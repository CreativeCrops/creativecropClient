if( window._lyteUiUtils ) {
	window._lyteUiUtils[ 'i18n' ] = function(key) {
		var ret = _lyteUiComponentsLocale[ !key? '':key ];
		return ret? ret: key;
	}
}
else {
	window._lyteUiUtils = {}
	window._lyteUiUtils[ 'i18n' ] = function(key) {
		var ret = _lyteUiComponentsLocale[ !key? '':key ];
		return ret? ret: key;
	}
}

LyteComponent.registerHelper("lyteUiReturnOnlyKey",function(item){
	var objectkeys = Object.keys(item)
	if(objectkeys)
		{
			return objectkeys[0]
		}
	else
		{
			return false
		}
});
LyteComponent.registerHelper("lyteUiReturnOnlyValue",function(item){
	var objectkeys = Object.keys(item)
	return item[objectkeys[0]]
});

/**
 * Helper to return url when flag is true
 * @param {string} url - The url to return
 * @param {boolean} flag - True returns the URL , false returns an empty string
 *
 */

Lyte.Component.registerHelper( 'lyteUiSetURL', function( url, flag ) {

	if( flag ) {
		return url;
	} else {
		return '';
	}

} );


/**
 * Helper to check if an entire row in the calendar is empty or not
 * @param {object} vector - an array of objects where each object contains a particular date
 *
 */

LyteComponent.registerHelper( 'lyteUiCheckEmpty', function( vector ) {
	return vector && vector[ 0 ].emptyBlock && vector[ 6 ].emptyBlock;
} );


LyteComponent.registerHelper("lyteUiI18n",function(key){
	return _lyteUiUtils.i18n(key);
});

LyteComponent.registerHelper("lyteUiOptGroupCheck", function(content){
		if(content.constructor == Object)
            {
              if(Object.keys(content).length == 1)
	              {
	              	var value = content[Object.keys(content)[0]]
	              	if(value.constructor == Object || value.constructor == Array)
	                  {
	                      return true
	                  }
	               }
            }
        return false
});
LyteComponent.registerHelper("lyteUiCheckForType",function(item,ltPropUserValue,ltPropSystemValue,section){
	if(section){
		var count = 0;
		var tcount = 0;
		for(var key in item){
			tcount++;
			if(key == ltPropUserValue){
				count++;
			}
			if(key == ltPropSystemValue){
				count++;
			}
		}
		if(count == 2 || tcount != 1){
			return false;
		}
		else{
			return true
		}
	}
	else{
		if(typeof item == "object"){
			return true
		}
		else{
			return false
		}
	}
});
LyteComponent.registerHelper("lyteUiChildPadding", function(treeIcon) {

	if ( treeIcon === 'Arrow' ) {
		return "padding-left:20px;";
	} else if (treeIcon === 'Plus') {
		return "padding-left:25px;";
	} else {
		return "padding-left:27px;";
	}
});
LyteComponent.registerHelper("lyteUiHaveChildren", function(treeData,key) {

	if ( treeData[key] && treeData[key].length > 0 ) {

		return true;
	}
	return false;
});
LyteComponent.registerHelper("lyteUiIsObject", function(obj) {

	if ( Object.prototype.toString.call(obj) === "[object Object]" ) {
		return true;
	} else {
		return false;
	}
});
LyteComponent.registerHelper("lyteUiIsArray", function(obj) {

	if ( Object.prototype.toString.call(obj) === "[object Array]") {
		return true;
	} else {
		return false;
	}
});
LyteComponent.registerHelper('lyteUiGiveProper',function(full,val){
	var returnval = []
	for(var i=0;i<full.length;i++){
		if(full[i].menu == val){
			returnval.push(full[i])
		}
	}
	return returnval
});
LyteComponent.registerHelper('lyteUiAddClassModal',function(className,show,drag){
	var resp = className;
	if(drag){
		resp += " draggable";
	}
	if(show){
		resp += " "+className+"Show";
	}
	return resp;
});

LyteComponent.registerHelper('lyteUiAddShowClass',function(a,b,c){
	if(a === true){
		return b+" "+c;
	}
	return b;
});


LyteComponent.registerHelper('lyteUiCatwise',function(a,b){
    if(a==b[this.get('ltPropCategory')]){
        return true
    }
      else {
        return false
    }
});

LyteComponent.registerHelper('lyteUiCheckClassForDate',function(val){
	if(!val){
		return false;
	}
	if(val.indexOf('lyteCalGray') != -1){
		return true
	}
	return false
});

LyteComponent.registerHelper('lyteUiConcat',function(){
	var resp = '';
	var argLength = arguments.length;
	for(var i=0;i<argLength;i++){
		if(arguments[i] != undefined){
			resp += arguments[i];
		}
	}
	return resp;
});

LyteComponent.registerHelper('lyteUiConcatTypeClass',function(a,b,c){
	if(a!==""){
		return a+b+" "+c;
	}
	return c;
});

LyteComponent.registerHelper('lyteUiGetContainerClass',function(setselect,classval){
	var toRet=''
	if(!classval){
		classval = ''
	}
    if(setselect==true){
    	toRet = 'lyteDropdownContainer tick-selection ' + classval
    }
    else{
    	toRet = 'lyteDropdownContainer ' + classval
    }
    return toRet

});

LyteComponent.registerHelper('lyteUiGetDropdownClass',function(arg1){
	if(arg1 && arg1.toString().toLowerCase()  == "true"){
		return 'lyteDropdownElement1 lyteDropdown-disabled'
	}
	else{
		return 'lyteDropdownElement1'
	}
});

LyteComponent.registerHelper('lyteUiIfEquals',function(a,b){
	return a === b;
});

LyteComponent.registerHelper('lyteUiLabelCheck',function(a,b){
	if(a==b){
		return true;
	}
	else {
		return false
	}
});

LyteComponent.registerHelper('lyteUiObjectCheck',function(a){
    if(typeof a==='string'){
        return true;
    }
    else {
        return false
    }
});

LyteComponent.registerHelper('lyteUiReturnValueBy',function(content,key){
	if(key || key == 0){
		return content[key]
	}
	else{
		return content
	}
});
// LyteComponent.registerHelper('lyteUiHeaderCheck',function(value){
// 	if(value)
// 		{
// 			return true;
// 		}
// 	else
// 		{
// 		return false;
// 		}
// });
LyteComponent.registerHelper('lyteUiSetWH',function(radius){
	return parseInt(radius) * 2;
});
LyteComponent.registerHelper('lyteUiSetRadius',function(radius,stroke){
	return parseInt(radius)-parseInt(stroke)/2;
});
LyteComponent.registerHelper('lyteUiSetDashArray',function(radius,stroke){
	var r = parseInt(radius)-parseInt(stroke)/2;
	return  2 * 3.14159 * r;
});
LyteComponent.registerHelper('lyteUiSetOffset',function(radius,stroke,value){
	var r = parseInt(radius)-parseInt(stroke)/2;
	var strokeDash =  2 * 3.14159 * r;
	return strokeDash * (1 - parseInt(value)/100);
});
LyteComponent.registerHelper('lyteUiTextTransform',function(radius){
	return 'translate(0,-'+parseInt(radius) * 2+')';
});
LyteComponent.registerHelper('lyteUiMakeSortable',function(elementId){
	console.log(elementId);
	document.getElementById(elementId).classList.add('sortable');
	return true;
});
LyteComponent.registerHelper("lyteUiCheckTabPosition",function(position){
	if(position.pos === "bottom"){
		return false;
	}
	else{
		return true;
	}
});

LyteComponent.registerHelper('lyteUiGetValue',function(object, key){
	return object[key]
});

LyteComponent.registerHelper('lyteUiIsEmptyArray',function(obj){
     return obj.length == 0;
});
LyteComponent.registerHelper("lyteRgbToHex",function(item){
	var valArray = item.substring(4,item.length-1).split(",");
	var hexValue = "#";
	for(var i=0;i<3;i++){
		var val = parseInt(valArray[i]).toString(16).toUpperCase();
		if(val.length < 2){
			val = "0"+val;
		}
		hexValue += val;
	}
	return hexValue;
});
LyteComponent.registerHelper("lyteCPInsertBreak",function(index){
	if((index + 1)%10 == 0){
		return true;
	}
	return false;
});
LyteComponent.registerHelper("lyteUiCheckInRange",function(start,end,current){
	if(start === '' && end === ''){
		return true;
	}
	else if(start !== '' && end === ''){
		var startDate = new Date(start)
		var currentDate = new Date(current)
		if(currentDate >= startDate){
			return true
		}
	}
	else if(start !== '' && end !== ''){
		var startDate = new Date(start)
		var endDate = new Date(end)
		var currentDate = new Date(current)
		if(currentDate >= startDate && currentDate <= endDate){
			return true
		}
	}
	else {
		var endDate = new Date(end)
		var currentDate = new Date(current)
		if(currentDate <= endDate){
			return true
		}
	}
	return false
});
LyteComponent.registerHelper("lyteUiIsEmptyObject",function(item){
	for(var key in item) {
        if(item.hasOwnProperty(key)){
            return false;
        }
    }
    return true;
});
LyteComponent.registerHelper("lyteUiCheckDisabled",function(list,value){
	for(var i = 0; i<list.length; i++){
		if(value === list[i]){
			return "true";
		}
	}
    return "false";
});

LyteComponent.registerHelper("lyteUiTreeHelp",function(varr,index){
	return varr + index++ ;
});

LyteComponent.registerHelper("lyteUiTreeChildHelp",function(val,clas){

	if((val.children === undefined)||(val.children.length === 0)){
		return 'noChildClass';
	}

	return '';

});

/* Needs more thought and testing */
Lyte.Component.register( 'lyte-accordion', {
_template:"<template tag-name=\"lyte-accordion\">\t<lyte-yield yield-name=\"yield\">\t</lyte-yield></template>",
_dynamicNodes : [{"type":"insertYield","position":[1]}],
_observedAttributes :["ltPropDuration","ltPropHeight","ltPropExclusive","ltPropYield"],
	data: function() {
		return { 
			'ltPropDuration': Lyte.attr( 'string', { 
				'default': '0.2s' 
			} ),
			'ltPropHeight': Lyte.attr( 'string' ),
			'ltPropExclusive': Lyte.attr( 'boolean', { 
				'default': true
			} ),
			'ltPropYield': Lyte.attr( 'boolean', { 
				'default': true 
			} )
		}
	},

	execAndCheck: function( name, event ) {
		var arg, ret;

		arg = _lyteAccordion.findProperParent( event.target ).parentElement;
	 	ret = this.executeMethod( name, event, arg, this );
	 	ret = ret == undefined ? true : ret;
	 	return ret;
	},

	initiateClose: function( activeElement, cb, event ) {
		activeElement.style.height = '0px';
	 	activeElement.style.paddingTop = '0px';
	 	activeElement.style.paddingBottom = '0px';
		activeElement.style.overflow = 'hidden';	
		activeElement.parentElement.classList.remove( 'lyteAccordionActive' );
		if( cb ) {
			$L.fastdom.measure( function() {
				cb.call( this, event );
			}, this );
		}
	},

	execNonRetCalls: function( arr ) {
		if( this.getMethods( arr[ 0 ] ) ) {
			this.executeMethod.apply( this, arr );
	 	}
	},

	initiateOpen: function( sibling, configuration, event ) {
		var heightToSet =  configuration.height, ret;

	 	if( 
	 		this.getData( 'heights' )[ sibling.getAttribute( 'map' ) ].conf 
	 		&& heightToSet 
	 	) {
	 		sibling.style.height = heightToSet
	 	}
	 	else{
	 		sibling.style.height = this.getData( 'heights' )[ sibling.getAttribute( 'map' ) ].height
	 	}

	 	sibling.style.overflow = 'auto';
	 	sibling.style.paddingTop = '15px';
	 	sibling.style.paddingBottom = '15px';
	 	sibling.parentElement.classList.add( 'lyteAccordionActive' );
	 	ret = _lyteAccordion.findProperParent( event.target );
	 	$L.fastdom.measure( function() {
	 		this.execNonRetCalls( [  'onOpen', event, ret.parentElement, this ] );
	 		this.execNonRetCalls( [ 'onChanged', event, ret.parentElement, this ] );
	 	}, this );
	},

	didDestroy: function() {
		var allNodes = this.$node.querySelectorAll( 'lyte-accordion-item' ), i = 0, curValue;
		for( ; i < allNodes.length; i++ ) {
			curValue = allNodes[ i ].getAttribute( 'lyte-shortcut' );
			if( curValue ) {
				allNodes[ i ].setAttribute( 'lyte-shortcut', JSON.stringify( {} ) );
			}
		}
	},

	getAllHeights: function() {
		this.setData( 'heights', {} );		
		$L.fastdom.measure( function() {
			var node = this.$node.querySelector( 'lyte-yield' ), nodes = node.children, 
			i = 0, body, isStyle, inlineHeight = false, exclusive;
			for( ; i < nodes.length; i++ ) {
				if( nodes[ i ].tagName == 'TEMPLATE' ) {
					continue;
				}

				body = nodes[ i ].children[ 1 ];
				if( !body || body.tagName == 'TEMPLATE' ) {
					continue;
				}

				isStyle = body.style.height;
				this.getData( 'heights' )[ i ] = {};
				if( !isStyle ) {
					this.getData( 'heights' )[ i ].height = body.getBoundingClientRect().height + 'px';
					this.getData( 'heights' )[ i ].conf = true;
				}
				else {
					this.getData( 'heights' )[ i ].height = isStyle;
					this.getData( 'heights' )[ i ].conf = false;
				}

				if( 
					nodes[ i ].classList.contains( 'lyteAccordionActive' ) 
					&& this.getData( 'ltPropExclusive' ) 
				) {
					this.flag = i;
				}
			}
		}, this );
		
		$L.fastdom.mutate( function() {
			var node = this.$node.querySelector( 'lyte-yield' ), nodes = node.children,
			exclusive = this.getData( 'ltPropExclusive' ), i = 0, body;

			for( ; i < nodes.length; i++ ) {
				if( nodes[i].tagName == 'TEMPLATE' ) {
					continue;
				}

				body = nodes[ i ].children[ 1 ];
				if( !body || body.tagName == 'TEMPLATE' ) {
					continue;
				}
				
				body.setAttribute( 'map', i );
				if( !nodes[ i ].classList.contains( 'lyteAccordionActive' ) ) {
					body.style.height = '0px';
					body.style.paddingTop = '0px';
					body.style.paddingBottom = '0px';
				}
				else if( exclusive ) {
					if( this.flag != i ) {
						nodes[ i ].classList.remove( 'lyteAccordionActive' );
						body.style.height = '0px';
						body.style.paddingTop = '0px';
						body.style.paddingBottom = '0px';
					}
					else {
						
						// Doing this to achieve this precedence: inline style > ltPropHeight > boundingClientRect
						body.style.height = !this.getData( 'heights' )[ i ].conf ? 
												this.getData( 'heights' )[ i ].height :
												this.getData( 'ltPropHeight' ) ? 
													this.getData( 'ltPropHeight' ) : 
													this.getData( 'heights' )[ i ].height
					}
				}
				else {
					body.style.height = !this.getData( 'heights' )[ i ].conf ? 
											this.getData( 'heights' )[ i ].height :
											this.getData( 'ltPropHeight' ) ? 
												this.getData( 'ltPropHeight' ) : 
												this.getData( 'heights' )[ i ].height
				}
			}

			$L.fastdom.measure( function() {
				this.execNonRetCalls( [ 'afterRender', this ] );
			}, this );
		}, this );
		
	},

	didConnect: function() {		
		this.getAllHeights()
	},

	getConfiguration: function() {
		var config = {};
		
		config.transition = this.getData( 'ltPropDuration' )
		config.height = this.getData( 'ltPropHeight' )
		config.exclusive = this.getData( 'ltPropExclusive' )
		return config;
	}
} );

var _lyteAccordion = {
	findProperParentS: function( elm ) {
		var properparent, stack = [], found = false, i;
		while( elm.tagName != "LYTE-YIELD" && elm.tagName != 'HTML'){
			properparent = elm;
			stack.push( elm );
			elm = elm.parentElement;
		}

		for( i = stack.length - 1; i > -1; i-- ) {
			if( stack[ i ].tagName === 'LYTE-ACCORDION-HEADER' 
				|| ( stack.length === 1 && stack[ i ].tagName === 'LYTE-ACCORDION-ITEM' ) 
			) {
				found = true
				break;
			}
		}

		if( !found ) {
			return null;
		}

		return properparent.children[ 0 ]

	},

	findProperParent: function( element ) {
		var properparent;

		if( !element ) {
			return ;
		}
		while( element.tagName != "LYTE-YIELD" && element.tagName != 'HTML' ) {
			properparent = element;
			element = element.parentElement;
		}
		return properparent.children[0];

	}
}

document.addEventListener( 'click', function( event ) {
	var elementClicked = _lyteAccordion.findProperParentS( event.target ), 
	parent, temp, childs, flag, i = 0, sibling, component, configuration, transition,
	openElement, bodyElement, returnval, itsStyle, activeElement;

	if( !elementClicked ) {
		return ;
	}

	parent  = elementClicked
	while(
		parent.tagName != 'HTML' 
		&& parent.tagName != 'LYTE-ACCORDION'
	) {
		parent = parent.parentElement
		if( !parent ) {
			return ;
		}
	}

	// This is a safety check because it is generally guaranteed to be a LYTE-ACCORDION Element
	if( parent.tagName == 'HTML' ) {
		return ;
	}

	temp  = parent.querySelector( 'lyte-yield' );
	childs = temp.children;
	flag = true;

	// why is this here??
	for( ; i < childs.length; i++ ) {
		if( childs[i].children[ 0 ] == elementClicked ) {
			flag = false
			break;
		}
	}

	if( flag ) {
		return ;
	}

	/* sibling - The lyte-accordion-body tag of current clicked accordion item */

	sibling = temp.children[ i ].children[ 1 ];
	component = temp.parentElement.component;
	configuration = component.getConfiguration();
	transition = configuration.transition;

	/* When they haven't provided a lyte-accordion-body tag */
	if(
		!sibling 
		|| sibling.tagName != 'LYTE-ACCORDION-BODY'
	) {
		// Close accordion
 		if( 
 			configuration 
 			&& configuration.exclusive 
 			&& ( openElement = component.$node.querySelector( '.lyteAccordionActive' ) )
 			&& ( bodyElement = openElement.querySelector( 'lyte-accordion-body' ) )
 		 ) {
 			
 			bodyElement.style.transitionDuration = transition;
 			if( component.getMethods( 'onBeforeClose' ) ) {
 				returnval = component.execAndCheck( 'onBeforeClose', event );
	 			if( returnval ){
	 				component.initiateClose( openElement.children[ 1 ], function( e ) {
	 					this.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );
	 				}, event );
	 			}
	 			else {
	 				return ;
	 			} 			
	 		}
	 		else {
	 			component.initiateClose( openElement.children[ 1 ], function( e ) {
	 				this.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );
	 			}, event );		
	 		}
 		}


 		if( temp.children[ i ].classList.contains( 'lyteAccordionActive' ) ) {
 			temp.children[ i ].classList.remove( 'lyteAccordionActive' )
 		}
 		else {
 			temp.children[i].classList.add( 'lyteAccordionActive' )
 		}

 		$L.fastdom.measure( function() {
 			component.execNonRetCalls( [ 'onChanged',event, _lyteAccordion.findProperParent( event.target ).parentElement, component ] );
 		} )
 		
		return ;
	}

	itsStyle = window.getComputedStyle( sibling ).height;
 	if( transition ) {
 		sibling.style.transitionDuration = transition

 		// Added so that it slides the first time as well
 		if( ( openElement = component.$node.querySelector( '.lyteAccordionActive' ) )
 			&& ( bodyElement = openElement.querySelector( 'lyte-accordion-body' ) ) ) {
 			 	bodyElement.style.transitionDuration = transition;
 		}
 	}

 	activeElement = component.$node.querySelector( '.lyteAccordionActive' );

 	// Close the already opened accordion-item in exclusive accordion. 
	if( 
		configuration 
		&& configuration.exclusive 
		&& activeElement 
		&& activeElement != sibling.parentElement
	) {	
		if( 
			activeElement.children[ 1 ] 
			&& activeElement.children[ 1 ].tagName == 'LYTE-ACCORDION-BODY' 
			&& component.getMethods( 'onBeforeClose' ) 
		) {
			returnval = component.execAndCheck( 'onBeforeClose', event );
	 		if( returnval ) {
	 			component.initiateClose( activeElement.children[ 1 ], function( e ) {
	 				this.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );
	 			}, event );
	 		}
	 		else {
	 			return ;
	 		} 			
		}
	 	else if( 
	 		activeElement.children[ 1 ] 
	 		&& activeElement.children[ 1 ].tagName == 'LYTE-ACCORDION-BODY' 
	 	) {
	 		component.initiateClose( activeElement.children[ 1 ], function( e ) {
	 			this.execNonRetCalls( [ 'onClose', e, _lyteAccordion.findProperParent( e.target ).parentElement, this ] );
	 		}, event );
	 	}

	 	// If the element has no bodyelement you still need to remove it.
 		if( activeElement.classList.contains( 'lyteAccordionActive' ) ) {
 			activeElement.classList.remove( 'lyteAccordionActive' )
 		}
		
	}
	
	// itsStyle.height = '0px' -> Meaning it is closed
	if( itsStyle == '0px' ) {
	 	
	 	if( component.getMethods( 'onBeforeOpen' ) ) {
	 		returnval = component.execAndCheck( 'onBeforeOpen', event );
	 		if( returnval ) {
	 			component.initiateOpen( sibling, configuration, event );
	 		}
	 		else {
	 			return ;
	 		}	 		
	 	}
	 	else {
	 		component.initiateOpen( sibling, configuration, event );
	 	}
	 }

	 // It is open so close it
	 else {
	 	if( component.getMethods( 'onBeforeClose' ) ) {
	 		returnval = component.execAndCheck( 'onBeforeClose', event );
	 		if( returnval ) {
	 			component.initiateClose( sibling, function( e ) {
	 				var ret =  _lyteAccordion.findProperParent( e.target );
	 				this.execNonRetCalls( [ 'onClose', e, ret.parentElement, this ] );
	 				this.execNonRetCalls( [ 'onChanged', e, ret.parentElement, this ] );
	 			}, event );
	 		}
	 		else{
	 			return;
	 		}
	 	}
	 	else {
	 		component.initiateClose( sibling, function( e ) {
	 			var ret =  _lyteAccordion.findProperParent( e.target );
	 			this.execNonRetCalls( [ 'onClose', e, ret.parentElement, this ] );
	 			this.execNonRetCalls( [ 'onChanged', e, ret.parentElement, this ] );
	 		}, event );
	 	}
	 }
}, true );

Lyte.createCustomElement( "lyte-accordion-item", {
	static: {
		"observedAttributes": {
			get: function() {
				return [ 'lyte-shortcut' ]; 
			}
		}
	},

	"attributeChangedCallback": function( attributeName, oldValue, newValue, namespace ) {
		if( typeof shortcut == "function" ){
         	if( !newValue ) {
            	return ;
          	}

          	newValue = JSON.parse( newValue )
          	if( !newValue.key ){
            	return ;
          	}

          	var newKey = newValue.key, type = newValue.type, wait = newValue.wait;
          	if( !oldValue ){
            	oldValue = {};
          	}

          	shortcut.push( {
            	newKey: newKey,
            	type: type,
            	wait: wait,
            	oldKey: oldValue.key,
            	value: this
         	} )
      	}
	}
} );

if(!LytePopup){
    var LytePopup = {
        components:[],
        onEscape : function(evt){
            evt = evt || window.event;
            var isEscape = false;
            if ("key" in evt) {
                isEscape = (evt.key == "Escape" || evt.key == "Esc");
            } else {
                isEscape = (evt.keyCode == 27);
            }
            if (isEscape) {
                LytePopup.closePopup(undefined,true);
            }
        },
        bindDocumentKeydown : function(){
            document.addEventListener('keydown',LytePopup.onEscape,true);
        },
        addPopup : function(component) {
            LytePopup.closePopup();
            var compLengh = LytePopup.components.length;
            if(compLengh>0){
                var prevZIndex = 0;
                var prePopup = '', thisPopup = '', thisFreeze = '';
                if(LytePopup.components[compLengh-1].$node.tagName == "LYTE-MODAL"){
                    prePopup = '.lyteModal';
                }
                else if(LytePopup.components[compLengh-1].$node.tagName == "LYTE-POPOVER"){
                    prePopup = '.lytePopover';
                }  
                else{
                    prePopup = '.alertPopup';
                }

                if(component.$node.tagName == "LYTE-MODAL"){
                    thisPopup = '.lyteModal';
                    thisFreeze = '.lyteModalFreeze';
                }
                else if(component.$node.tagName == "LYTE-POPOVER"){
                    thisPopup = '.lytePopover';
                    thisFreeze = '.lytePopoverFreeze';
                }
                else{
                    thisPopup = '.alertPopup';
                    thisFreeze = '.alertFreezeLayer';
                }
                var node = LytePopup.components[compLengh-1].childComp.querySelector(prePopup);
                prevZIndex = Number(document.defaultView.getComputedStyle(node,null).getPropertyValue('z-index'));
                component.childComp.querySelector(thisPopup).style.zIndex = prevZIndex+2;
                if(component.$node.ltProp('freeze') && component.childComp.querySelector(thisFreeze)){
                    component.childComp.querySelector(thisFreeze).style.zIndex = prevZIndex+1;
                }
            }
            LytePopup.components[compLengh] = component;
        },
        closePopup : function(component,fromEscape){
            if(fromEscape){
                var lastPop = LytePopup.components[LytePopup.components.length-1];
                if(lastPop && lastPop.$node.ltProp("closeOnEscape")){
                    lastPop.$node.ltProp("show",false);
                }
            }
            else{
                if(component){
                    LytePopup.components.splice(LytePopup.components.indexOf(component),1);
                }
                else{
                    for(var i=LytePopup.components.length-1;i>=0;i--){
                        if(LytePopup.components[i].$node && !LytePopup.components[i].$node.ltProp("allowMultiple")){
                            LytePopup.components[i].$node.ltProp("show",false);
                        }
                    }
                }   
            }  
        }   
    };
    LytePopup.bindDocumentKeydown();
};


//component
Lyte.Component.register("lyte-alert",{
_template:"<template tag-name=\"lyte-alert\">\t<template is=\"if\" value=\"{{ltPropShowCopy}}\">\t\t<template case=\"true\"><lyte-wormhole>\t\t\t<template is=\"registerYield\" yield-name=\"lyte-content\">\t\t\t\t<div class=\"alertWrapper {{ltPropWrapperClass}}\">\t\t\t\t\t\t<div class=\"alertPopup\">\t\t\t\t\t\t<template is=\"if\" value=\"{{ltPropShowCloseButton}}\">\t\t\t\t\t\t\t<template case=\"true\"><span class=\"lyte-svg alertClose\" onclick=\"{{action('closeAlert')}}\"></span></template>\t\t\t\t\t\t</template>\t\t\t\t\t\t<template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\">\t\t\t\t\t\t\t<lyte-yield yield-name=\"alert\"></lyte-yield>\t\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIfEquals(ltPropHeading,'')}}\">\t\t\t\t\t\t\t\t<template case=\"false\"><div class=\"alertHeader\">\t\t\t\t\t\t\t\t\t<span class=\"dBlock\">{{ltPropHeading}}</span>\t\t\t\t\t\t\t\t</div></template>\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t<div class=\"alertContent\">\t\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIfEquals(ltPropType,'')}}\">\t\t\t\t\t\t\t\t\t<template case=\"false\"><div class=\"alertContentMiddle\">\t\t\t\t\t\t\t\t\t\t<span class=\"{{lyteUiConcatTypeClass(ltPropType,'AlertIcon','lyteStatusIcon')}}\"></span>\t\t\t\t\t\t\t\t\t</div></template>\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t<div class=\"alertContentMiddle\">\t\t\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIfEquals(ltPropPrimaryMessage,'')}}\">\t\t\t\t\t\t\t\t\t\t<template case=\"false\"><div>\t\t\t\t\t\t\t\t\t\t\t<span class=\"alertPrimaryMsg\">{{ltPropPrimaryMessage}}</span>\t\t\t\t\t\t\t\t\t\t</div></template>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIfEquals(ltPropSecondaryMessage,'')}}\">\t\t\t\t\t\t\t\t\t\t<template case=\"false\"><div>\t\t\t\t\t\t\t\t\t\t\t<span class=\"alertSecondaryMsg\">{{ltPropSecondaryMessage}}</span>\t\t\t\t\t\t\t\t\t\t</div></template>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t\t<div class=\"clearFloat\"></div>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t</template></template>\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIsEmptyArray(ltPropButtons)}}\">\t\t\t\t\t\t\t<template case=\"false\"><div class=\"{{lyteUiConcat('alertFooter ',ltPropButtonPosition)}}\">\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{ltPropButtons}}\">\t\t\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIfEquals(item.type,'accept')}}\">\t\t\t\t\t\t\t\t\t\t<template case=\"true\"><lyte-button class=\"lyteAlertBtn\" onclick=\"{{action('accept',item.text)}}\">\t\t\t\t\t\t\t\t\t\t\t<template is=\"registerYield\" yield-name=\"text\">{{item.text}}</template>\t\t\t\t\t\t\t\t\t\t</lyte-button></template>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIfEquals(item.type,'reject')}}\">\t\t\t\t\t\t\t\t\t\t<template case=\"true\"><lyte-button class=\"lyteAlertBtn\" onclick=\"{{action('reject',item.text)}}\">\t\t\t\t\t\t\t\t\t\t\t<template is=\"registerYield\" yield-name=\"text\">{{item.text}}</template>\t\t\t\t\t\t\t\t\t\t</lyte-button></template>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</div></template>\t\t\t\t\t\t</template>\t\t\t\t\t</div>\t\t\t\t\t<div class=\"{{lyteUiAddShowClass(ltPropShowCopy,'','alertFreezeLayer')}}\" style=\"{{lyteUiConcat('background:',ltPropDimmer.color,';','opacity:',ltPropDimmer.opacity)}}\"></div>\t\t\t\t</div>\t\t\t</template>\t\t</lyte-wormhole></template>\t</template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[0,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"false":{"dynamicNodes":[{"type":"text","position":[0,1,0]}]}},"default":{}},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"false":{"dynamicNodes":[{"type":"attr","position":[0,1]}]}},"default":{}},{"type":"attr","position":[3,3,1]},{"type":"if","position":[3,3,1],"cases":{"false":{"dynamicNodes":[{"type":"text","position":[0,1,0]}]}},"default":{}},{"type":"attr","position":[3,3,3]},{"type":"if","position":[3,3,3],"cases":{"false":{"dynamicNodes":[{"type":"text","position":[0,1,0]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,1,5]},{"type":"if","position":[1,1,5],"cases":{"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"attr","position":[0,1]},{"type":"for","position":[0,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"registerYield","position":[0,1],"dynamicNodes":[{"type":"text","position":[0]}]},{"type":"componentDynamic","position":[0]}]}},"default":{}},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"registerYield","position":[0,1],"dynamicNodes":[{"type":"text","position":[0]}]},{"type":"componentDynamic","position":[0]}]}},"default":{}}]}]}},"default":{}},{"type":"attr","position":[1,3],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'background:'","ltPropDimmer.color","';'","'opacity:'","ltPropDimmer.opacity"]}}}}]},{"type":"componentDynamic","position":[0]}]}},"default":{}}],
_observedAttributes :["ltPropType","ltPropShow","ltPropWrapperClass","ltPropHeading","ltPropPrimaryMessage","ltPropSecondaryMessage","ltPropButtons","ltPropButtonPosition","ltPropShowCloseButton","ltPropCloseOnEscape","ltPropDimmer","ltPropAllowMultiple","ltPropTop","ltPropYield"],
	data: function(){
        return {
    		//config from callee
    		"ltPropType":Lyte.attr("string",{"default": "success"}),
    		"ltPropShow":Lyte.attr("boolean",{"default": false}),
            "ltPropWrapperClass":Lyte.attr("string",{"default": ""}),
    		"ltPropHeading":Lyte.attr("string",{"default": ""}),
    		"ltPropPrimaryMessage":Lyte.attr("string",{"default": ""}),
    		"ltPropSecondaryMessage":Lyte.attr("string",{"default": ""}),
    		"ltPropButtons":Lyte.attr("array",{"default": [{"type":"accept","text":"Ok"}]}),
    		"ltPropButtonPosition":Lyte.attr("string",{"default": "right"}),
    		"ltPropShowCloseButton":Lyte.attr("boolean",{"default": true}),
    		"ltPropCloseOnEscape":Lyte.attr("boolean",{"default": true}),
    		"ltPropDimmer":Lyte.attr("object",{"default":{"color":"black","opacity":"0.4"}}),
            "ltPropAllowMultiple":Lyte.attr("boolean",{"default": false}),
            "ltPropTop":Lyte.attr("string",{"default":"40px"}),
            "ltPropYield":Lyte.attr("boolean",{"default":false})
        }
	},
	showToggled : function() {
		if(this.$node.ltProp("show")){
			this.showAlert();
		}
		else{
			this.closeAlert();
		}
	}.observes('ltPropShow'),
	closeAlertFn : function(){
		if(this.getMethods("onClose")){
			this.executeMethod("onClose");	
		}
	},
    showAlert : function(){
        var self = this;
        setTimeout(function(){
            if(self.getData('ltPropTop') == "center"){
                var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
                self.actualModalDiv.style.top = (h - self.actualModalDiv.getBoundingClientRect().height)/2 + "px";
            }
            else{
                self.actualModalDiv.style.top = self.getData('ltPropTop');
            }
        },10);
        this.setData('ltPropShowCopy',true);
        if(this.getData('ltPropButtons')){
            var buttons = this.getData('ltPropButtons');
            var buttonComp;
            for(var i=0; i<buttons.length; i++){
                buttonComp = this.actualModalDiv.querySelectorAll(".lyteAlertBtn")[i];
                if(buttons[i].appearance){
                    buttonComp.setData('ltPropAppearance',buttons[i].appearance);
                }
                if(buttons[i].disabled){
                    buttonComp.setData('ltPropDisabled',buttons[i].disabled);
                }
                if(buttons[i].style){
                    buttonComp.setData('ltPropStyle',buttons[i].style);
                }
                if(buttons[i].color){
                    buttonComp.setData('ltPropColor',buttons[i].color);
                }
                if(buttons[i].backgroundColor){
                    buttonComp.setData('ltPropBackgroundColor',buttons[i].backgroundColor);
                }
                if(buttons[i].tabIndex){
                    buttonComp.setData('ltPropTabIndex',buttons[i].tabIndex);
                }
                if(buttons[i].type){
                    buttonComp.setData('ltPropType',buttons[i].type);
                }
                if(buttons[i].id){
                    buttonComp.setData('ltPropId',buttons[i].id);
                }
                if(buttons[i].class){
                    buttonComp.setData('ltPropClass',buttons[i].class);
                }
                if(buttons[i].autoFocus){
                    buttonComp.setData('ltPropAutoFocus',buttons[i].autoFocus);
                }
                if(buttons[i].lyteShortcut){
                    buttonComp.setData('ltPropLyteShortcut',buttons[i].lyteShortcut);
                }
                if(buttons[i].name){
                    buttonComp.setData('ltPropName',buttons[i].name);
                }
                if(buttons[i].value){
                    buttonComp.setData('ltPropValue',buttons[i].value);
                }
            }
            buttonComp = null;
        }
        LytePopup.addPopup(this);
    },
    closeAlert : function(){
        this.actualModalDiv.style.top = "-"+(this.actualModalDiv.getBoundingClientRect().height+this.actualModalDiv.getBoundingClientRect().top+40)+"px";
        var animDur = parseFloat(document.defaultView.getComputedStyle(this.actualModalDiv).getPropertyValue("transition-duration")) * 1000;
        var self = this;
        setTimeout(function(){
            self.setData('ltPropShowCopy',false);
        },animDur-100);
        this.closeAlertFn();

        LytePopup.closePopup(this);
        // this.actualModalDiv = null;
        // this.childComp = null;
    },
	actions: {
        wormholeDidConnect : function(){
            this.childComp = this.$node.querySelector('lyte-wormhole');
            this.actualModalDiv = this.childComp.querySelector(".alertPopup");
            LyteComponent.appendChild(document.body,this.childComp);
        },
		closeAlert : function(){
            this.$node.ltProp("show",false);            
		},
		accept : function(buttonText){
			if(this.getMethods("onAccept")){
				this.executeMethod("onAccept",buttonText);	
			}
            this.$node.ltProp("show",false);            
		},
		reject : function(buttonText){
			if(this.getMethods("onReject")){
				this.executeMethod("onReject",buttonText);	
			}
            this.$node.ltProp("show",false);
		}
	}
});

Lyte.Component.register("lyte-autocomplete",{
_template:"<template tag-name=\"lyte-autocomplete\">         <lyte-dropdown lt-prop-set-pos=\"{{ltPropSetPos}}\" lt-prop-type=\"{{ltPropDropType}}\" lt-prop-yield=\"true\" lt-prop-freeze=\"{{ltPropFreeze}}\" lt-prop-callout=\"{{ltPropCallout}}\" lt-prop-show=\"{{ltPropShow}}\" lt-prop-position=\"{{ltPropPosition}}\" lt-prop-hover=\"{{ltPropHover}}\" lt-prop-disabled=\"{{ltPropDisabled}}\" lt-prop-boundary=\"{{ltPropBoundary}}\" lt-prop-tabindex=\"{{ltPropTabindex}}\" on-option-selected=\"{{method('valSet')}}\" on-show=\"{{method('show')}}\" on-hide=\"{{method('hide')}}\" on-before-show=\"{{method('beforeShow')}}\" on-before-hide=\"{{method('beforeHide')}}\" on-add=\"{{method('add')}}\" on-remove=\"{{method('remove')}}\" on-position-changed=\"{{'positionChanged'}}\" on-scroll=\"{{method('scroll')}}\">        <template is=\"registerYield\" yield-name=\"yield\">              <lyte-drop-button onkeyup=\"{{action('keyup', event)}}\" onclick=\"{{action('clickThrow', event)}}\">                     <lyte-input lt-prop-maxlength=\"{{ltPropMaxlength}}\" lt-prop-auto-update=\"{{ltPropAutoUpdate}}\" on-value-change=\"{{method('valuechange')}}\" lt-prop-tab-index=\"{{ltPropTabIndex}}\" lt-prop-id=\"{{ltPropId}}\" lt-prop-wrapper-style=\"{{ltPropWrapperStyle}}\" lt-prop-class=\"{{ltPropClass}}\" lt-prop-autofocus=\"{{ltPropAutofocus}}\" lt-prop-autocomplete=\"{{ltPropAutocomplete}}\" lt-prop-type=\"{{ltPropType}}\" lt-prop-name=\"{{ltPropName}}\" lt-prop-placeholder=\"{{ltPropPlaceholder}}\" lt-prop-value=\"{{lbind(ltPropValue)}}\" lt-prop-width=\"100%\" lt-prop-height=\"{{ltPropHeight}}\" lt-prop-style=\"{{ltPropStyle}}\" lt-prop-appearance=\"{{ltPropAppearance}}\" lt-prop-direction=\"vertical\" lt-prop-disabled=\"{{ltPropDisabled}}\" lt-prop-readonly=\"{{ltPropReadonly}}\" lt-prop-pattern=\"{{ltPropPattern}}\" rows=\"{{ltPropRows}}\" cols=\"{{ltPropCols}}\" title=\"{{ltPropInputTitle}}\" lt-prop-text-area-resize=\"{{ltPropTextAreaResize}}\" lt-prop-input-title=\"{{ltPropInputTitle}}\"></lyte-input>                     <div class=\"closeIconWrapper\" onclick=\"{{action('resetValue', event)}}\" style=\"{{if(ltPropValue, 'display: block;','display: none;')}}\">                        <span class=\"closeIcon\"></span>                    </div>                     <template is=\"if\" value=\"{{expHandlers(ltPropType,'==','search')}}\"><template case=\"true\">                        <span class=\"iconSeparator\" style=\"{{if(ltPropValue, 'display: block;','display: none;')}}\"></span>                     </template></template>              </lyte-drop-button>           <template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\">            <lyte-drop-box class=\"{{ltPropDropdownClass}}\" id=\"{{ltPropDropdownId}}\">              <lyte-drop-body>              <template is=\"for\" items=\"{{ltPropContent}}\" item=\"list\" index=\"indexVal\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(list)}}\"><template case=\"true\">                      <lyte-drop-group elemorder=\"{{indexVal}}\">                         <lyte-drop-label>{{lyteUiReturnOnlyKey(list)}}</lyte-drop-label>                            <template is=\"for\" items=\"{{lyteUiReturnOnlyValue(list)}}\" item=\"list1\" index=\"indexVal1\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(list1),'==',false)}}\"><template case=\"true\">                                             <lyte-drop-item grporder=\"{{indexVal}}\" elemorder=\"{{indexVal1}}\" data-value=\"{{list1}}\">                                                    <lyte-autocomplete-label keywords=\"{{list1}}\">{{list1}}</lyte-autocomplete-label>                                              </lyte-drop-item>                                        </template><template case=\"false\">                                            <lyte-drop-item grporder=\"{{indexVal}}\" elemorder=\"{{indexVal1}}\" data-value=\"{{list1[ltPropLabel]}}\" class=\"{{list1.class}}\">                                                <lyte-autocomplete-label keywords=\"{{list1[ltPropKeyWords]}}\">{{list1[ltPropLabel]}}</lyte-autocomplete-label>                                                    <template is=\"if\" value=\"{{list1[ltPropDescription]}}\"><template case=\"true\">                                                        <lyte-autocomplete-description>, {{list1[ltPropDescription]}}</lyte-autocomplete-description>                                                    </template></template>                                            </lyte-drop-item>                                    </template></template></template>                    </lyte-drop-group>                    </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(list),'==',false)}}\"><template case=\"true\">                                       <lyte-drop-item elemorder=\"{{indexVal}}\" data-value=\"{{list}}\">                                              <lyte-autocomplete-label keywords=\"{{list}}\">{{list}}</lyte-autocomplete-label>                                        </lyte-drop-item>                                </template><template case=\"false\">                                      <lyte-drop-item elemorder=\"{{indexVal}}\" data-value=\"{{list[ltPropLabel]}}\" class=\"{{list1.class}}\">                                          <lyte-autocomplete-label keywords=\"{{list[ltPropKeyWords]}}\">{{list[ltPropLabel]}}</lyte-autocomplete-label>                                              <template is=\"if\" value=\"{{list[ltPropDescription]}}\"><template case=\"true\">                                                  <lyte-autocomplete-description>, {{list[ltPropDescription]}}</lyte-autocomplete-description>                                              </template></template>                                      </lyte-drop-item>                                </template></template></template></template></template>                    </lyte-drop-body>                   </lyte-drop-box>          </template><template case=\"false\">                  <lyte-yield yield-name=\"yield\"></lyte-yield>            </template></template>        </template>      </lyte-dropdown>     </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropValue","'display: block;'","'display: none;'"]}}}},{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropValue","'display: block;'","'display: none;'"]}}}}]}},"default":{}},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}],
_observedAttributes :["ltPropAutocomplete","ltPropPlaceholder","ltPropAutofocus","ltPropDisabled","ltPropMaxlength","ltPropReadonly","ltPropId","ltPropClass","ltPropType","ltPropName","ltPropWidth","ltPropValue","ltPropContent","ltPropLabel","ltPropDescription","ltPropAppearance","ltPropDirection","ltPropExternalSearch","ltPropYield","ltPropHeight","ltPropHighlight","ltPropHighlightClass","ltPropKeyWords","ltPropMinLength","ltPropErrorClass","ltPropDropdownWidth","ltPropDropdownHeight","ltPropDropdownClass","ltPropDropdownId","ltPropMethod","ltPropWrapperStyle","ltPropAjaxRequest","ltPropTabIndex","ltPropTabindex","ltPropFreeze","ltPropCallout","ltPropShow","ltPropDisabled","ltPropHover","ltPropBoundary","ltPropPosition","ltPropDropType","ltPropSetPos","ltPropPattern","ltPropAutoUpdate","ltPropValueSet","ltPropPreventInsideClick","ltPropExtSearchOpen","ltPropInputTitle","ltPropRows","ltPropCols","ltPropTextAreaResize","timeout","optGroup","autocompleteFlag"],
    init : function(){
         this.$node.focus = function(){
              this.$node.querySelector( 'input' ).focus();
        }.bind( this ) 

        this.$node.toggle = function() {
           this.$node.querySelector( 'lyte-dropdown' ).toggle( arguments[ 0 ], arguments[ 1 ] )
        }.bind( this )   

        if( this.getMethods( 'beforeRender' ) ) {
                this.executeMethod( 'beforeRender', this.$node );
        }
    },

     didConnect : function(){
        var errorDiv = document.createElement( 'DIV' );
        errorDiv.classList.add( 'lyteautocompleteError' );
        errorDiv.style.display = 'none';
        this.autocompleteComp = errorDiv;
        $L( 'lyte-drop-body', this.$node ).e[ 0 ].appendChild( errorDiv );
        this.dropdown = $L( 'lyte-dropdown', this.$node ).e[ 0 ];
        this.dropbody = this.dropdown.childComp ? this.component.childComp : $L( 'lyte-drop-box', this.dropdown ).e[ 0 ];
        this.$node.setValue = function(value){
              value = value != undefined ? value : '';
              $L('lyte-input',this.$node).e[0].ltProp('value', value);
              this.pressFunc.call(this, value, {});
        }.bind(this);
        if(this.getMethods('afterRender'))
            {
                this.executeMethod('afterRender', this.$node);
            }
     },

     typeObs : function() {
      var type = this.getData( 'ltPropType' )
        if( type == 'textarea' ) {
            this.input = $L( 'textarea', this.$node ).e[ 0 ]
        } else {
            this.input =  $L( 'input', this.$node ).e[ 0 ];
            if( type == 'search' ) {
                this.$node.classList.add( 'searchPresent' )
                return
            }
            this.$node.classList.remove( 'searchPresent' )
        }

     }.observes( 'ltPropType' ).on( 'didConnect' ),

     arrayFrom : function( nodeList ) {
            var arrayList = [];
            for( var i = 0; i < nodeList.length; i++ ) {
                arrayList.push( nodeList[ i ] );
              }
            return arrayList.slice(); 
           },

     optGroupObs : function(){
        setTimeout( this.optGroup.bind( this ), 0 );
     }.observes( 'ltPropContent' ),      
     
     optGroup : function(){
          if( ( this.dropbody && !this.dropbody.classList.contains( 'lyteDropdownHidden' ) && $L( 'input', this.$node ).e[ 0 ].value.length ) || this.getData( 'ltPropExternalSearch' ) ) {
              this.contentFiltering.call( this, this.input.value )
          }

     },
     // setting height

     classObs : function(){
        if( this.getData( 'ltPropYield' ) ) {
              if( arguments[ 0 ] ) {
                 this.dropbody.classList.remove( arguments[ 0 ].oldValue )
              }  
              this.dropbody.classList.add( this.getData( 'ltPropDropdownClass' ) )
          }
      }.observes('ltPropDropdownClass').on('didConnect'),

     heigthSetObs : function(){
        this.heigthSet.call(this);
     }.observes('ltPropDropdownHeight').on('didConnect'),

     heigthSet : function(){
          var ltPropDropdownHeight = this.getData('ltPropDropdownHeight');
          if(ltPropDropdownHeight){
                $L('lyte-drop-body', this.dropbody).e[0].style.maxHeight = ltPropDropdownHeight;
          }
     },
     // setting width 

     widthSetObs : function(){
        this.widthSet.call(this);
     }.observes('ltPropDropdownWidth').on('didConnect'),

     widthSet : function(){
          var ltPropDropdownWidth = this.getData('ltPropDropdownWidth');
          if(ltPropDropdownWidth){
                 $L('lyte-drop-body', this.dropbody).e[0].style.width = ltPropDropdownWidth;
          }
     },

     data : function (){
      //user data
            return {
               ltPropAutocomplete : Lyte.attr("string",{"default" : 'off'}),
               ltPropPlaceholder : Lyte.attr("string",{"default" : ''}),
               ltPropAutofocus : Lyte.attr("boolean",{"default" : false}),
               ltPropDisabled : Lyte.attr("boolean",{"default" : false}),
               ltPropMaxlength : Lyte.attr("number",{"default" : 25}),
               ltPropReadonly : Lyte.attr("boolean",{"default" : false}),
               ltPropId : Lyte.attr("string",{"default" : 'inputId'}),
               ltPropClass : Lyte.attr("string",{"default" : ''}),
               ltPropType : Lyte.attr("string",{"default" : 'text'}),
               ltPropName : Lyte.attr("string",{"default" : ''}),
               ltPropWidth : Lyte.attr("string",{"default" : '100%'}),
               ltPropValue : Lyte.attr("string",{"default" : ''}),
               ltPropContent : Lyte.attr("array",{"default" : []}),
               ltPropLabel : Lyte.attr("string",{"default" : ''}),
               ltPropDescription : Lyte.attr("string",{"default" : ''}),
               ltPropAppearance : Lyte.attr("string",{"default" : 'flat'}),
               ltPropDirection : Lyte.attr("string",{"default" : 'vertical'}),
               ltPropExternalSearch : Lyte.attr("boolean",{"default" : false}),
               ltPropYield : Lyte.attr("boolean",{"default" : false}),
               ltPropHeight : Lyte.attr("string",{"default" : ''}),
               ltPropHighlight : Lyte.attr("boolean",{"default" : false}),
               ltPropHighlightClass : Lyte.attr("string",{"default" : 'lyteautocompleteHighlight'}),
               ltPropKeyWords : Lyte.attr("string",{"default" : ''}),
               ltPropMinLength : Lyte.attr('number',{'default' : 1}),
               ltPropErrorClass : Lyte.attr('string',{'default' : 'lyteautocompleteError'}),
               ltPropDropdownWidth : Lyte.attr('string',{'default' : 'auto'}),
               ltPropDropdownHeight : Lyte.attr('string',{'default' : '300px'}),
               ltPropDropdownClass : Lyte.attr('string', {'default' : 'lyteautocompleteDropdown'}),
               ltPropDropdownId : Lyte.attr('string', {'default' : 'lyteAutocomplete'}),
               ltPropMethod : Lyte.attr('string',{'default' : 'contains'}),
               ltPropWrapperStyle : Lyte.attr('string', {'default' : ''}),
               ltPropAjaxRequest : Lyte.attr("object",{"default":{}}),
               ltPropTabIndex : Lyte.attr('string',{default : '0'}),
               ltPropTabindex : Lyte.attr('string',{default : '0'}),
               ltPropFreeze : Lyte.attr('boolean', { default: false}),
               ltPropCallout : Lyte.attr('boolean',{default : false}),
               ltPropShow : Lyte.attr('boolean', { default : false}),
               ltPropDisabled : Lyte.attr('boolean', { default : false}),
               ltPropHover : Lyte.attr('boolean', { default : false}),
               ltPropBoundary : Lyte.attr('object', { default : {}}),
               ltPropPosition : Lyte.attr('string', { default : 'down'}),
               ltPropDropType : Lyte.attr('string', { default : 'default'}),
               ltPropSetPos : Lyte.attr('boolean', { default : false}),
               ltPropPattern : Lyte.attr('string', { default : ".+"}),
               ltPropAutoUpdate : Lyte.attr('boolean', { default : true}),
               ltPropValueSet : Lyte.attr('boolean', { default : true}),
               ltPropPreventInsideClick : Lyte.attr('boolean', { default : false}),
               ltPropExtSearchOpen :Lyte.attr('boolean', { default : false }),
               ltPropInputTitle : Lyte.attr('string', { default : '' }),

               //textarea
               ltPropRows : Lyte.attr("number",{"default" : undefined}),
               ltPropCols : Lyte.attr("number",{"default" : undefined}),
               ltPropTextAreaResize : Lyte.attr("object",{"default" : {vertical : true, horizontal : true}}),

               // system data
               timeout : Lyte.attr("number",{"default" : undefined}),
               optGroup : Lyte.attr("boolean",{"default" : false}),
               autocompleteFlag : Lyte.attr('boolean', {'default' : true})

             }
         },

// to Highlight selected text
     highlightText : function(targerArray, inputValue)
        {
            var regEx = new RegExp('('+inputValue+')','gi');
            var regEx2 = /(?!>)([^><]+)(?=<)/ig;
            for(var i = 0; i < targerArray.length; i++){
                    var autocompleteLabel = $L('lyte-autocomplete-label', targerArray[i]).e[0], span = $L('div.lyteAutoComplete', targerArray[i]).e[0];
                    if(!span){
                      span = document.createElement('div');
                      span.classList.add('lyteAutoComplete');
                      targerArray[i].insertBefore(span, targerArray[i].firstChild);
                    }
                    autocompleteLabel.style.display = 'none';
                    if(autocompleteLabel.children.length){
                             span.innerHTML = this.autoHighlight.call(this, autocompleteLabel, regEx, regEx2);
                      }
                    else{
                          span.innerHTML = autocompleteLabel.textContent.replace(regEx,'<span class ='+this.getData('ltPropHighlightClass')+'>$1</span>');
                    }
            } 
        }, 

      autoHighlight : function(autocompleteLabel,regEx, regEx2){
         return autocompleteLabel.innerHTML.replace(regEx2, function(){
                      return arguments[0].replace(regEx,'<span class ='+this.getData('ltPropHighlightClass')+'>$1</span>')
              }.bind(this));
      }, 

    //showing nd hiding error message
   errorMessage : function(flag){
      var errorDiv =  this.autocompleteComp
      if(flag)
          {
              errorDiv.style.display = 'block';
              if(!errorDiv.style.width){
                errorDiv.style.width = window.getComputedStyle(this.$node).getPropertyValue('width')
              }
          }
      else
          {
              errorDiv.style.display = 'none'
              errorDiv.innerHTML = ''
          }
    },

    actions : {
        resetValue : function( evt ) {
          // event.stopPropagation();
          this.$node.setValue( '' );
        },

        "clickThrow":function(event){
                if(this.getData('ltPropMinLength') == 0)
                      {
                         // this.allow = true;
                         if(!this.getData('ltPropExternalSearch')){
                              setTimeout(this.pressFunc.bind(this), 0 ,this.input.value, {})
                          }else{
                            setTimeout(function(){
                              if(this.getMethods('onExtSearch')){
                                    this.executeMethod('onExtSearch', this.input.value, this.$node);
                                }
                            }.bind(this), 0)
                          }
                      } else { 
                         event.stopPropagation();
                      }            
           },
          //filtering process  checks
        "keyup":function(event){
              if(event.keyCode == 37 || event.keyCode == 13 || event.keyCode == 38 || event.keyCode == 39 || event.keyCode == 40 || event.keyCode == 91 || event.keyCode == 27 || event.keyCode == 16 || event.keyCode == 18){
                return
              }
              var val = this.input.value;
               if( this.getData('timeout') != undefined ){ 
                      clearTimeout(this.getData('timeout'))
                }
              if((val.length >= this.getData('ltPropMinLength')|| event.keyCode == 8) && event.keyCode != 13)
                  {   
                         this.setData('timeout', setTimeout(function(){  
                             this.pressFunc.call(this, val, event)
                           }.bind(this),100))
                  }    
            }  
    },

     methods : {
             // when dropdown value selected  
        "valSet":function( event,selectedVal ){
                  var targetElem = (event||window.event).target
                  while(targetElem.tagName != 'LYTE-DROP-ITEM' && targetElem.tagName != "BODY"){
                      targetElem = targetElem.parentElement
                    }
                   if(targetElem.tagName == 'LYTE-DROP-ITEM'){
                        var autocompleteLabel = $L('lyte-autocomplete-label', targetElem).e[0]
                        selectedVal = autocompleteLabel.textContent
                      } 
                  if(selectedVal){
                        if( this.getData( 'ltPropValueSet' ) ) {
                          this.input.value = selectedVal
                        }
                        var ltPropContent = this.getData('ltPropContent');
                        if(this.getMethods('onSelect')){
                              var value;
                              if(this.getData('ltPropYield')){
                                    value = targetElem.getAttribute('data-value')
                                  }
                              else{
                                    var ltPropContent = this.getData('ltPropContent')
                                    var childrens = this.arrayFrom.call(this, $L('lyte-drop-body', $L('lyte-dropdown', this.$node).e[0].component.childComp).e[0].children);
                                    for(var i = 0; i < childrens.length; i++){
                                           if(['LYTE-DROP-GROUP', 'LYTE-DROP-ITEM'].indexOf(childrens[i].tagName) == -1){
                                                  Lyte.arrayUtils(childrens, 'removeAt', i);
                                                  i--;
                                              }
                                        }
                                     if(targetElem.parentElement.tagName == 'LYTE-DROP-GROUP'){
                                             var grp = ltPropContent[childrens.indexOf(targetElem.parentElement)];
                                             value = grp[Object.keys(grp)[0]][this.arrayFrom.call(this, $L('lyte-drop-item', targetElem.parentElement).e).indexOf(targetElem)];
                                      }
                                      else{
                                            value = ltPropContent[childrens.indexOf(targetElem)];
                                      }    
                                  }   
                               this.executeMethod('onSelect', value, event, this.$node)
                            }
                      }          
            },
           show :  function(){
              if(this.getMethods('onShow')){
                this.executeMethod('onShow', arguments[0], arguments[1])
              } 
           },
           hide :  function(){
              if(this.getMethods('onHide')){
                this.executeMethod('onHide', arguments[0], arguments[1])
              } 
           },
           beforeShow :  function(){
              if(this.getMethods('onBeforeShow')){
                return this.executeMethod('onBeforeShow', arguments[0], arguments[1])
              } 
           },
           beforeHide :  function(){
              if( this.getData( 'ltPropPreventInsideClick' ) && arguments[0] && arguments[0].keyCode != 27 ) {
                 if( this.$node.contains(arguments[0].target) ) {
                    return false
                 }
              }
              if(this.getMethods('onBeforeHide')){
                return this.executeMethod('onBeforeHide', arguments[0], arguments[1])
              } 
           },
           add : function(){
              if(this.getMethods('onAdd')){
                this.executeMethod('onAdd', arguments[0], arguments[1], arguments[2], arguments[3])
              }
           },
           remove : function(){
              if(this.getMethods('onRemove')){
                this.executeMethod('onRemove', arguments[0], arguments[1], arguments[2], arguments[3])
              }
           },
           positionChanged : function(){
              if(this.getMethods('onPositionChanged')){
                this.executeMethod('onPositionChanged', arguments[0], arguments[1])
              }
           },
           scroll : function(){
              if(this.getMethods('onScroll')){
                this.executeMethod('onScroll', arguments[0], arguments[1]);
              }
           },
          valuechange : function(arg1){
            if(this.getMethods('onValueChange')){
                 this.executeMethod('onValueChange', arg1, this.$node);
              }
          }

        },
        filteringArray : function(searchList, targetList, val, event){
             var flag, method = this.getData('ltPropMethod'), visibleList = [];
             if(val.length)
                {
                   for(var i = 0; i < searchList.length; i++)
                     {
                          switch(method)
                            {
                              case 'contains' : {
                                  if(searchList[i].trim().toLowerCase().indexOf(val.toLowerCase()) >= 0)
                                      {
                                          visibleList.push(targetList[i]);
                                      }
                                  break;    
                               }
                               case 'startsWith' : {
                                    if(searchList[i].trim().toLowerCase().startsWith(val.toLowerCase()))
                                        {
                                          visibleList.push(targetList[i]);
                                       }
                                    break;
                               }
                               case 'endsWith' : {
                                    if(searchList[i].trim().toLowerCase().endsWith(val.toLowerCase()))
                                        {
                                            visibleList.push(targetList[i]);
                                       }
                                    break;
                               }
                            }  
                      }
                }
             else
                {
                   visibleList = targetList;
                }
             if(this.getMethods('onSearch'))   
                {
                  flag = this.executeMethod('onSearch',visibleList,this.autocompleteComp, this.$node, val, event);
                }
             if(flag != false)
                {
                  for(var i = 0; i < searchList.length; i++)
                     {  
                        switch(method)
                          {
                            case 'contains' : {
                                if(searchList[i].trim().toLowerCase().indexOf(val.toLowerCase()) < 0)
                                    {
                                       targetList[i].classList.add('lyteSearchHidden')
                                    }
                                  else
                                    {
                                       targetList[i].classList.remove('lyteSearchHidden')
                                    }  
                                break;    
                             }
                             case 'startsWith' : {
                                  if(!searchList[i].trim().toLowerCase().startsWith(val.toLowerCase()))
                                      {
                                          targetList[i].classList.add('lyteSearchHidden')
                                      }
                                     else
                                      {
                                         targetList[i].classList.remove('lyteSearchHidden')
                                      }  
                                  break;
                             }
                             case 'endsWith' : {
                                  if(!searchList[i].trim().toLowerCase().endsWith(val.toLowerCase()))
                                      {
                                          targetList[i].classList.add('lyteSearchHidden')
                                      }
                                    else
                                     {
                                        targetList[i].classList.remove('lyteSearchHidden')
                                     }  
                                  break;
                             }
                          }      
                     }
                    this.optGroupHide.call(this)
                    this.errorMessage.call(this, !visibleList.length) 
                   if(visibleList.length && this.getData('ltPropHighlight'))  
                      {
                          this.highlightText.call(this, targetList, val)
                      }   
                } 
        },  
        // hiding category
        optGroupHide : function(){
              var categories = $L('lyte-drop-group', this.dropbody).e
              for(var i = 0; i < categories.length; i++){
                    if($L('lyte-drop-item.lyteSearchHidden', categories[i]).e.length == $L('lyte-drop-item', categories[i]).e.length){
                            categories[i].style.display = 'none'
                    }else{
                        categories[i].style.display = 'block'
                    }   
                  }
        },
        contentFiltering : function(val, event){
              var dropdown = this.dropdown, content = [], target = [];
               var lyteDropdownContainer =  this.dropbody;
               if((lyteDropdownContainer.classList.contains('lyteDropdownHidden') && val.length >= this.getData('ltPropMinLength'))|| (!lyteDropdownContainer.classList.contains('lyteDropdownHidden') && val.length < this.getData('ltPropMinLength')))
                    {
                        // this.allow = true;
                        dropdown.toggle()
                        // delete this.allow;
                        if(lyteDropdownContainer.classList.contains('lyteDropdownHidden')){
                          return;
                        }
                    }
               var target = $L('lyte-drop-item:not(.lyteDropdownActive)', lyteDropdownContainer).e
               for(var k = 0; k < target.length; k++)
                  {
                      var autocompleteLabel = $L('lyte-autocomplete-label', target[k]).e[0]
                      var keyword = autocompleteLabel.getAttribute('keywords')
                      if(keyword)
                         {
                            try
                               {
                                 keyword = JSON.parse(keyword).join(' ')
                               }
                             catch(err){
                             } 
                         }
                      content.push(keyword ? keyword : autocompleteLabel.textContent.trim())
                  }
               this.filteringArray.call(this, content, target, val, event)
               dropdown.component.setAlignment.call(dropdown.component)
        },
        // filtering process  
        pressFunc : function ( val, event){
            if(!this.getData('ltPropExternalSearch') && Lyte.Component.registeredHelpers.lyteUiIsEmptyObject(this.getData("ltPropAjaxRequest")))
                {
                    this.contentFiltering.call(this, val, event)
                }
              else
                 {
                    if(val.length >= this.getData('ltPropMinLength') || !event.target)
                        {
                            if(!Lyte.Component.registeredHelpers.lyteUiIsEmptyObject(this.getData('ltPropAjaxRequest')))
                              {
                                  var request = this.getData('ltPropAjaxRequest');
                                  var xhttp = new XMLHttpRequest();
                                  var method = request.method;
                                  var param = request.param ? request.param + '=' + val : null;
                                  var reqHeader = request.header && request.header.name ? request.header.name : "Content-type";
                                  var reqHeaderVal = request.header && request.header.value ? request.header.value : "application/x-www-form-urlencoded";
                                  var comp = this;
                                  xhttp.onreadystatechange = function(){
                                    if(this.readyState == 4 && this.status == 200)
                                      {
                                        if(this.responseText)
                                            {
                                              x = JSON.parse(this.responseText)[comp.getData('ltPropAjaxRequest').key];
                                              if(!x)
                                                {
                                                  x = [];
                                                }
                                              comp.setData('ltPropContent',x);
                                              if(comp.getMethods('onSuccess')){
                                                comp.executeMethod('onSuccess',this.response,comp,this,arguments);
                                              }
                                            }
                                      }
                                  };
                                  var addParams  = request.additionalParams || {};
                                  var str = '';
                                  var x = 0;
                                  for(var i in addParams){
                                    if(x == 0){
                                      str = i + "=" + addParams[i];
                                    }
                                    else{
                                      str += '&' + i + "=" + addParams[i];
                                    }
                                    x++;
                                  }
                                  if(param){
                                    if(str){
                                      param += '&' + str;
                                    }
                                  }
                                  else{
                                    if(str){
                                      param = str;
                                    }
                                  }
                                  if(method === "GET" && param){
                                    xhttp.open("GET", request.url+'?'+param, true);
                                    param = null;
                                  }
                                  else{
                                    xhttp.open(method, request.url, true);
                                  }
                                  xhttp.setRequestHeader(reqHeader, reqHeaderVal);
                                  xhttp.send(param);
                              }
                          else
                              {
                                if(this.dropbody.classList.contains('lyteDropdownHidden') && this.getData( 'ltPropExtSearchOpen' )){
                                      // this.allow = true;
                                      this.dropdown.toggle()
                                      // delete this.allow;
                                      if(this.dropbody.classList.contains('lyteDropdownHidden')){
                                        return;
                                      }
                                  }
                                 if(this.getMethods('onExtSearch')){
                                      this.executeMethod('onExtSearch',val, this.$node, event);
                                  }
                              }
                      }
                     else
                        {
                          if(!this.dropbody.classList.contains('lyteDropdownHidden')){
                              this.dropdown.toggle();
                            }
                        } 

                  }   
        },
        someServerWork : function(data,val){
          var list = [];
          for(var i = 0; i<data.length; i++){
            if(data[i].indexOf(val+"") > -1){
              list.push(data[i]);
            }
          }
          return list;
        }  
  });
Lyte.Component.register('lyte-breadcrumb',{
_template:"<template tag-name=\"lyte-breadcrumb\">\t<div onclick=\"{{action('divClick', event, this)}}\">\t\t<template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\">\t\t\t\t\t<lyte-breadcrumb-structure class=\"{{ltPropClass}}\">\t\t\t\t\t\t<template is=\"for\" items=\"{{ltPropData}}\" item=\"array\" index=\"indexVal\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(array),'==',false)}}\"><template case=\"true\"><template is=\"if\" value=\"{{expHandlers(ltPropClass,'==','lyteStageOne')}}\"><template case=\"true\">\t\t\t\t \t\t\t\t\t\t\t  <lyte-breadcrumb-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick', event, this,array)}}\"> \t  \t\t\t\t \t\t\t\t\t\t\t  \t\t<lyte-breadcrumb-body> {{array}} </lyte-breadcrumb-body> \t\t\t\t \t\t\t\t\t\t\t\t\t<lyte-breadcrumb-head>{{indexVal}}</lyte-breadcrumb-head>\t\t\t\t \t\t\t\t\t\t\t\t</lyte-breadcrumb-item>\t\t\t\t \t\t\t\t\t\t\t</template><template case=\"false\"> \t\t\t\t\t\t\t\t\t\t\t  <lyte-breadcrumb-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick', event, this,array)}}\"> \t \t\t\t\t\t\t\t\t\t\t\t  \t\t<lyte-breadcrumb-body> {{array}} </lyte-breadcrumb-body>\t\t\t\t\t\t\t\t\t\t\t\t</lyte-breadcrumb-item>\t\t\t\t\t\t\t\t\t\t </template></template></template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropClass,'==','lyteStageOne')}}\"><template case=\"true\">\t\t\t\t\t\t\t\t\t\t\t\t<lyte-breadcrumb-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick', event, this,array)}}\"> \t\t\t\t\t\t\t\t\t\t\t\t\t\t<lyte-breadcrumb-body> {{array[ltPropLabel]}} </lyte-breadcrumb-body> \t\t\t\t\t\t\t\t\t\t\t\t\t<lyte-breadcrumb-head>{{array[ltPropOption]}}</lyte-breadcrumb-head>\t\t\t\t\t\t\t\t\t\t\t\t</lyte-breadcrumb-item>\t\t\t\t\t\t\t\t\t\t\t</template><template case=\"false\"> \t\t\t\t\t\t\t\t\t\t\t   <lyte-breadcrumb-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick', event, this,array)}}\"> \t\t\t\t\t\t\t\t\t\t\t\t   \t    <lyte-breadcrumb-body> {{array[ltPropLabel]}} </lyte-breadcrumb-body>\t\t\t\t\t\t\t\t\t\t\t   </lyte-breadcrumb-item>\t\t\t\t\t\t\t\t\t\t  </template></template></template></template></template>\t\t\t\t\t</lyte-breadcrumb-structure>\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t<lyte-yield yield-name=\"yield\"></lyte-yield>\t\t\t </template></template>\t\t</div>\t\t</template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"text","position":[1,3,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"text","position":[1,3,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropClass","ltPropData","ltPropActiveClass","ltPropCompletedClass","ltPropYield","ltPropLabel","ltPropOption"],
	init : function(){
		if(this.getMethods('beforeRender'))
            {
                this.executeMethod('beforeRender', this.$node);
            }
	},	
	didConnect : function (){
		this.ArrayContentChange.call(this);
		this.$node.modifyCrumbItems = function ( property, arg1, arg2){
		if(!this.component.getData('ltPropYield'))
			{
				Lyte.arrayUtils(this.component.getData('ltPropData'), property, arg1, arg2)
			}
		else
			{
				this.component.ArrayContentChange.call(this.component);
			}	
	     }
	   $L.fastdom.measure(function(){
	   	   this.breadcrumbClass.call(this);
	   }.bind(this))
	   if(this.getMethods('afterRender'))
            {
                this.executeMethod('afterRender', this.$node);
            }  
	},

	ArrayContentChangeObs : function(){
		this.ArrayContentChange.call(this);
	}.observes('ltPropData.[]'),

	ArrayContentChange : function (){
		var innerElements = $L('lyte-breadcrumb-item', this.$node).e;
		if(innerElements.length)
			{
				var ltPropActive = this.getData('ltPropActiveClass');
				var ltPropCompleted = this.getData('ltPropCompletedClass');
				$L('lyte-breadcrumb-item', this.$node).removeClass(ltPropActive)
				$L('lyte-breadcrumb-item', this.$node).addClass(ltPropCompleted)
				innerElements[innerElements.length - 1].classList.add(ltPropActive)	
				innerElements[innerElements.length - 1].classList.remove(ltPropCompleted)	
			}
	},

	breadcrumbClassObs : function(){
		this.breadcrumbClass.call(this)
	}.observes('ltPropClass'),

	breadcrumbClass : function(){
		if(this.getData('ltPropYield'))
			{
				$L('lyte-breadcrumb-structure', this.$node).e[0].classList.add(this.getData('ltPropClass'));
			}
	},
	data : function(){
        return {
			//  user data
			ltPropClass : Lyte.attr("string",{"default":'lyteBreadcrumbSlash'}),
			ltPropData : Lyte.attr("array",{"default":[]}),
			ltPropActiveClass : Lyte.attr("string",{"default":'lyteActive'}),
			ltPropCompletedClass : Lyte.attr("string",{"default":'lyteCompleted'}),
			ltPropYield : Lyte.attr("boolean",{"default":false}),
			ltPropLabel : Lyte.attr('string', {'default': ''}),
            ltPropOption : Lyte.attr('string', {'default': ''})
		}
	},
	actions : {
	   'onclick' : function (event, Component, data){
		if((event.ctrlKey == true || event.metaKey == true || event.which == 2) && event.target.href != undefined && event.target.href.indexOf('javascript:') != -1 && event.target.target == '_blank'){return false;}
			if(this.getMethods('onClick'))
				{
				   this.executeMethod('onClick', Component, this.$node, event, data)
				   event.stopPropagation();	
				}
		},
        divClick : function(event, div){
			if((event.ctrlKey == true || event.metaKey == true || event.which == 2) && event.target.href != undefined && event.target.href.indexOf('javascript:') != -1 && event.target.target == '_blank'){return false;}
            if(this.getMethods('onClick') && this.getData('ltPropYield'))
                {
                    var node = event.target;
                    while(node != div)
                        {
                            if(node.tagName == 'LYTE-BREADCRUMB-ITEM')
                                {
                                    this.executeMethod('onClick', node, this.$node, event, node.getAttribute('data-value'))
                                    break;
                                }
                              else
                                {
                                    node =  node.parentElement;
                                }  
                        }
                }
        }
	}
});
Lyte.Component.register( 'lyte-button', {
_template:"<template tag-name=\"lyte-button\">\t<button type=\"{{ltPropType}}\" onclick=\"{{action('check',event)}}\" class=\"{{finalClass}}\" value=\"{{ltPropValue}}\" tabindex=\"{{ltPropTabindex}}\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" style=\"{{finalStyle}}\">\t\t\t<lyte-yield yield-name=\"text\"></lyte-yield>\t\t</button></template>",
_dynamicNodes : [{"type":"attr","position":[1],"attr":{"style":{"name":"style","dynamicValue":"finalStyle"}}},{"type":"insertYield","position":[1,1]}],
_observedAttributes :["ltPropName","ltPropDisabled","ltPropAutofocus","ltPropAppearance","ltPropId","ltPropType","ltPropValue","ltPropTabindex","ltPropStyle","ltPropSize","ltPropBackgroundColor","ltPropColor","lyteShortcut","ltPropClass"],
	data: function() {
		return {
			'ltPropName': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropDisabled': Lyte.attr( 'boolean', {
				'default': false
			} ),
			'ltPropAutofocus': Lyte.attr( 'boolean', {
				'default': false
			} ),
			'ltPropAppearance': Lyte.attr( 'string', {
				'default': 'default'
			} ),
			'ltPropId': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropType': Lyte.attr( 'string', {
				'default': 'button'
			} ),
			'ltPropValue': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropTabindex': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropStyle': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropSize': Lyte.attr( 'string', {
				'default': 'default'
			} ),
			'ltPropBackgroundColor': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropColor': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'lyteShortcut': Lyte.attr( 'object', {
				'default': {}
			} ),
			'ltPropClass':Lyte.attr( 'string', {
				'default': ''
			} )
		}
	},

	init: function() {
		this.pushValue();
	},

	didDestroy: function() {
		var val = this.getData('lyteShortcut');
		if( val ) {
			if( typeof shortcut === 'function' ) {
				shortcut.push( {
					newKey: undefined,
					type: undefined,
					wait: undefined,
					oldKey: val.key
				} );
			}
		}
	},

	shortcutChanged: function() {
		this.pushValue();
	}.observes( 'lyteShortcut' ),

	pushValue: function() {
		var key = this.getData( 'lyteShortcut' ),
		node = this.$node;

		if( !key.key ) {
			return ;
		}

		if( typeof shortcut === 'function' ) {
			shortcut.push( {
				newKey : key.key,
				type : key.type,
				wait : key.wait,
				oldKey:undefined,
				value:node
			} );
		}
	},

	changeClass: function() {
		var cls = this.getData( 'ltPropClass' ), tempStyle = '', 
		tempClass = 'lyte-button' + ( cls ? ' ' + cls : '' ),
		app = this.getData( 'ltPropAppearance' ), size = this.getData( 'ltPropSize' ),
		color = this.getData( 'ltPropColor' ), bg = this.getData( 'ltPropBackgroundColor' );
		size = size ? size.toLowerCase() : '';
		app = app ? app : 'default';

		if( bg ) {
			tempClass = tempClass + ' lyteBackgroundColorBtn';
		}
		else if( color ) {
			tempClass = tempClass + ' lyteColorBtn';
		}
		else if( app.indexOf( 'default' ) !== -1 ) {
			tempClass = tempClass + ' lyteDefaultBtn';
		}
		else if( app.indexOf( 'primary' ) !== -1 ) {
			tempClass = tempClass + ' lytePrimaryBtn';
		}
		else if( app.indexOf( 'secondary' ) !== -1 ) {
			tempClass = tempClass + ' lyteSecondary';
		}

		if( app.indexOf( 'success' ) !== -1 ) {
			tempClass = tempClass + ' lyteSuccess';
		}
		else if( app.indexOf( 'failure' ) !== -1 ) {
			tempClass = tempClass + ' lyteFailure';
		}

		if( size === 'extra-small' ) {
			tempClass = tempClass + ' lyteExsm';
		}
		else if( size === 'small' ) {
			tempClass = tempClass + ' lyteSm';
		}
		else if( size === 'large' ) {
			tempClass = tempClass + ' lyteLg';
		}

		if( color ) {
			if( !bg ) {
				tempStyle = tempStyle + 'color:' + color + ';border-color:' + color + ';';
			}
			else {
				tempStyle = tempStyle + 'background-color:' + bg + ';border-color:' + bg + ';color:' + color + ';';
			}
		}
		else if( bg ) {
			tempStyle = tempStyle + 'background-color:' + bg + ";border-color:" + bg + ";color:white;";
		}

		if( this.getData( 'ltPropStyle' ) ) {
			tempStyle = tempStyle + this.getData( 'ltPropStyle' );
		}

		this.setData( 'finalStyle', tempStyle );
		this.setData( 'finalClass', tempClass );
	}.observes(
		'ltPropClass',
		'ltPropBackgroundColor',
		'ltPropColor',
		'ltPropStyle',
		'ltPropSize',
		'ltPropAppearance'
	).on( 'init' ),
	actions: {
		check: function( event ) {
			var button = this.$node.querySelector( 'button' )
			if( button.disabled ) {
				event.stopPropagation()
			}
		}
	}
});

/* NOTES TO SELF ===>
	31-07-2018
	 1. Added dropdown for month and year in month header
 */

Lyte.Component.register( 'lyte-calendar', {
_template:"<template tag-name=\"lyte-calendar\">    <div class=\"lyteCalendarPopup\">        <div class=\"lyteCalendarView\">            <div>                <template is=\"if\" value=\"{{navYield}}\"><template case=\"true\">                    <lyte-yield yield-name=\"navigator\"></lyte-yield>                </template><template case=\"false\">                    <div class=\"lyteCalendarNavigator\">                        <template is=\"if\" value=\"{{ifNotEquals(ltPropHeaderType,'dropdown')}}\"><template case=\"true\">                            <template is=\"if\" value=\"{{ltPropYear}}\">                            <template case=\"true\"><span class=\"lyteCalNav lyteCalyearNavLft\" onclick=\"{{action('previous','Y',event)}}\"></span></template>                            </template>                        </template></template>                        <span class=\"lyteCalNav lyteCaldLft\" onclick=\"{{action('previous','M',event)}}\"></span>                        <template is=\"if\" value=\"{{ifEquals(ltPropHeaderType,'dropdown')}}\"><template case=\"true\">                            <span class=\"lyteCalsCalMon\">                                <lyte-dropdown class=\"lyteCalMonthDD\" lt-prop-options=\"{{monthNames}}\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method('optionSelected','M')}}\"></lyte-dropdown>                                <lyte-dropdown class=\"lyteCalYearDD\" lt-prop-options=\"{{years}}\" lt-prop-tabindex=\"2\" on-option-selected=\"{{method('optionSelected','Y')}}\"></lyte-dropdown>                            </span>                        </template><template case=\"false\">                            <span class=\"lyteCalsCalMon\">{{monthHeader}}</span>                        </template></template>                        <span class=\"lyteCalNav lyteCaldRgt\" onclick=\"{{action('next','M',event)}}\"></span>                        <template is=\"if\" value=\"{{ifNotEquals(ltPropHeaderType,'dropdown')}}\"><template case=\"true\">                            <template is=\"if\" value=\"{{ltPropYear}}\">                                <template case=\"true\"><span class=\"lyteCalNav lyteCalyearNavRgt\" onclick=\"{{action('next','Y',event)}}\"></span></template>                            </template>                        </template></template>                    </div>                </template></template>                            </div>            <div class=\"lyteCalTableContainer\">                <div class=\"lyteCalTableRowHeader\">                    <template is=\"for\" items=\"{{daysOfWeek}}\" item=\"day\" indexval=\"idod\">                        <div class=\"lyteCalTableCellHeader\">{{lyteUiI18n(day)}}</div>                    </template>                </div>                <template is=\"for\" items=\"{{matrix}}\" item=\"vector\" indexval=\"rowid\">                    <template is=\"if\" value=\"{{lyteUiCheckEmpty(vector)}}\">                        <template case=\"false\">                            <div class=\"lyteCalTableRow\">                                <template is=\"for\" items=\"{{vector}}\" item=\"date\" indexval=\"cellid\">                                    <template is=\"if\" value=\"{{lyteUiCheckInRange(ltPropMinDate,ltPropMaxDate,date.val)}}\">                                        <template case=\"true\">                                            <template is=\"if\" value=\"{{date.emptyBlock}}\">                                                <template case=\"true\">                                                    <div class=\"lyteCalEmpty\"></div>                                                </template>                                                <template case=\"false\">                                                    <div data-date=\"{{date.val}}\" onclick=\"{{action('dateSelected',event)}}\" class=\"{{date.clsname}}\"><span class=\"lyteCalDateSpan\">{{date.date}}</span></div>                                                </template>                                            </template>                                        </template>                                        <template case=\"false\">                                            <template is=\"if\" value=\"{{date.emptyBlock}}\">                                                <template case=\"true\">                                                    <div class=\"lyteCalEmpty\"></div>                                                </template>                                                <template case=\"false\">                                                    <div data-date=\"{{date.val}}\" class=\"{{date.clsname}}\"><span class=\"lyteCalDateSpan\">{{date.date}}</span></div>                                                </template>                                            </template>                                        </template>                                    </template>                                </template>                            </div>                        </template>                    </template>                </template>            </div>            <div>                <div class=\"lyteCalBtns\">                    <template is=\"if\" value=\"{{showToday}}\">                        <template case=\"true\"><p class=\"lyteCalCurrentDate\"><a onclick=\"{{action('today',event)}}\">{{lyteUiI18n('today')}}</a></p></template>                    </template>                    <template is=\"if\" value=\"{{ltPropYield}}\">                        <template case=\"true\">                            <lyte-yield yield-name=\"footer\"></lyte-yield>                        </template>                    </template>                </div>            </div>        </div>    </div></template>",
_dynamicNodes : [{"type":"attr","position":[1,1,1,1]},{"type":"if","position":[1,1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"componentDynamic","position":[1,3]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[1,7]},{"type":"attr","position":[1,9]},{"type":"if","position":[1,9],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[1,1,3,1,1]},{"type":"for","position":[1,1,3,1,1],"dynamicNodes":[{"type":"text","position":[1,0]}]},{"type":"attr","position":[1,1,3,3]},{"type":"for","position":[1,1,3,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0,0]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0,0]}]}},"default":{}}]}},"default":{}}]}]}},"default":{}}]},{"type":"attr","position":[1,1,5,1,1]},{"type":"if","position":[1,1,5,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0,0]},{"type":"text","position":[0,0,0]}]}},"default":{}},{"type":"attr","position":[1,1,5,1,3]},{"type":"if","position":[1,1,5,1,3],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropStartDate","ltPropEndDate","ltPropCurrentDate","ltPropFormat","ltPropYear","ltPropMonthHeaderFormat","daysOfWeek","monthNames","shortHands","todayName","viewDate","changeData","ltPropYield","ltPropMinDate","ltPropMaxDate","ltPropStartWeekDay","navYield","selectDate","currentDatechanged","ltPropFillRows","ltPropNumberOfRows","callFrmDidcnct","monthDD","yearDD","years","ltPropHeaderType"],
	data: function() {
		return {
			'ltPropStartDate': Lyte.attr( 'string', { 
				'default': ''
			} ),
			'ltPropEndDate': Lyte.attr( 'string', { 
				'default': ''
			} ),
			'ltPropCurrentDate': Lyte.attr( 'string', { 
				'default': '' 
			} ),
			'ltPropFormat': Lyte.attr( 'string', { 
				'default': 'MM/DD/YYYY' 
			} ),
			'ltPropYear': Lyte.attr( 'boolean', { 
				'default': true 
			} ),
			'ltPropMonthHeaderFormat': Lyte.attr( 'string', { 
				'default': 'MMMM YYYY' 
			} ),
			'daysOfWeek': Lyte.attr( 'array', { 
				'default': [] 
			} ),
			'monthNames': Lyte.attr( 'array', { 
				'default': [
				'January',
				'February',
				'March',
				'April',
				'May',
				'June',
				'July',
				'August',
				'September',
				'October',
				'November',
				'December' 
				]
			} ),
			'shortHands': Lyte.attr( 'array', { 
				'default': [
				'Jan',
				'Feb',
				'Mar',
				'Apr',
				'short.may',
				'Jun',
				'Jul',
				'Aug',
				'Sep',
				'Oct',
				'Nov',
				'Dec'
				]
			} ),
			'todayName': Lyte.attr( 'string', {
				'default': 'Today' 
			} ),
			'viewDate': Lyte.attr( 'object', { 
				'default': {} 
			} ),
			'changeData': Lyte.attr( 'number', {
				'default': 0 
			} ),
			'ltPropYield': Lyte.attr( 'boolean', { 
				'default': false
			} ),
			'ltPropMinDate': Lyte.attr( 'string', { 
				'default': ''
			} ),
			'ltPropMaxDate': Lyte.attr( 'string', { 
				'default': '' 
			} ),
			'ltPropStartWeekDay': Lyte.attr( 'number', { 
				'default': 1 
			} ),
			'navYield': Lyte.attr( 'boolean', { 
				'default': false 
			} ),
			'selectDate': Lyte.attr( 'boolean', { 
				'default': true 
			} ),
			'currentDatechanged': Lyte.attr( 'number', { 
				'default': 0 
			} ),
			'ltPropFillRows': Lyte.attr( 'boolean', { 
				'default': true 
			} ),
			'ltPropNumberOfRows': Lyte.attr( 'number', { 
				'default': 6 
			} ),
			'callFrmDidcnct' : Lyte.attr('boolean',{"default" : false}),
			'monthDD' : Lyte.attr("object"),
			'yearDD' : Lyte.attr("object"),
			'years' :Lyte.attr("array",{"default":[1900, 1901, 1902, 1903, 1904, 1905, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1933, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1953, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 1962, 1963, 1964, 1965, 1966, 1967, 1968, 1969, 1970, 1971, 1972, 1973, 1974, 1975, 1976, 1977, 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030, 2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041, 2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052, 2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063, 2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074, 2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085, 2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100]}),
			'ltPropHeaderType' : Lyte.attr("string",{"default" : "default"})

		}
	},

	changeDaysOfWeek: function() {
		var days = [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ], 
		startDay = this.getData( 'ltPropStartWeekDay' ), i, result = [] ;
		for( i = 0; i < 7; i++ ) { 
			result.push( days[ ( i + startDay ) % 7 ] );
		}

		this.setData( 'daysOfWeek', result );
		
	},

	setMonthAndYearDropdown : function(){
		if(!this.getData('navYield') && this.getData('ltPropHeaderType') == "dropdown" && this.getData('monthDD') && this.getData('yearDD')){
			var monthHeaders = this.getData('monthHeader').split(' '),
			format = this.getData( 'ltPropMonthHeaderFormat' ), 
			lmd = /MMMM YYYY/ig,
			ld = /MMM YYYY/ig,
			monthArray = [],
			monthNames;
			if(lmd.test( format )){
				monthNames = this.getData('monthNames');
			}
			else if(ld.test(format)){
				monthNames = this.getData('shortHands');
			}
			for(var i=0;i<monthNames.length; i++){
				monthArray[i] = _lyteUiUtils.i18n(monthNames[i]);
			}
			this.getData('monthDD').component.setData('ltPropOptions',monthArray);
			this.getData('monthDD').component.setData('ltPropSelected',monthHeaders[0]);
			this.getData('yearDD').component.setData('ltPropSelected',monthHeaders[1]);
		}
	}.observes('monthHeader','callFrmDidcnct'),

	startWeekDayObserver: function() {
		this.changeDaysOfWeek();
	}.observes( 'ltPropStartWeekDay' ),

	monthHeaderObserver: function() {
		this.setData( 'monthHeader', this.getMonthHeader.call( this ) )
	}.observes( 'monthNames.[]' ),

	getMonthHeader: function() {
		var format = this.getData( 'ltPropMonthHeaderFormat' ), 
		lmd = /MMMM YYYY/ig,
		ld = /MMM YYYY/ig,
		retval = "", monthArray;

		if( lmd.test( format ) ) {
			monthArray = this.getData( 'monthNames' )
			retval = _lyteUiUtils.i18n( monthArray[ this.getData( 'viewDate' ).getMonth() ] ) + " " + this.getData( 'viewDate' ).getFullYear();
		}
		else if( ld.test( format ) ) {
			monthArray = this.getData( 'shortHands' )
			retval = _lyteUiUtils.i18n( monthArray[ this.getData( 'viewDate' ).getMonth() ] ) + " " + this.getData( 'viewDate' ).getFullYear();
		}

		return retval;
	},

	revert: function( event ) {
		var from = new Date( this.getData( 'viewDate' ).getTime() ), 
		curDate = new Date();

		curDate.setDate(1);

		var to = new Date( curDate.getTime() );

		this.setData( 'viewDate', curDate )
		this.setData( 'monthHeader', this.getMonthHeader.call( this ) );
		this.setData( 'changeData', this.getData( 'changeData' ) + 1 );
		this.setData( 'showToday', false );
		if( this.getMethods( 'onNavigate' ) 
			&& ( from.getMonth() !== to.getMonth() 
			|| from.getFullYear() !== to.getFullYear() ) 
		) {
			this.executeMethod( 'onNavigate', event, this.getDateFromFormat( from, this.getData( 'ltPropFormat' ) ), this.getDateFromFormat( to, this.getData( 'ltPropFormat' ) ) ,this );
		}
	},

	getDateFromFormat: function( tdate, format ) {
		var date = tdate.getDate(), year  = tdate.getFullYear(), month= tdate.getMonth() + 1, monthArray,
		sd = /(MM).+(DD).+(YYYY)/ig,
		ld = /(MMM|DD|YYYY).+(MMM|DD|YYYY).+(YYYY|MMM|DD)/ig,
		lmd = /(MMMM|DD|YYYY).+(MMMM|DD|YYYY).+(YYYY|MMMM|DD)/ig,
		iso =/(YYYY).+(MM).+(DD)/ig;

		format = format.toUpperCase();
		
		if( month < 10 ) {
			month = '0' + month
		}

		if( date < 10 ) {
			date = '0' + date
		}

		if( lmd.test( format ) ){
			monthArray = [ 
			'January',
			'February',
			'March',
			'April',
			'May',
			'June',
			'July',
			'August',
			'September',
			'October',
			'November',
			'December'
			]
			format = format.replace( 'MMMM', monthArray[ month - 1 ] )
			format = format.replace( 'DD', date )
			format = format.replace( 'YYYY', year )
		}
		else if( ld.test( format ) ){
			monthArray=[ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ]
			format = format.replace( 'MMM', monthArray[ month - 1 ] )
			format = format.replace( 'DD', date )
			format = format.replace( 'YYYY', year )
		}
		else if( iso.test( format ) ){
			format = format.replace( 'MM', month )
			format = format.replace( 'DD', date )
			format = format.replace( 'YYYY', year )
		}
		else if( sd.test( format ) ) {
			format = format.replace( 'MM', month )
			format = format.replace( 'DD', date )
			format = format.replace( 'YYYY', year )
		}
		
		return format
	},

	isLeapYear: function( year ) {
		return ( ( year % 4 == 0 ) && ( year % 100 != 0 ) ) || ( year % 400 == 0 );
	},

	getNumber: function(month,year) {
		var daysinmonths = [ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ];
		if( this.isLeapYear.call( this, year ) && month == 1 ) {
			return 29;
		}
		else{
			return daysinmonths[ month ];
		}
	},

	showtoday: function() {
		var curDate = new Date()
		if( curDate.getMonth() != this.getData('viewDate').getMonth() || curDate.getYear() != this.getData('viewDate').getYear() ) {
			this.setData( 'showToday', true )
		}
		else {
			this.setData( 'showToday', false )
		}
	},

	checkDate: function( current ) {
		var start = this.getData( 'ltPropMinDate' ), end = this.getData( 'ltPropMaxDate' ),
		startDate, endDate;
		if( start === '' && end === '' ){
			return true;
		}
		else if( start !== '' && end === '' ) {
			startDate = new Date( start )
			if( current >= startDate ) {
				return true
			}
		}
		else if( start !== '' && end !== '' ) {
			startDate = new Date( start )
			endDate = new Date( end )
			if( current >= startDate && current <= endDate ){
				return true
			}
		}
		else {
			endDate = new Date( end )
			if( current <= endDate ){
				return true
			}
		}

		return false
	},

	numberOfRowsChange: function() {
		// https://stackoverflow.com/questions/19727905/in-javascript-is-it-expensive-to-use-try-catch-blocks-even-if-an-exception-is-n
		// No penalty in chrome >= 60
		var numberOfRows = this.getData( 'ltPropNumberOfRows' )
		try {
			if( numberOfRows < 5 ) {
				throw "Calendar failed to render. The number of rows should be greater than 4.";
			}
		}
		catch( e ) {
			console.error( e );
			return ;
		}

		this.setDatesFunction();
	}.observes( 'ltPropNumberOfRows' ),

	setDates: function() {
		this.setDatesFunction()
	}.observes( 
		'ltPropStartDate', 
		'ltPropEndDate', 
		'changeData', 
		'ltPropMinDate', 
		'ltPropMaxDate',
		'ltPropFormat',
		'ltPropStartWeekDay'
	),

	getNumberOfFirstRowDates: function( firstday ) {
		var startDayOfMonth = this.getData( 'ltPropStartWeekDay' ), firstRowDays;
		if( firstday == 0 ) {
			firstRowDays = startDayOfMonth === 0 ? 7 : startDayOfMonth;
		}
		else {
			if( firstday < startDayOfMonth ) {
				firstRowDays = startDayOfMonth - firstday;
			}
			else {
				firstRowDays = 7 - ( firstday - startDayOfMonth );
			}
		}

		return firstRowDays;

	},

	getNumberToSubtract: function( firstday ) {
		var numberToSubtract, startDayOfMonth = this.getData( 'ltPropStartWeekDay' );

		if( firstday == 0 ){
			numberToSubtract = startDayOfMonth == 0 ? 0 : 7 - startDayOfMonth;
		}
		else {
			if( firstday < startDayOfMonth ){
				numberToSubtract = 7 - ( startDayOfMonth - firstday );
			}
			else {
				numberToSubtract = firstday - startDayOfMonth;
			}
		}

		return numberToSubtract;
	},

	getFirstDay: function( date, day ) {
		var first;

		first = date - Math.floor( date / 7 ) * 7 - 1;
		first = day - first;

		if( first < 0 ){
			first = 7 - first;
		}

		return first;
	},

	getRemainingDays: function( numberOfDaysInMonth, firstRowDays ) {
		var rem = numberOfDaysInMonth - firstRowDays;
		rem = rem - 28;

		return rem;
	},

	inc: function( rem, num ) {
		if( rem > 0 && num == 6 ) {
			return 7; 
		}

		return num;
	},

	setDatesFunction: function() {
		// Number of rows in the table
		var numberOfRows = this.getData( 'ltPropNumberOfRows' ), 
		fillRows = this.getData( 'ltPropFillRows' ), 
		reachedNextMonth = false, 
		result = [],
		cur = this.getData( 'viewDate' ), 
		day = cur.getDay(),
		date = cur.getDate(), 
		firstday =  this.getFirstDay( date, day ),
		month = cur.getMonth(),
		year = cur.getFullYear(),
		numberOfDaysInMonth = this.getNumber( this, month, year ),
		firstRowDays = this.getNumberOfFirstRowDates( firstday ),
		rem = this.getRemainingDays( numberOfDaysInMonth, firstRowDays );


		numberOfRows = this.inc( rem, numberOfRows );

		var calStartDate = new Date( month + 1 + '/1/' + year ), 
		numberToSubtract = this.getNumberToSubtract( firstday );

		calStartDate.setDate( calStartDate.getDate() -  numberToSubtract );
		
		var todayDate = new Date();

		// Construct array
		for( var i = 0; i < numberOfRows; i++ ) {

			// This is to ensure that we don't create an empty row when we reach the next month when fillRows is false.
			if(reachedNextMonth) {
				break;
			}

			result.push( [] );
			for( var j = 0; j < 7; j++ ) {
				if( !fillRows && month !== calStartDate.getMonth() ) {
					result[i].push( { emptyBlock: true } );
					calStartDate.setDate( calStartDate.getDate() + 1 );
					if( i != 0 ) {
						reachedNextMonth = true
					}

					continue;
				}

				var clsname = 'lyteCalCdate', newMonth = calStartDate.getMonth(),
				curDate = new Date( this.getData( 'viewDate' ).getTime() ),
				curMonth = curDate.getMonth(),
				ndate = calStartDate.getDate(),
				tdate = this.getData( 'ltPropCurrentDate' ) ? new Date( this.getData( 'ltPropCurrentDate' ) ) : 'nodate',
				nyear = calStartDate.getYear(),
				isInRange = this.checkDate( calStartDate ),
				isPresent = this.getData( 'ltPropMinDate' ) !== "" || this.getData( 'ltPropMaxDate' ) !== "";

				if( curMonth !== newMonth ) {
					if( isPresent && !isInRange || ( !isPresent ) ) {
						clsname += ' lyteCalGray';
					}		
				}
				else if( isPresent 
					&& !isInRange ) {
					clsname += ' lyteCalGray'
				}

				if( tdate !== 'nodate' && newMonth == tdate.getMonth() && tdate.getDate() == ndate && tdate.getYear() == nyear && this.getData( 'selectDate' ) ) {
					clsname += ' lyteCalSel'
				}

				if( todayDate.getMonth() === newMonth && todayDate.getDate() === ndate && todayDate.getYear() === nyear && this.getData( 'selectDate' ) ) {
					clsname += ' lyteCalToday'
				}

				// Add Classes for weekends
				if( calStartDate.getDay() == 0 || calStartDate.getDay() == 6 ) {
					clsname += ' lyteCalWeekend'
				}

				// Store in array and increment date by 1
				clsname += ' lyteCalTableCell';
				var obj = {};
				obj.date = calStartDate.getDate();
				obj.clsname = clsname;
				obj.val = this.getDateFromFormat.call( this, calStartDate, this.getData( 'ltPropFormat' ) );
				result[ i ].push( obj );
				// Lyte.arrayUtils( this.getData( 'matrix' )[ i ], 'push', obj )
				calStartDate.setDate( calStartDate.getDate() + 1 );
			}

		}

		this.setData( 'matrix', result );

	},

	executeViewDateChanges : function() {
		if( this.getMethods( 'onViewdateChange' ) ){
			this.executeMethod( 'onViewdateChange', this, this.getData( 'viewDate' ) );
		}
	}.observes( 'viewDate' ),

	initFn: function() {
		var viewDate = this.getData( 'ltPropCurrentDate' ) ? new Date( this.getData( 'ltPropCurrentDate' ) ) : new Date(),
		self = this;

		this.changeDaysOfWeek();
		viewDate.setDate( 1 )
		this.setData( 'viewDate', viewDate )
		this.setData( 'monthHeader', this.getMonthHeader.call( this ) )
		this.setDatesFunction()
		this.showtoday.call( this )

		// set revert
		this.$node.revertToToday = function() {
			self.revert();
		};
	}.observes( 'currentDatechanged' ).on( 'init' ),

	didConnect : function(){
		if(!this.getData('navYield') && this.getData('ltPropHeaderType') == "dropdown"){
			this.setData('monthDD',this.$node.querySelector('.lyteCalMonthDD'));
			this.setData('yearDD',this.$node.querySelector('.lyteCalYearDD'));
			this.getData('yearDD').component.setData('ltPropOptions',this.getData('years'));
			this.setData('callFrmDidcnct',true);
		}
	},

	removeClass: function() {
		var node = this.$node.querySelector( '.lyteCalSel' );

		if( node ) {
			node.classList.remove( 'lyteCalSel' );
		}
	},

	changeViewDate: function( val ) {
		var cur = this.getData( 'ltPropCurrentDate' );

		if( this.getData( 'preventObs' ) ) {
			return ;
		}

		// Current Date is set to empty
		if( !cur ) {
			this.removeClass();
			return ;
		}

		// Bad current date
		if( ( new Date( cur ) ).toString() === 'Invalid Date' ) {
			return ;
		}

		var val = this.getData( 'ltPropCurrentDate' );
		var newDate = new Date( val );
		newDate.setDate( 1 );
		this.setData( 'viewDate', newDate );
		this.setData( 'monthHeader', this.getMonthHeader.call( this ) );
		this.setDatesFunction();
		this.showtoday.call( this )
	}.observes( 'ltPropCurrentDate' ),

	monthHeaderFormatObserver: function() {
		this.setData( 'monthHeader', this.getMonthHeader.call( this ) );
	}.observes( 'ltPropMonthHeaderFormat' ),

	changeCurrentDate: function( set, val ) {
		var inter, to, from = new Date( this.getData( 'viewDate' ).getTime() ), fromDate, toDate;
		if( set === 'Y' ) {
			inter = this.getData( 'viewDate' )
			inter.setYear( 1900 + inter.getYear() + val )
			to = new Date( inter.getTime() )
			this.setData( 'viewDate', inter )
			this.setData( 'monthHeader', this.getMonthHeader.call( this ) )
			this.setData( 'changeData', this.getData( 'changeData' ) + 1 )
			this.showtoday.call( this )
		}
		else if( set === 'M' ) {
			inter = this.getData( 'viewDate' )
			inter.setMonth( inter.getMonth() + val )
			to = new Date( inter.getTime() )
			this.setData( 'viewDate', inter )
			this.setData( 'monthHeader', this.getMonthHeader.call( this ) )
			this.setData( 'changeData', this.getData( 'changeData' ) + 1 )
			this.showtoday.call( this )
		}

		fromDate = this.getDateFromFormat( from, this.getData( 'ltPropFormat' ) );
		toDate = this.getDateFromFormat( to, this.getData( 'ltPropFormat' ) );
		if( this.getMethods( 'onNavigate' ) ) {
			this.executeMethod( 'onNavigate', event, fromDate, toDate, this )
		}
	},

	/** 
	 * Get the proper calendar date item that was clicked
	 * @param {Element} elem - represents the element that was clickedd
	 *
	 */
	getProper: function( elem ) {
		while( elem 
			&& !elem.classList.contains( 'lyteCalTableCell' ) 
		) {
			elem = elem.parentElement;
		}

		return elem;
	},

	actions: {
		previous: function( val ) {
			this.changeCurrentDate( val, -1 );
		},

		next: function( val ) {
			this.changeCurrentDate( val, 1 );
		},

		dateSelected: function( event ) {
			var target = this.getProper( event.target ), ele;
			if( event.button !== 0 ) {
				return ;
			}

			ele = this.$node.getElementsByClassName( 'lyteCalSel' )
			if( ele.length !== 0 ){
				ele[0].classList.remove( 'lyteCalSel' )
			}

			this.setData( 'preventObs', true )
			this.setData( 'ltPropCurrentDate', target.getAttribute( 'data-date' ) )
			this.setData( 'preventObs', false )
			target.classList.add( 'lyteCalSel' )
			if( this.getMethods( 'onDateSelected' ) ){
				this.executeMethod( 'onDateSelected', event, target.getAttribute( 'data-date' ), this )
			}
		},

		today: function( event ) {
			this.revert( event );
		}

	},

	methods : {
		optionSelected : function(prop,event,selected,comp){
			if(prop == 'M'){
				var index = comp.getData('ltPropOptions').indexOf(selected);
				this.changeCurrentDate(prop, index - this.getData('viewDate').getMonth());
			}
			else if(prop == 'Y'){
				this.changeCurrentDate(prop, parseInt(selected) - this.getData('viewDate').getFullYear());
			}
		}
	}
});

Lyte.Component.register( 'lyte-checkbox', {
_template:"<template tag-name=\"lyte-checkbox\">\t<template is=\"switch\" value=\"{{ltPropType}}\">\t\t<template case=\"default\">\t\t\t<label class=\"lyteCheckbox lyteDefault\" onmouseup=\"{{action('mup',event)}}\" onclick=\"{{action('prevent',event)}}\">\t\t\t\t<input type=\"checkbox\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{ltPropChecked}}\" disabled=\"{{ltPropDisabled}}\" class=\"\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('checkBoxClicked',event)}}\">\t\t\t\t<span class=\"{{ltPropClass}}\">\t\t\t\t\t<span class=\"{{ltPropLabelClass}}\">\t\t\t\t\t\t{{ltPropLabel}}\t\t\t\t\t</span>\t\t\t\t</span>\t\t\t</label>\t\t\t</template>\t\t<template case=\"primary\">\t\t\t<label class=\"lyteCheckbox lytePrimary\" onmouseup=\"{{action('mup',event)}}\" onclick=\"{{action('prevent',event)}}\">\t\t\t\t<input type=\"checkbox\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{ltPropChecked}}\" disabled=\"{{ltPropDisabled}}\" class=\"\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('checkBoxClicked',event)}}\">\t\t\t\t<span class=\"{{ltPropClass}}\">\t\t\t\t\t<span class=\"{{ltPropLabelClass}}\">\t\t\t\t\t\t{{ltPropLabel}}\t\t\t\t\t</span>\t\t\t\t</span>\t\t\t</label>\t\t\t</template>\t\t<template case=\"switch\">\t\t\t<label class=\"\" onmouseup=\"{{action('mup',event)}}\" onclick=\"{{action('prevent',event)}}\">\t\t\t\t<input type=\"checkbox\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{ltPropChecked}}\" disabled=\"{{ltPropDisabled}}\" class=\"lyteHide on-off-sw\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('checkBoxClicked',event)}}\">\t\t\t\t<span class=\"{{ltPropClass}}\">\t\t\t\t\t<span class=\"on-btn\"></span>\t\t\t\t</span>\t\t\t\t<span class=\"{{ltPropLabelClass}}\">\t\t\t\t\t{{ltPropLabel}}\t\t\t\t</span>\t\t\t</label>\t\t\t</template>\t\t<template case=\"slider\">\t\t\t<label class=\"lyteCheckSliderLabel\" onmouseup=\"{{action('mup',event)}}\" onclick=\"{{action('prevent',event)}}\">\t\t\t\t<input type=\"checkbox\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{ltPropChecked}}\" disabled=\"{{ltPropDisabled}}\" class=\"lyteHide\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('checkBoxClicked',event)}}\">\t\t\t\t<span class=\"{{ltPropClass}}\">\t\t\t\t\t<span class=\"{{ltPropLabelClass}}\">\t\t\t\t\t\t{{ltPropLabel}}\t\t\t\t\t</span>\t\t\t\t</span>\t\t\t\t\t\t\t</label>\t\t\t</template>\t</template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"switch","position":[1],"cases":{"default":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,3,1]},{"type":"text","position":[1,3,1,1]}]},"primary":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,3,1]},{"type":"text","position":[1,3,1,1]}]},"switch":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,5]},{"type":"text","position":[1,5,1]}]},"slider":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,3,1]},{"type":"text","position":[1,3,1,1]}]}},"default":{}}],
_observedAttributes :["ltPropType","ltPropId","ltPropDisabled","ltPropChecked","ltPropLabel","ltPropName","ltPropValue","ltPropReadonly","ltPropFireOnInit","ltPropClass","ltPropLabelClass"],
	data: function() {
    	return {
			'ltPropType': Lyte.attr( 'string', { 
				'default': 'default' 
			} ),
			'ltPropId': Lyte.attr( 'string', { 
				'default': undefined
			} ),
			'ltPropDisabled': Lyte.attr( 'boolean', {
				'default': false
			} ),
			'ltPropChecked': Lyte.attr( 'boolean', { 
				'default': false 
			} ),
			'ltPropLabel': Lyte.attr( 'string', { 
				'default': undefined
			} ),
			'ltPropName': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropValue': Lyte.attr( 'string', { 
				'default': undefined
			} ),
			'ltPropReadonly': Lyte.attr( 'boolean', {
				'default': false
			} ),
			'ltPropFireOnInit': Lyte.attr( 'boolean', { 
				'default': false
			} ),
			'ltPropClass': Lyte.attr( 'string', {
				'default': ''
			} ),
			'ltPropLabelClass': Lyte.attr( 'string', { 
				'default': '' 
			} )
		}
	},

	reduceOpacity: function() {
		if( this.getData( 'ltPropDisabled' ) ) {
			this.$node.style.opacity = '0.5';
		}
		else {
			this.$node.style.opacity = '';
		}
	},

	disabledChange: function() {
		this.reduceOpacity();
	}.observes( 'ltPropDisabled' ),

	init: function() {
		var type = this.getData( 'ltPropType' ), cls = this.getData( 'ltPropClass' ),
		label = this.getData( 'ltPropLabelClass' );

		this.reduceOpacity();
		if( type === 'switch' && cls === '' ) {
			this.setData( 'ltPropClass', 'lyteCheckSwitch' );
		}
		else if( type === 'default' && cls === '' ) {
			this.setData( 'ltPropClass', 'lyteCheckBoxDefault' );
		}
		else if( type === 'primary' && cls === '' ) {
			this.setData( 'ltPropClass', 'lyteCheckBoxPrimary' );
		}
		else if( type === 'slider' && cls === '' ){
			this.setData( 'ltPropClass', 'lyteCheckSlider' );
		}

		if( type === 'slider' && label === '' ){
			this.setData( 'ltPropLabelClass', 'lyteCheckSliderText' );
		}
	},

	didConnect: function() {
		this.fireCallBacksFunction.call( this, undefined, true );
	},

	fireCallbacks:function(arg1,onrender) {
		if( this.getData( 'preventRefire' ) ) {
			return ;
		}
		
		this.fireCallBacksFunction.call( this, arg1, onrender );
	}.observes( 'ltPropChecked' ),

	fireCallBacksFunction: function( arg1, onrender ) {
		var checked = this.getData( 'ltPropChecked' ), 
		foi = this.getData( 'ltPropFireOnInit' ), returnval,
		eventCache = this.getData( 'eventCache' );

		this.$node.checked = checked ? checked : false;

		if( checked && onrender ) {
			if( !foi ) {
				return ;
			}

			var input = this.$node.querySelector( 'input' );
			if( this.getMethods( 'onBeforeChecked' ) ) {
				this.executeMethod( 'onBeforeChecked', input, this, eventCache );
			}

			if( this.getMethods( 'onChecked' ) ) {
				this.executeMethod( 'onChecked', input, this, eventCache )
			}

			if( this.getMethods( 'onChanged' ) ) {
				this.executeMethod('onChanged', input, this, eventCache )
			}
		}
		else if( this.$node.checked && !onrender ) {
			var input = this.$node.querySelector( 'input' )
			if( !this.clicked ) {
				if( this.getMethods( 'onBeforeChecked' ) ) {
					returnval = this.executeMethod( 'onBeforeChecked', input, this, eventCache ) == false ? false : true;
					if( !returnval ) {
						this.set( 'preventRefire', true );
						this.setData( 'ltPropChecked', false );
						this.set( 'preventRefire', false );
						return ;
					}
				}
			}

			input.checked = true
			if( this.getMethods( 'onChecked' ) ) {
				this.executeMethod( 'onChecked', input, this, eventCache );
			}

			if( this.getMethods( 'onChanged' ) ) {
				this.executeMethod( 'onChanged', input, this, eventCache );
			}
		}
		else if( !this.$node.checked && !onrender ) {
			var input = this.$node.querySelector( 'input' )
			if( !this.clicked ){
				if( this.getMethods( 'onBeforeUnchecked' ) ) {
					returnval = this.executeMethod( 'onBeforeUnchecked', input, this, eventCache ) == false ? false : true;
					if( !returnval ) {
						this.setData( 'preventRefire', true );
						this.setData( 'ltPropChecked', true);
						this.setData( 'preventRefire', false);
						return ;
					}
				}
			}

			input.checked = false
			if( this.getMethods( 'onUnchecked' ) ) {
				this.executeMethod( 'onUnchecked', input, this, eventCache );
			}

			if( this.getMethods( 'onChanged' ) ) {
				this.executeMethod( 'onChanged', input, this, eventCache );
			}
		}

	},

	actions: {
		mup: function( event ) {
			this.setData( 'sendEvent', false );
			var disabled = this.getData( 'ltPropDisabled' ), checked, returnval;
			if( disabled ) {
				return ;
			}

			var ele =  this.$node.querySelector( 'input' )
			checked = ele.checked
			if( this.getMethods( 'onBeforeChecked' ) && !checked ) {
				returnval = this.executeMethod( 'onBeforeChecked', ele, this, event ) == false ? false : true;
				if( !returnval ) {
					this.setData( 'prevented', true );
					event.preventDefault();
				}
			}

			if( this.getMethods( 'onBeforeUnchecked' ) && checked ) {
				returnval = this.executeMethod( 'onBeforeUnchecked', ele, this, event ) == false ? false : true;
				if( !returnval ) {
					this.setData( 'prevented', true )
					event.preventDefault();
				}
			}
		},

		prevent: function( event ) {
			var se = this.getData( 'sendEvent' );

			if( !se ) {
				event.stopPropagation();
			}
		},

		checkBoxClicked: function( event ) {
			this.setData( 'sendEvent', true );
			this.setData( 'eventCache', event );
			this.clicked = true
			var input;
			if( this.getData( 'prevented' ) ) {
				input = this.$node.querySelector( 'input' );
				this.setData( 'prevented', false )
				this.setData( 'preventRefire', true )
				if( input.checked ) {
					input.checked = false
				}
				else {
					input.checked = true
				}

				this.setData( 'preventRefire', false )
				this.clicked = false
				this.setData( 'eventCache', undefined );
				return;
			}

			if( this.getData( 'ltPropDisabled' ) ) {
				this.clicked = false
				event.preventDefault()
				this.setData( 'eventCache', undefined );
				return ;
			}

			var checked
			var ele = event.target
			checked = ele.checked;

			if( !checked ) {
				this.setData( 'ltPropChecked', false )
			}
			else{
				this.setData( 'ltPropChecked', true ) 
			}

			this.setData( 'eventCache', undefined );

			this.clicked = false
		}
	}
});

LyteColorbox = {
	_boxElement : 'lyteCBoxElement',
	_box : null,
	_content : null,
	_overlay : null,
	_title : null,
	_close : null,
	_download : null,
	_next : null,
	_prev : null,
	_open : null,
	_active : null,
	_closing : null,
	_previousOffset : {},
	_first : true,
	_photo : null,
	_related : null,
	_el : null,
	_photoRegex : /\.(gif|png|jp(e|g|eg)|bmp|ico|webp|jxr|svg)((#|\?).*)?$/i,
	_index : 0,
	_zoom : false,
	_component : null,
	_init : null,
	_winheight : null,
	_winWidth : null,
	_isArray : false,
	_hrefArray : [],
	_titleArray : [],

	setSize : function(size, dimension, param) {
		if(/%/.test(size)){
			return parseInt(size);
		}
		else{
			return Math.round((dimension === 'x' ? (isNaN(size/param) ? 0 : size/param) : (isNaN(size/param) ? 0 : size/param)) * 100);
		}
		// return Math.round((/%/.test(size) ? ((dimension === 'x' ? $window.width() : winheight()) / 100) : 1) * parseInt(size, 10));
	},

	createElement : function(tagName,id,className){
		var element = document.createElement(tagName);
		if (id) {
			element.id = id;
		}
		if (className) {
			$L(element).addClass(className);
		}
		return element;
	},

	getSelector : function(compSelectors,elemClasses){
		for(var i = 0; i<compSelectors.length; i++){
			if(elemClasses.indexOf(compSelectors[i]) != -1){
				return compSelectors[i];
			}
		}
		return false;
	},

	getIndex : function(increment) {
		var max = LyteColorbox._related.length,
		newIndex = (LyteColorbox._index + increment) % max;

		return (newIndex < 0) ? max + newIndex : newIndex;
	},

	isImage : function(url) {
		return LyteColorbox._photo || LyteColorbox._photoRegex.test(url);
	},

	createName : function(param){
		return param.replace(/[ ,-]/g,"_");
	},

	getRelated : function(rel) {
		LyteColorbox._index = 0;
		LyteColorbox._related = [];
		if (rel && rel !== false && rel !== 'nofollow') {
			var elements = Array.from(document.querySelectorAll('.' + LyteColorbox._boxElement)).filter(function (node) {
				return (LyteColorbox.getSelector(LyteColorbox._component.getData('ltPropSelectors'),Array.from(node.classList)) === rel);
			});
			for(var i = 0;i<elements.length;i++){
				var obj = Object.assign({},elements[i].dataset);
				obj.classList = elements[i].classList ? elements[i].classList : [rel];
				LyteColorbox._related.push(obj);
			}
			LyteColorbox._index = LyteColorbox._related.findIndex( function(obj) { return obj.lytecboxHref == LyteColorbox._el.lytecboxHref && obj.lytecboxTitle == LyteColorbox._el.lytecboxTitle});

			// Check direct calls to Colorbox.
			if (LyteColorbox._index === -1) {
				LyteColorbox._related = LyteColorbox._related.push(LyteColorbox._el);
				LyteColorbox._index = LyteColorbox._related.length - 1;
			}
		} else {
			LyteColorbox._related = LyteColorbox._el;
		}
	},

	appendHTML : function() {
		if (!LyteColorbox._box) {
			LyteColorbox._init = false;
			var comp = LyteColorbox._component;
			// debugger
			LyteColorbox._content = comp.$node.querySelector('.lyteCBoxContent');
			LyteColorbox._overlay = comp.$node.querySelector('.lyteCBoxOverlay');
			LyteColorbox._title = comp.$node.querySelector('.lyteCBoxTitle');
			LyteColorbox._close = comp.$node.querySelector('.lyteCBoxClose');
			LyteColorbox._download = comp.$node.querySelector('.lyteCBoxDownload');
			LyteColorbox._next = comp.$node.querySelector('.lyteCBoxNext');
			LyteColorbox._prev = comp.$node.querySelector('.lyteCBoxPrevious');
			LyteColorbox._box = comp.$node.querySelector('.lyteCBox') ? comp.$node.querySelector('.lyteCBox') : false;
			if(!LyteColorbox._box){
				LyteColorbox._box = LyteColorbox.createElement('div',null,'lyteCBox');
				var children = comp.$node.querySelector('lyte-yield').children;
				while(children.length > 0){
					LyteComponent.appendChild(LyteColorbox._box,children[0]);
				}
				LyteColorbox._box.classList.add('lyteColorbox');
			}
		}
		if (document.body && ((LyteColorbox._box.parentElement && LyteColorbox._box.parentElement.tagName != "BODY") || !LyteColorbox._box.parentElement) ) {
			LyteComponent.appendChild(document.body,LyteColorbox._box);
		}
	},

	launch : function(element) {
		if (!LyteColorbox._closing) {
			LyteColorbox._el = element;
			LyteColorbox.getRelated(LyteColorbox.getSelector(LyteColorbox._component.getData('ltPropSelectors'),Array.from(element.classList)));
			// LyteColorbox._component.setData('ltPropGroup',LyteColorbox._related);
			var returnVal = LyteColorbox._component.callOnBeforeOpen(LyteColorbox._related) == false ? false : true;
			if(!returnVal){
				LyteColorbox._related = null;
				LyteColorbox._el - null;
				return;
			}
			// LyteColorbox._related = LyteColorbox._component.getData('ltPropGroup');
			LyteColorbox._index = LyteColorbox._related instanceof Array ? LyteColorbox._related.findIndex( function(obj) { return obj.lytecboxHref == LyteColorbox._el.lytecboxHref && obj.lytecboxTitle == LyteColorbox._el.lytecboxTitle}) : 0;
			if(!LyteColorbox._component.getData('ltPropYield')){
				if(LyteColorbox._related.length > 1){
					LyteColorbox._next.classList.remove('lyteColorboxHideVisibility');
					LyteColorbox._prev.classList.remove('lyteColorboxHideVisibility');
				}
				else{
					LyteColorbox._next.classList.add('lyteColorboxHideVisibility');
					LyteColorbox._prev.classList.add('lyteColorboxHideVisibility');
				}
			}

			if (!LyteColorbox._open) {

				LyteColorbox._open = LyteColorbox._active = true; // Prevents the page-change action from queuing up if the visitor holds down the left or right keys.

				// setClass(settings.get('className'));
				LyteColorbox._box.classList.add('lyteColorboxHideVisibility','lyteColorboxDisplay');
				LyteColorbox.computeOffsetImpl();
				if(document.querySelector('.lyteCBoxPhoto')){
					document.querySelector('.lyteCBoxPhoto').remove();
				}
				LyteColorbox._box.classList.remove('lyteColorboxHideVisibility');
				LyteColorbox._component.callOnOpen();
				setTimeout(function(){
					LyteColorbox.load(element);
				},100)
				
			}
			else{
				LyteColorbox.load(element);
			}

			
		}
	},

	load : function(element){

		LyteColorbox._active = true;
		LyteColorbox._photo = false;
		
		href = element.lytecboxHref;
		title = element.lytecboxTitle;
		LyteColorbox._title.textContent = title;
		if(LyteColorbox.isImage(href)){
			LyteColorbox._photo = new Image();
			LyteColorbox._photo.classList.add("lyteCBoxPhoto","lyteCBoxPhotoZoomIn");
			LyteColorbox._photo.src = href;
			LyteColorbox._photo.alt = LyteColorbox._component.getData('ltPropImgError');
			
			LyteColorbox._photo.onload = function(){
				// debugger
				LyteColorbox.computeOffsetImpl(null,LyteColorbox._photo);
				LyteColorbox._component.callOnLoad(LyteColorbox._photo);
			};

		}

	},

	calculateOverlayHeight : function(winheight){
		if(!LyteColorbox._component.getData('ltPropYield')){
			LyteColorbox._overlay.style.height = winheight - 50 + "px";
		}
		else{
			LyteColorbox._overlay.style.height = LyteColorbox._overlay.getBoundingClientRect().height + "px";
		}
	},

	computeOffsetImpl : function(event,photo){
		if(LyteColorbox._open){
			var winWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	    	var winheight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
	    	if(!LyteColorbox._component.getData('ltPropYield')){
				LyteColorbox.calculateOverlayHeight(winheight);
			}
			var offset = {};
			if(!LyteColorbox._first){
				window.removeEventListener('resize',LyteColorbox.computeOffsetImpl);
			}
			LyteColorbox._first = false;
	    	var overlayOffset = LyteColorbox._overlay.getBoundingClientRect();
			if(photo){
				LyteColorbox._content.style.overflow = 'hidden';
				if(LyteColorbox._component.getData('ltPropHeight')){
					offset.conHeight = parseInt(LyteColorbox._component.getData('ltPropHeight'));
				}
				else{
					if(photo.height >= overlayOffset.height){
						offset.conHeight = overlayOffset.height;
					}
					else{
						offset.conHeight = photo.height;
					}
				}
				if(LyteColorbox._component.getData('ltPropWidth')){
					offset.conWidth = parseInt(LyteColorbox._component.getData('ltPropWidth'));
				}
				else{
					if(photo.width >= overlayOffset.width){
						offset.conWidth = overlayOffset.width;
					}
					else{
						offset.conWidth = photo.width;
					}
				}

				LyteColorbox._content.style.height = LyteColorbox.setSize(offset.conHeight,'y',winheight) + "%";
				LyteColorbox._content.style.width = LyteColorbox.setSize(offset.conWidth,'x',winWidth) + "%";
				photo.style.height = "100%";
				photo.style.width = "100%";
				if(!LyteColorbox._component.getData('ltPropYield')){
					if(document.querySelector('.lyteColorboxLoadingImg').style.display != "none"){
						document.querySelector('.lyteColorboxLoadingImg').style.display = "none";
					}
				}
				
				LyteColorbox._content.append(photo);
				LyteColorbox._active = false;

			}
			if(!LyteColorbox._component.getData('ltPropYield')){
				offset.top = (winheight - LyteColorbox._content.getBoundingClientRect().height) / 2 ;
				offset.left = (winWidth - LyteColorbox._content.getBoundingClientRect().width) / 2;
				offset.iconTop = ((winheight - LyteColorbox._next.getBoundingClientRect().height) / 2 ) + (document.querySelector('.lyteColorboxHeader').getBoundingClientRect().height / 2);
				LyteColorbox._content.style.top = offset.top + (document.querySelector('.lyteColorboxHeader').getBoundingClientRect().height / 2) + "px";
				LyteColorbox._content.style.left = offset.left + "px";
				LyteColorbox._next.style.top = offset.iconTop + "px";
				LyteColorbox._next.style.left = winWidth - LyteColorbox._next.getBoundingClientRect().width + "px";
				LyteColorbox._prev.style.top = offset.iconTop + "px";
				LyteColorbox._prev.style.left = "0px";
			}
			else{
				var contentOffset = LyteColorbox._content.getBoundingClientRect();
				var overlayOffset = LyteColorbox._overlay ? LyteColorbox._overlay.getBoundingClientRect() : {height : winheight, width : winWidth};
				LyteColorbox._content.style.top = (overlayOffset.height - contentOffset.height) / 2 + "px";
				LyteColorbox._content.style.left = (overlayOffset.width - contentOffset.width) / 2 + "px";
				if(window.getComputedStyle(LyteColorbox._content).transform){
					LyteColorbox._content.style.transform = "none";
				}
			}
			
			window.addEventListener('resize',LyteColorbox.computeOffsetImpl);
		}
	},
	// Navigates to the next page/image in a set.
	next : function () {
		if (!LyteColorbox._active && LyteColorbox._related[1] && (LyteColorbox._component.getData('ltPropLoop') || LyteColorbox._related[LyteColorbox._index + 1])) {
			if(LyteColorbox._zoom){
				LyteColorbox._zoom = false;
				document.querySelector('.lyteCBoxPhoto').classList.remove('lyteCBoxPhotoZoomOut');
				document.querySelector('.lyteCBoxPhoto').classList.add('lyteCBoxPhotoZoomIn');
			}
			document.querySelector('.lyteCBoxPhoto').remove();
			LyteColorbox._index = LyteColorbox.getIndex(1);
			LyteColorbox._photo = null;
			LyteColorbox.load(LyteColorbox._related[LyteColorbox._index]);
		}
	},

	prev : function () {
		if (!LyteColorbox._active && LyteColorbox._related[1] && (LyteColorbox._component.getData('ltPropLoop') || LyteColorbox._index)) {
			if(LyteColorbox._zoom){
				LyteColorbox._zoom = false;
				document.querySelector('.lyteCBoxPhoto').classList.remove('lyteCBoxPhotoZoomOut');
				document.querySelector('.lyteCBoxPhoto').classList.add('lyteCBoxPhotoZoomIn');
			}
			document.querySelector('.lyteCBoxPhoto').remove();
			LyteColorbox._index = LyteColorbox.getIndex(-1);
			LyteColorbox._photo = null;
			LyteColorbox.load(LyteColorbox._related[LyteColorbox._index]);
		}
	},

	
	close : function () {
		if (LyteColorbox._open && !LyteColorbox._closing) {
			if(LyteColorbox._zoom){
				LyteColorbox._zoom = false;
				document.querySelector('.lyteCBoxPhoto').classList.remove('lyteCBoxPhotoZoomOut');
				document.querySelector('.lyteCBoxPhoto').classList.add('lyteCBoxPhotoZoomIn');
			}
			LyteColorbox._closing = true;
			LyteColorbox._open = false;
			LyteColorbox._box.classList.remove('lyteColorboxDisplay');
			LyteColorbox._component.callOnClose();
			LyteColorbox._photo = null;
			LyteColorbox._related = [];
			LyteColorbox._closing = false;
			LyteColorbox._el = null;
		}
	},

	download : function(){
		// debugger
		var a = document.createElement('a');
		a.setAttribute("href", LyteColorbox._el.lytecboxHref);
		a.setAttribute("download", LyteColorbox.createName(LyteColorbox._el.lytecboxTitle));
		document.body.append(a);
		a.click();
		a.remove();
	},

	zoomIn : function(){
		LyteColorbox._previousOffset = {
			width : LyteColorbox._content.style.width,
			height : LyteColorbox._content.style.height
		};
		var winWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    	var winheight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
		var zoomBy = LyteColorbox._el.lytecboxZoomBy ? parseInt(LyteColorbox._el.lytecboxZoomBy) : parseInt(LyteColorbox._component.getData('ltPropZoomBy'));
		var contentOffset = LyteColorbox._content.getBoundingClientRect();
		var overlayOffset = LyteColorbox._overlay.getBoundingClientRect();
		var newWidth = contentOffset.width * ((100+zoomBy) / 100);
		var newHeight = contentOffset.height * ((100+zoomBy) / 100);
		var widthPercent = 0;
		var heightPercent = 0;

		if(newWidth > overlayOffset.width){
			widthPercent = ((newWidth - overlayOffset.width) / overlayOffset.width) * 100;
			newWidth = overlayOffset.width;
			LyteColorbox._content.style.overflow = 'auto';
		}
		if(newHeight > overlayOffset.height){
			heightPercent = ((newHeight - overlayOffset.height) / overlayOffset.height) * 100;
			newHeight = overlayOffset.height;
			LyteColorbox._content.style.overflow = 'auto';
		}
		LyteColorbox._content.style.height = LyteColorbox.setSize(newHeight,'y',winheight) + "%";
		LyteColorbox._content.style.width = LyteColorbox.setSize(newWidth,'x',winWidth) + "%";
		LyteColorbox._photo.style.height = Math.round(100+heightPercent) + "%";
		LyteColorbox._photo.style.width = Math.round(100+widthPercent) + "%";
		LyteColorbox.computeOffsetImpl();
	},

	zoomOut : function(){
		LyteColorbox._content.style.overflow = 'hidden';
		LyteColorbox._content.style.height = LyteColorbox._previousOffset.height;
		LyteColorbox._content.style.width = LyteColorbox._previousOffset.width;
		LyteColorbox._photo.style.height = "100%";
		LyteColorbox._photo.style.width = "100%";
		LyteColorbox.computeOffsetImpl();
	}

};

Lyte.Component.register("lyte-colorbox", {
_template:"<template tag-name=\"lyte-colorbox\">\t<template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\">\t\t<lyte-yield yield-name=\"colorBoxYield\"></lyte-yield>\t</template><template case=\"false\">\t\t<div id=\"lyteColorbox\" class=\"lyteColorbox lyteCBox\">\t\t\t\t\t\t\t<div class=\"lyteColorboxHeader\">\t\t\t\t\t<div class=\"lyteColorboxTitle lyteCBoxTitle\"></div>\t\t\t\t\t<div class=\"lyteColorboxDownloadDiv lyteCBoxDownload\">\t\t\t\t\t\t<img src=\"/dist/bower_components/ui-components/components/images/download-arrow.svg\" style=\"height: 14px;\">\t\t\t\t\t</div>\t\t\t\t\t<div class=\"lyteColorboxCloseIcon lyteCBoxClose\">\t\t\t\t\t\t<svg viewport=\"0 0 12 12\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" style=\"width: 13px; height: 14px;\"><line x1=\"1\" y1=\"11\" x2=\"11\" y2=\"1\" stroke=\"white\" stroke-width=\"2\"></line><line x1=\"1\" y1=\"1\" x2=\"11\" y2=\"11\" stroke=\"white\" stroke-width=\"2\"></line></svg>\t\t\t\t\t</div>\t\t\t\t</div>\t\t\t\t<div class=\"lyteColorboxFreezeLayer lyteCBoxOverlay\"></div>\t\t\t\t<div class=\"lyteColorboxContent lyteCBoxContent\">\t\t\t\t\t<img class=\"lyteColorboxLoadingImg\" src=\"/dist/bower_components/ui-components/components/images/loading.gif\">\t\t\t\t</div>\t\t\t\t<div class=\"lyteColorboxIconDiv lyteCBoxPrevious\">\t\t\t\t\t<div class=\"lyteColorboxPreviousIcon\"></div>\t\t\t\t</div>\t\t\t\t<div class=\"lyteColorboxIconDiv lyteCBoxNext\">\t\t\t\t\t<div class=\"lyteColorboxNextIcon\"></div>\t\t\t\t</div>\t\t\t\t\t</div>\t</template></template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[]}},"default":{}}],
_observedAttributes :["ltPropYield","ltPropHeight","ltPropWidth","ltPropOverlayClose","ltPropLoop","ltPropArrowKey","ltPropSelectors","ltPropZoomBy","ltPropEscKey","ltPropImgError"],
	data : function(){
		return {
			'ltPropYield' : Lyte.attr("boolean",{"default":false}),
			'ltPropHeight' : Lyte.attr("string"),
			'ltPropWidth' : Lyte.attr("string"),
			'ltPropOverlayClose' : Lyte.attr("boolean",{"default":true}),
			'ltPropLoop' : Lyte.attr("boolean",{"default":true}),
			'ltPropArrowKey' : Lyte.attr("boolean",{"default":true}),
			'ltPropSelectors' : Lyte.attr("array",{"default" : []}),
			'ltPropZoomBy' : Lyte.attr("string",{"default":"50%"}),
			'ltPropEscKey' : Lyte.attr("boolean",{"default":true}),
			'ltPropImgError' : Lyte.attr("string",{"default":"This image failed to load."})
			
		}		
	},
	
	intialFunc : function(){
		// debugger
		if(!LyteColorbox._component){
			LyteColorbox._component = this;
		}
		LyteColorbox.appendHTML();

		var ele = this.getSelectorElements();
		if(ele.length > 0){
			this.addBindings(ele);
		}
		else{
			console.warn("No selector(s) provided to colorbox.")
		}
	}.observes('ltPropSelectors.[]').on('didConnect'),

	callOnBeforeOpen : function(arrayObj){
		var returnVal;
		if(this.getMethods('onBeforeOpen')){
			retrunVal = this.executeMethod('onBeforeOpen',arrayObj,this);
		}
		return returnVal;
	},

	callOnOpen : function(){
		if(this.getMethods('onOpen')){
			this.executeMethod('onOpen',this);
		}
	},

	callOnLoad : function(){
		if(this.getMethods('onLoad')){
			this.executeMethod('onLoad',arguments[0],this);
		}
	},

	getSelectorElements : function(){
		var selectors = this.getData('ltPropSelectors');
		var ele = [];
		for(var i = 0; i<selectors.length; i++){
			Lyte.arrayUtils(ele,'push',Array.from(document.querySelectorAll('.'+selectors[i])));
		}
		return ele;
	},

	callOnClose : function(){
		if(this.getMethods('onClose')){
			this.executeMethod("onClose",this);
		}
	},

	didDestroy: function() {
		// debugger
		if(!LyteColorbox._first){
			window.removeEventListener('resize',LyteColorbox.computeOffsetImpl);
		}
		LyteColorbox._component = null;
		LyteColorbox._box.remove();
		LyteColorbox._box = null;
		LyteColorbox._prev = null;
		LyteColorbox._next = null;
		LyteColorbox._content = null;
		LyteColorbox._overlay = null;;
		LyteColorbox._title = null;
		LyteColorbox._close = null;
		LyteColorbox._download = null;
		LyteColorbox._el = null;
	},

	clickHandler : function() {
		var e = event || window.event;
		// ignore non-left-mouse-clicks and clicks modified with ctrl / command, shift, or alt.
		// See: http://jacklmoore.com/notes/click-events/
		if (!(e.which > 1 || e.shiftKey || e.altKey || e.metaKey || e.ctrlKey)) {
			e.preventDefault();
			var obj = Object.assign({},this.dataset);
			obj.classList = this.classList;
			LyteColorbox.launch(obj);
		}
	},

	addBindings : function(ele) {

		if (LyteColorbox._box) {

			if(!LyteColorbox._init){
				LyteColorbox._init = true;
				
				if(LyteColorbox._next){
					LyteColorbox._next.addEventListener('click',function () {
						LyteColorbox.next();
					},true);
				}
				if(LyteColorbox._prev){
					LyteColorbox._prev.addEventListener('click',function () {
						LyteColorbox.prev();
					},true);
				}
				if(LyteColorbox._close){
					LyteColorbox._close.addEventListener('click',function () {
						LyteColorbox.close();
					},true);
				}
				if(LyteColorbox._overlay){
					LyteColorbox._overlay.addEventListener('click',function () {
						if (LyteColorbox._component.getData('ltPropOverlayClose')) {
							LyteColorbox.close();
						}
					},true);
				}
				if(LyteColorbox._download){
					LyteColorbox._download.addEventListener('click',function(){
						LyteColorbox.download();
					},true);
				}
				LyteColorbox._content.addEventListener('click',function(){
					if(!LyteColorbox._zoom){
						LyteColorbox._zoom = true;
						document.querySelector('.lyteCBoxPhoto').classList.remove('lyteCBoxPhotoZoomIn');
						document.querySelector('.lyteCBoxPhoto').classList.add('lyteCBoxPhotoZoomOut');
						LyteColorbox.zoomIn();
					}
					else{
						LyteColorbox._zoom = false;
						document.querySelector('.lyteCBoxPhoto').classList.remove('lyteCBoxPhotoZoomOut');
						document.querySelector('.lyteCBoxPhoto').classList.add('lyteCBoxPhotoZoomIn');
						LyteColorbox.zoomOut();
					}
				},true);

				// Key Bindings
				document.addEventListener('keydown', function (e) {
					var key = e.keyCode;
					if (LyteColorbox._open && LyteColorbox._component.getData('ltPropEscKey') && key === 27) {
						e.preventDefault();
						LyteColorbox.close();
					}
					if (LyteColorbox._open && LyteColorbox._component.getData('ltPropArrowKey') && LyteColorbox._related[1] && !e.altKey) {
						if (key === 37) {
							e.preventDefault();
							if(LyteColorbox._prev){
								LyteColorbox._prev.click();
							}
							else{
								if(LyteColorbox._related instanceof Array && LyteColorbox._related.length > 1){
									LyteColorbox.prev();
								}
							}
							
							
						} else if (key === 39) {
							e.preventDefault();
							if(LyteColorbox._next){
								LyteColorbox._next.click();
							}
							else{
								if(LyteColorbox._related instanceof Array && LyteColorbox._related.length > 1){
									LyteColorbox.next();
								}
							}
						}
					}
				});
			}
			
			

			// if(ele.length){
				for(var i = 0; i<ele.length; i++){
					ele[i].addEventListener("click",this.clickHandler,true);
					ele[i].classList.add(LyteColorbox._boxElement);
				}
			// }
			
			return true;
		}
		return false;
	}
});

/*------------------------   NOTES   ------------------------*/
/*
  Things needed to document:
  1. No fill color will return transparent as color value on select. - done
*/

if(!ColorPicker_Util){
	var ColorPicker_Util = {
		component : null,
		baseConverter : function(numberToConvert, oldBase, newBase) {
	        if (newBase == 10) {
	            return parseInt(numberToConvert, 16);
	        }
	        if (newBase == 16) {
	            return parseInt(numberToConvert).toString(16);
	        }
	        numberToConvert = numberToConvert + "";
	        numberToConvert = numberToConvert.toUpperCase();
	        var listOfCharacters = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	        var dec = 0;
	        for (var i = 0; i <= numberToConvert.length; i++) {
	            dec += (listOfCharacters.indexOf(numberToConvert.charAt(i))) * (Math.pow(oldBase, (numberToConvert.length - i - 1)));
	        }
	        numberToConvert = "";
	        var magnitude = Math.floor((Math.log(dec)) / (Math.log(newBase)));
	        for (var i = magnitude; i >= 0; i--) {
	            var amount = Math.floor(dec / Math.pow(newBase, i));
	            numberToConvert = numberToConvert + listOfCharacters.charAt(amount);
	            dec -= amount * (Math.pow(newBase, i));
	        }
	        if (numberToConvert.length == 0){
	            numberToConvertToConvert = 0;
	        }
	        if (!numberToConvert){
	            numberToConvert = 0;
	        }
	        return numberToConvert;
	    },
	    getHsvByRgbCode : function(rgbColor) {
	        var rgbColor = rgbColor.replace('#', ''),
	        red = ColorPicker_Util.baseConverter(rgbColor.substr(0, 2), 16, 10),
	        green = ColorPicker_Util.baseConverter(rgbColor.substr(2, 2), 16, 10),
	        blue = ColorPicker_Util.baseConverter(rgbColor.substr(4, 2), 16, 10);
	        if (red == 0 && green == 0 && blue == 0) {
	            var returnArray = {};
	            returnArray.hue = 0;
	            returnArray.saturation = 0;
	            returnArray.brightness = 0;
	            return returnArray;
	        }
	        red = red / 255;
	        green = green / 255;
	        blue = blue / 255;
	        maxValue = Math.max(red, green, blue);
	        minValue = Math.min(red, green, blue);
	        var hue = 0;
	        if (maxValue == minValue) {
	            hue = 0;
	            saturation = 0;
	        } else {
	            if (red == maxValue) {
	                hue = (green - blue) / (maxValue - minValue) / 1;
	            } else if (green == maxValue) {
	                hue = 2 + (blue - red) / 1 / (maxValue - minValue) / 1;
	            } else if (blue == maxValue) {
	                hue = 4 + (red - green) / (maxValue - minValue) / 1;
	            }
	            saturation = (maxValue - minValue) / maxValue;
	        }
	        hue = hue * 60;
	        valueBrightness = maxValue;
	        if (hue < 0){
	            hue += 360;
	        }
	        var returnArray = {};
	        returnArray.hue = hue;
	        returnArray.saturation = saturation;
	        returnArray.brightness = valueBrightness;
	        return returnArray;
	    },
	    getRgbCodeByRgbColors : function(red, green, blue) {
	        var red = ColorPicker_Util.baseConverter(red, 10, 16),
	        green = ColorPicker_Util.baseConverter(green, 10, 16),
	        blue = ColorPicker_Util.baseConverter(blue, 10, 16);
	        red = red + "";
	        green = green + "";
	        blue = blue + "";
	        while (red.length < 2) {
	            red = "0" + red;
	        }
	        while (green.length < 2) {
	            green = "0" + green;
	        }
	        while (blue.length < 2) {
	            blue = "0" + "" + blue;
	        }
	        rgbColor = red + "" + green + "" + blue;
	        return rgbColor.toUpperCase();
	    },
	    getRgbColorsByRgbCode : function(rgbCode) {
	        var retArray = {};
	        retArray.red = ColorPicker_Util.baseConverter(rgbCode.substr(0, 2), 16, 10);
	        retArray.green = ColorPicker_Util.baseConverter(rgbCode.substr(2, 2), 16, 10);
	        retArray.blue = ColorPicker_Util.baseConverter(rgbCode.substr(4, 2), 16, 10);
	        return retArray;
	    },
	    getRgbColorsByHsv : function(hue, saturation, valueBrightness) {
	        var Hi = Math.floor(hue / 60),
	        red,green,blue,f,p,q,t;
	        if (hue == 360){
	            hue = 0;
	        }
	        f = hue / 60 - Hi;
	        if (saturation > 1){
	            saturation /= 100;
	        }
	        if (valueBrightness > 1){
	            valueBrightness /= 100;
	        }
	        p = (valueBrightness * (1 - saturation));
	        q = (valueBrightness * (1 - (f * saturation)));
	        t = (valueBrightness * (1 - ((1 - f) * saturation)));
	        switch (Hi) {
	        case 0:
	            red = valueBrightness;
	            green = t;
	            blue = p;
	            break;
	        case 1:
	            red = q;
	            green = valueBrightness;
	            blue = p;
	            break;
	        case 2:
	            red = p;
	            green = valueBrightness;
	            blue = t;
	            break;
	        case 3:
	            red = p;
	            green = q;
	            blue = valueBrightness;
	            break;
	        case 4:
	            red = t;
	            green = p;
	            blue = valueBrightness;
	            break;
	        default:
	            red = valueBrightness;
	            green = p;
	            blue = q;
	            break;
	        }
	        if (saturation == 0) {
	            red = valueBrightness;
	            green = valueBrightness;
	            blue = valueBrightness;
	        }
	        red *= 255;
	        green *= 255;
	        blue *= 255;
	        red = Math.round(red);
	        green = Math.round(green);
	        blue = Math.round(blue);
	        return {
	            red: red,
	            green: green,
	            blue: blue
	        }
	    },
	    getRgbCodeByHsv : function(hue, saturation, valueBrightness) {
	        while (hue >= 360){
	            hue -= 360;
	        }
	        var colors = ColorPicker_Util.getRgbColorsByHsv(hue, saturation, valueBrightness);
	        return ColorPicker_Util.getRgbCodeByRgbColors(colors.red, colors.green, colors.blue);
	    },
	    getLeftPos : function(el) {
	        if (document.getBoxObjectFor) {
	            if (el.tagName != 'INPUT' && el.tagName != 'SELECT' && el.tagName != 'TEXTAREA'){
	                return document.getBoxObjectFor(el).x
	            }
	        }
	        var ret = el.offsetLeft;
	        while ((el = el.offsetParent) != null) {
	            if (el.tagName != 'HTML') {
	                ret += el.offsetLeft;
	                if (document.all){
	                    ret += el.clientLeft;
	                }
	            }
	        }
	        return ret;
	    },
	    getTopPos : function(el) {
	        if (document.getBoxObjectFor) {
	            if (el.tagName != 'INPUT' && el.tagName != 'SELECT' && el.tagName != 'TEXTAREA'){
	                return document.getBoxObjectFor(el).y
	            }
	        }
	        var ret = el.offsetTop;
	        while ((el = el.offsetParent) != null) {
	            if (el.tagName != 'HTML') {
	                ret += (el.offsetTop - el.scrollTop);
	                if (document.all){
	                    ret += el.clientTop;
	                }
	            }
	        }
	        return ret;
	    },
	    getCmykByRgbColors: function(rgb){
			var c = 1 - rgb[0] / 255;
		    var m = 1 - rgb[1] / 255;
		    var y = 1 - rgb[2] / 255,k;

		    var min_cmy = Math.min(c, m, y);
		    c = (c - min_cmy) / (1 - min_cmy);
		    m = (m - min_cmy) / (1 - min_cmy);
		    y = (y - min_cmy) / (1 - min_cmy);
		    k = min_cmy;

		    c = isNaN( c )? 0 :c;
		    m = isNaN( m )? 0 :m;
		    y = isNaN( y )? 0 :y;

			return [c, m, y, k];
		},
		getColorPicker : function(arg){
			var ele = arg.closest('lyte-colorpicker');
			// console.log(arg);
			// console.log(ele);
			if(!ele){
				components = LytePopup.components;
				for(var i =components.length - 1; i>=0; i--){
					if(components[i].$node.parentElement.tagName == 'LYTE-COLORPICKER' && components[i].childComp.style.visibility == 'visible'){
						ele = components[i].childComp;
						break;
					}
				}
				if(ele){
					var div = ele.querySelector('.popoverWrapper');
					if(div && div.classList.length > 1){
						var className = div.className.split(" ")[1];
						var colorpickers = document.querySelectorAll('lyte-colorpicker');
						for(var i = 0 ; i<colorpickers.length ; i++){
							if(colorpickers[i].component.getData('ltPropWrapperClass') === className){
								ele = colorpickers[i];
								break;
							}
						}
					}
				}
			}
			return ele;
		}
	}
}

if(!ColorPicker_EventUtil){
	var ColorPicker_EventUtil = {
		__stopPropagation : false,
		__eventBound : false,
		__initHueMove: function(e,_this) {
			if(_this){
				_this.setData('hueStatus', 1);
		        // _this.setData('poxYHue', ColorPicker_Util.getTopPos(_this.getData('divElHueBar')));
		        _this.setData('poxXHue', ColorPicker_Util.getLeftPos(_this.getData('ltPropInline') ? _this.$node.querySelector('.colorSlider_hueBar') : _this.childComp.querySelector('.colorSlider_hueBar')));
		        _this.__setTextSelOk(false);
		        ColorPicker_EventUtil.__moveOnHueBar(e,_this);
		        return false;
			}
	    },

		__initPaletteMove : function(e,_this) {
	    	if(_this){
	    		var posdivElPalette = _this.getData('posdivElPalette');
		    	var circleOffsetBecauseOfWinWidget = _this.getData('circleOffsetBecauseOfWinWidget');
		    	var divElPalette =  _this.getData('ltPropInline') ? _this.$node.querySelector('#colorDiv') : _this.childComp.querySelector('#colorDiv');
		    	var circleOffsetSize = _this.getData('circleOffsetSize');
		        if (document.all){
		            e = event || window.event;
		        }
		        _this.__ffHackWinWidget();
		        posdivElPalette.x = ColorPicker_Util.getLeftPos(divElPalette) + circleOffsetBecauseOfWinWidget;
		        posdivElPalette.y = ColorPicker_Util.getTopPos(divElPalette) + circleOffsetBecauseOfWinWidget;
		        _this.setData('posdivElPalette',posdivElPalette);
		        _this.setData('dragStatus', 1);
		        _this.setData('paletteMaxX', (divElPalette.clientWidth - circleOffsetSize));
		        _this.setData('paletteMaxY', (divElPalette.clientHeight - circleOffsetSize));
		        ColorPicker_EventUtil.__moveOnPalette(e,_this);
		        _this.__setTextSelOk(false);
		        posdivElPalette = null;
		        divElPalette = null;
		        return false;
	    	}
	    },

	    __moveOnPalette : function(e,_this) {
	    	if(_this){
	    		e.preventDefault();
		    	var posdivElPalette = _this.getData('posdivElPalette');
		    	var circleOffsetSize = _this.getData('circleOffsetSize');
		    	var divElPaletteCircle = _this.getData('ltPropInline') ? _this.$node.querySelector('.colorSlider_palette_circle') : _this.childComp.querySelector('.colorSlider_palette_circle');
		        if (_this.getData('dragStatus') != 1){
		            return;
		        }
		        if (_this.getData('clickOnPaletteInProgress')){
		            return;
		        }
		        _this.setData('clickOnPaletteInProgress', true);
		        if (document.all){
		            e = event;
		        }
		        var leftEl = posdivElPalette.x;
		        var topEl = posdivElPalette.y;
		        var left = e.clientX + document.documentElement.scrollLeft - leftEl - circleOffsetSize;
		        var top = e.clientY + document.documentElement.scrollTop - topEl - circleOffsetSize;
		        if (left < circleOffsetSize * -1){
		            left = circleOffsetSize * -1;
		        }
		        if (top < circleOffsetSize * -1){
		            top = circleOffsetSize * -1;
		        }
		        if (left > _this.getData('paletteMaxX')){
		            left = _this.getData('paletteMaxX');
		        }
		        if (top > _this.getData('paletteMaxY')){
		            top = _this.getData('paletteMaxY');
		        }
		        divElPaletteCircle.style.left = left + 'px';
		        divElPaletteCircle.style.top = top + 'px';
		        _this.setData('currentSaturation', Math.round(((left + circleOffsetSize) / _this.getData('paletteSize').width) * 100));
		        _this.setData('currentBrightness', 100 - Math.round(((top + circleOffsetSize) / _this.getData('paletteSize').height) * 100));
		        _this.__setCurrentRgbCode();
		        _this.__setBgColorPreviewDiv();
		        _this.__updateRgbInForm();
		        _this.executeOnChange();
		        _this.setData('clickOnPaletteInProgress', false);
		        posdivElPalette = null;
		        divElPaletteCircle = null;
		        circleOffsetSize = null;
	    	}
	    },

	    __moveOnHueBar: function(e,_this) {
	    	if(_this){
	    		e.preventDefault();
		        if (_this.getData('hueStatus') != 1){
		            return;
		        }
		        if (document.all){
		            e = event;
		        }
		        var leftPos = _this.getData('poxXHue');
		        var diff = e.clientX + document.documentElement.scrollLeft - leftPos;
		        if (diff > _this.getData('paletteSize').height){
		            diff = _this.getData('paletteSize').height;
		        }
		        if (diff < 0){
		            diff = 0;
		        }
		        var ele = _this.getData('ltPropInline') ? _this.$node : _this.childComp;
		        if((diff - 9) > 247){
		        	ele.querySelector('.colorSlider_sliderHandle').style.left = '247px';
		        }
		        else{
		        	ele.querySelector('.colorSlider_sliderHandle').style.left = (diff - 9) + 'px';
		        }
		        var hue = Math.round(((_this.getData('paletteSize').height - diff) * (360 / _this.getData('paletteSize').height)));
		        if (hue == 360){
		            hue = 0;
		        }
		        _this.setData('currentHue', hue);
		        _this.__setCurrentRgbCode();
		        _this.__setPaletteBgColor();
		        _this.__setBgColorPreviewDiv();
		        _this.__updateRgbInForm();
		        _this.executeOnChange();
	    	}
	    },

	    __endDrag : function(e,_this) {
	    	if(_this){
	    		if(_this.getData('dragStatus') == 0 && _this.getData('hueStatus') == 0){
		    		return;
		    	}
		    	ColorPicker_EventUtil.__stopPropagation = true;
		        if (_this.getData('dragStatus') == 1) {
		            // _this.__updateHsvInForm();
		            _this.__updateRgbInForm();
		        }
		        _this.setData('dragStatus', 0);
		        _this.setData('hueStatus', 0);
		        _this.__setTextSelOk(true);
		        // var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(_this.getData('ltPropCurrentRgbCode'));
		        // var selectedColor = {
		        // 	"hex" : "#"+_this.getData('ltPropCurrentRgbCode'),
		        // 	"rgb" : "rgb("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+")"
		        // };
		        // _this.setData("ltPropSelectedColor",selectedColor);
		        _this.executeOnSelect();
	    	}
	    	ColorPicker_Util.component = null;
	    }
	}
}



Lyte.Component.register("lyte-colorpicker", {
_template:"<template tag-name=\"lyte-colorpicker\">\t<template is=\"if\" value=\"{{ltPropInline}}\"><template case=\"true\">\t<div class=\"lyteColorPicker\">\t\t<template is=\"if\" value=\"{{ltPropShowTitle}}\"><template case=\"true\">\t\t\t<div class=\"lyteColorPicker__titlebar\">\t\t\t\t<span class=\"lyteColorPicker__title\">{{ltPropTitle}}</span>\t\t\t\t\t\t\t</div>\t\t</template></template>\t\t<div class=\"lyteColorPicker__showhidecontainer\">\t\t\t<template is=\"if\" value=\"{{ltPropBasicColorPicker}}\"><template case=\"true\">\t\t\t\t<div class=\"lyteColorPicker__default\">\t\t\t\t\t<template is=\"if\" value=\"{{ltPropNoFillButton}}\"><template case=\"true\">\t\t\t\t\t<div class=\"lyteColorPicker__nocolorbutton\" onclick=\"{{action(&quot;noFillExecute&quot;,event)}}\">\t\t\t\t\t\t<span class=\"lyteColorPicker__icon\">\t\t\t\t\t\t\t<svg viewBox=\"0 0 16 16\">\t\t\t\t\t\t\t\t<path d=\"{{noFillPath}}\"></path>\t\t\t\t\t\t\t</svg>\t\t\t\t\t\t</span>\t\t\t\t\t\t<span class=\"lyteColorPicker__text\">{{ltPropNoFillLabel}}</span>\t\t\t\t\t</div>\t\t\t\t\t</template></template>\t\t\t\t\t<template is=\"if\" value=\"{{ltPropUsedColors}}\"><template case=\"true\">\t\t\t\t\t<div class=\"lyteColorPicker__palettecontainer usedColor__container\">\t\t\t\t\t\t<span class=\"lyteColorPicker__paletteheading\">{{lyteUiI18n(\"Recently.Used.Colors\")}}</span>\t\t\t\t\t\t<div class=\"lyteColorPicker__palette\">\t\t\t\t\t\t\t<ul class=\"used__colors\">\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{usedColors}}\" item=\"color\" index=\"indexVal\">\t\t\t\t\t\t\t\t<li class=\"lyteColorPicker__colorpan\" lt-prop-title=\"{{lyteRgbToHex(color)}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;showdelay&quot; : &quot;1000&quot;}\" onclick=\"{{action(&quot;selectColor&quot;, event, color)}}\">{{color}}</li>\t\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteCPInsertBreak(indexVal)}}\"><template case=\"true\">\t\t\t\t\t\t\t\t<br>\t\t\t\t\t\t\t\t</template></template>\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</ul>\t\t\t\t\t\t</div>\t\t\t\t\t</div>\t\t\t\t\t</template></template>\t\t\t\t\t<div class=\"lyteColorPicker__palettecontainer\">\t\t\t\t\t\t<span class=\"lyteColorPicker__paletteheading\">{{ltPropPaletteLabel}}</span>\t\t\t\t\t\t<div class=\"lyteColorPicker__palette\">\t\t\t\t\t\t\t<div>\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{availableColors}}\" item=\"colorArray\" index=\"indexVal\">\t\t\t\t\t\t\t\t<ul class=\".lyteColorPicker__shades default__colors\">\t\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{colorArray}}\" item=\"color\" index=\"indexVal\">\t\t\t\t\t\t\t\t\t<li class=\"lyteColorPicker__colorpan\" lt-prop-title=\"{{lyteRgbToHex(color)}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;showdelay&quot; : &quot;1000&quot;}\" onclick=\"{{action(&quot;selectColor&quot;, event, color)}}\">{{color}}</li>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t</ul>\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t</div>\t\t\t\t\t</div>\t\t\t\t\t<template is=\"if\" value=\"{{ltPropStandardColors}}\"><template case=\"true\">\t\t\t\t\t<div class=\"lyteColorPicker__palettecontainer\">\t\t\t\t\t\t<span class=\"lyteColorPicker__paletteheading\">{{lyteUiI18n(\"Standard.Colors\")}}</span>\t\t\t\t\t\t<div class=\"lyteColorPicker__palette\">\t\t\t\t\t\t\t<ul class=\"standard__colors\">\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{standardColorArray}}\" item=\"color\" index=\"indexVal\">\t\t\t\t\t\t\t\t<li class=\"lyteColorPicker__colorpan\" lt-prop-title=\"{{lyteRgbToHex(color)}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;showdelay&quot; : &quot;1000&quot;}\" onclick=\"{{action(&quot;selectColor&quot;, event, color)}}\">{{color}}</li>\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</ul>\t\t\t\t\t\t</div>\t\t\t\t\t</div>\t\t\t\t\t</template></template>\t\t\t\t\t<template is=\"if\" value=\"{{ltPropAdvancedColorButton}}\"><template case=\"true\">\t\t\t\t\t<div class=\"lyteColorPicker__navigatable lyteColorPicker__morecolorbutton\" onclick=\"{{action(&quot;goToAdvancedCP&quot;,event)}}\">\t\t\t\t\t\t<span class=\"lyteColorPicker__icon\">\t\t\t\t\t\t\t<svg viewBox=\"0 0 600 598\">\t\t\t\t\t\t\t\t<path d=\"{{moreColorsPath}}\"></path>\t\t\t\t\t\t\t</svg>\t\t\t\t\t\t</span>\t\t\t\t\t\t<span class=\"lyteColorPicker__text\" style=\"position: absolute; left: 50%; transform: translate(-50%);\">{{lyteUiI18n(\"Advanced.Colors\")}}</span>\t\t\t\t\t\t<span class=\"lyteColorpickerForwardArrow h-alignright\">\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\t\t\t\t\t</div>\t\t\t\t\t</template></template>\t\t\t\t\t<template is=\"if\" value=\"{{ltPropColorPreview}}\"><template case=\"true\">\t\t\t\t\t<div class=\"lyteColorPicker__colorfieldcontainer\">\t\t\t\t\t\t<div class=\"lyteColorPicker__colorfield\">\t\t\t\t\t\t\t<span class=\"lyteColorPicker__colorfieldpreview lyteColorPicker__transparentbg\">\t\t\t\t\t\t\t\t<div class=\"lyteColorPicker__dynamiccolor\" lt-prop-title=\"{{lyteUiI18n('Copy.Color.value.to.Clipboard')}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;}\" onmouseover=\"{{action(&quot;onOverColorPreviewDiv&quot;,event,&quot;fromBasic&quot;,&quot;over&quot;)}}\" onmouseout=\"{{action(&quot;onOverColorPreviewDiv&quot;,event,&quot;fromBasic&quot;,&quot;out&quot;)}}\" onclick=\"{{action(&quot;copyValueToClipboard&quot;,&quot;fromBasic&quot;)}}\">\t\t\t\t\t\t\t\t\t<div id=\"basciPreviewDivImg\" class=\"clipboardImg basicClipboardPos\"></div>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t</span>\t\t\t\t\t\t\t<input style=\"width: 157px;\" id=\"readColorValue\" class=\"lyteColorPicker__textbox h-hidecursor\" readonly=\"readonly\">\t\t\t\t\t\t</div>\t\t\t\t\t</div>\t\t\t\t\t</template></template>\t\t\t\t</div>\t\t\t</template><template case=\"false\">\t\t\t\t<div class=\"lyteColorPicker--advanced\">\t\t\t\t\t<div style=\"width: 320px;height: 258px;\">\t\t\t\t\t\t<div class=\"lyteColorPicker__maparea\">\t\t\t\t\t\t\t<div class=\"colorDiv\" id=\"colorDiv\">\t\t\t\t\t\t\t\t<div id=\"lyteCPImgDiv\"></div>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"colorSlider_palette_circle colorSlider_palette_circleBlack\"></div>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t</div>\t\t\t\t\t\t\t\t\t\t\t</div>\t\t\t\t\t<div class=\"lyteColorPicker__previewDiv\" style=\"padding: 3px 0px !important;\">\t\t\t\t\t\t<div class=\"colorSlider_hue\">\t\t\t\t\t\t\t<div class=\"colorSlider_sliderHandle\">\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t<div class=\"colorSlider_hueBar_border\">\t\t\t\t\t\t\t\t<div class=\"colorSlider_hueBar\"></div>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t</div>\t\t\t\t\t\t<div class=\"previewDiv\" onmouseover=\"{{action(&quot;onOverColorPreviewDiv&quot;,event,&quot;fromAdv&quot;,&quot;over&quot;)}}\" onmouseout=\"{{action(&quot;onOverColorPreviewDiv&quot;,event,&quot;fromAdv&quot;,&quot;out&quot;)}}\" onclick=\"{{action(&quot;copyValueToClipboard&quot;,&quot;fromAdv&quot;)}}\" lt-prop-title=\"{{lyteUiI18n('Copy.Color.value.to.Clipboard')}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;}\">\t\t\t\t\t\t\t<div id=\"copyColorValueImg\" class=\"clipboardImg advClipboardPos\"></div>\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\t\t\t\t\t</div>\t\t\t\t\t<div class=\"lyteColorPicker__previewDiv\">\t\t\t\t\t\t<div class=\"selectFormat\">\t\t\t\t\t\t\t<lyte-dropdown class=\"cPDropDown\" lt-prop-yield=\"true\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method(&quot;changeFormatView&quot;)}}\">\t\t\t\t\t\t\t\t<template is=\"registerYield\" yield-name=\"yield\">\t\t\t\t\t\t\t\t\t<lyte-drop-button class=\"colorPickerDD\">\t\t\t\t\t\t\t\t\t\t<span class=\"lyteMarginRight\">{{dropButtonValue}}</span>\t\t\t\t\t\t\t\t\t\t<lyte-icon class=\"dropdown\"></lyte-icon>\t\t\t\t\t\t\t\t\t</lyte-drop-button>\t\t\t\t\t\t\t\t\t<lyte-drop-box style=\"width: 83px;min-width:83px!important;\">\t\t\t\t\t\t\t\t\t\t<lyte-drop-body>\t\t\t\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{ltPropColorFormats}}\" item=\"item\" index=\"indexVal\">\t\t\t\t\t\t\t\t\t\t\t\t<lyte-drop-item data-value=\"{{item}}\"> {{item}} </lyte-drop-item>\t\t\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</lyte-drop-body>\t\t\t\t\t\t\t\t\t</lyte-drop-box>\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</lyte-dropdown>\t\t\t\t\t\t</div>\t\t\t\t\t\t<div>\t\t\t\t\t\t\t<div class=\"showValue\"><lyte-input id=\"lyteCPShowValue\" lt-prop-type=\"text\" lt-prop-appearance=\"box\" lt-prop-value=\"#000000\" lt-prop-direction=\"vertical\"> </lyte-input></div>\t\t\t\t\t\t</div>\t\t\t\t\t</div>\t\t\t\t\t<template is=\"if\" value=\"{{moreColorOptionSelected}}\"><template case=\"true\">\t\t\t\t\t\t<div class=\"lyteColorPicker__navigatable lyteColorPicker__morecolorbutton\" onclick=\"{{action(&quot;fromAdvCPtoBasic&quot;,event)}}\">\t\t\t\t\t\t\t<span class=\"lyteColorpickerBackwardArrow\"></span>\t\t\t\t\t\t\t<span class=\"lyteColorPicker__icon h-alignright\" style=\"    margin-top: 1px;\">\t\t\t\t\t\t\t\t<svg viewBox=\"0 0 600 598\">\t\t\t\t\t\t\t\t\t<path d=\"{{moreColorsPath}}\"></path>\t\t\t\t\t\t\t\t</svg>\t\t\t\t\t\t\t</span>\t\t\t\t\t\t\t<span class=\"lyteColorPicker__text lyteColorpickerText\">{{lyteUiI18n(\"Back.to.Basic.Colors\")}}</span>\t\t\t\t\t\t</div>\t\t\t\t\t</template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropInline,'!')}}\"><template case=\"true\">\t\t\t\t\t\t<div class=\"lyteColorPicker__commandbar\">\t\t\t\t\t\t\t<lyte-button lt-prop-appearance=\"primary\" style=\"float: right;\" onclick=\"{{action(&quot;closeColorPicker&quot;,event)}}\">\t\t\t\t\t\t\t\t<template is=\"registerYield\" yield-name=\"text\">Close</template>\t\t\t\t\t\t\t</lyte-button>\t\t\t\t\t\t</div>\t\t\t\t\t</template></template></template></template>\t\t\t\t</div>\t\t\t</template></template>\t\t</div>\t</div>\t</template><template case=\"false\">\t\t<lyte-popover class=\"lyteColorPicker popColorPicker\" on-close=\"{{method(&quot;closePopColorPicker&quot;)}}\" on-show=\"{{method(&quot;showColorPickerPopover&quot;,event)}}\">\t\t\t<template is=\"registerYield\" yield-name=\"popover\">\t\t\t\t<template is=\"if\" value=\"{{ltPropShowTitle}}\"><template case=\"true\">\t\t\t\t<lyte-popover-header class=\"lyteColorPicker__titlebar\">\t\t\t\t\t<span class=\"lyteColorPicker__title\">{{ltPropTitle}}</span>\t\t\t\t\t<template is=\"if\" value=\"{{ltPropCloseButton}}\"><template case=\"true\">\t\t\t\t\t<span class=\"lyteColorPicker__close\" onclick=\"{{action('closeColorPicker')}}\"></span>\t\t\t\t\t</template></template>\t\t\t\t</lyte-popover-header>\t\t\t\t</template></template>\t\t\t\t<lyte-popover-content class=\"lyteColorPicker__showhidecontainer\">\t\t\t\t\t<template is=\"if\" value=\"{{ltPropBasicColorPicker}}\"><template case=\"true\">\t\t\t\t\t<div class=\"lyteColorPicker__default\">\t\t\t\t\t\t<template is=\"if\" value=\"{{ltPropNoFillButton}}\"><template case=\"true\">\t\t\t\t\t\t<div class=\"lyteColorPicker__nocolorbutton\" onclick=\"{{action(&quot;noFillExecute&quot;,event)}}\">\t\t\t\t\t\t\t<span class=\"lyteColorPicker__icon\">\t\t\t\t\t\t\t\t<svg viewBox=\"0 0 16 16\">\t\t\t\t\t\t\t\t\t<path d=\"{{noFillPath}}\"></path>\t\t\t\t\t\t\t\t</svg>\t\t\t\t\t\t\t</span>\t\t\t\t\t\t\t<span class=\"lyteColorPicker__text\">{{ltPropNoFillLabel}}</span>\t\t\t\t\t\t</div>\t\t\t\t\t\t</template></template>\t\t\t\t\t\t<template is=\"if\" value=\"{{ltPropUsedColors}}\"><template case=\"true\">\t\t\t\t\t\t<div class=\"lyteColorPicker__palettecontainer usedColor__container\">\t\t\t\t\t\t\t<span class=\"lyteColorPicker__paletteheading\">{{lyteUiI18n(\"Recently.Used.Colors\")}}</span>\t\t\t\t\t\t\t<div class=\"lyteColorPicker__palette\">\t\t\t\t\t\t\t\t<ul class=\"used__colors\">\t\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{usedColors}}\" item=\"color\" index=\"indexVal\">\t\t\t\t\t\t\t\t\t<li class=\"lyteColorPicker__colorpan\" lt-prop-title=\"{{lyteRgbToHex(color)}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;showdelay&quot; : &quot;1000&quot;}\" onclick=\"{{action(&quot;selectColor&quot;, event, color)}}\">{{color}}</li>\t\t\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteCPInsertBreak(indexVal)}}\"><template case=\"true\">\t\t\t\t\t\t\t\t\t<br>\t\t\t\t\t\t\t\t\t</template></template>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t</ul>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t</div>\t\t\t\t\t\t</template></template>\t\t\t\t\t\t<div class=\"lyteColorPicker__palettecontainer\">\t\t\t\t\t\t\t<span class=\"lyteColorPicker__paletteheading\">{{ltPropPaletteLabel}}</span>\t\t\t\t\t\t\t<div class=\"lyteColorPicker__palette\">\t\t\t\t\t\t\t\t<div>\t\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{availableColors}}\" item=\"colorArray\" index=\"indexVal\">\t\t\t\t\t\t\t\t\t<ul class=\".lyteColorPicker__shades default__colors\">\t\t\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{colorArray}}\" item=\"color\" index=\"indexVal\">\t\t\t\t\t\t\t\t\t\t<li class=\"lyteColorPicker__colorpan\" lt-prop-title=\"{{lyteRgbToHex(color)}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;showdelay&quot; : &quot;1000&quot;}\" onclick=\"{{action(&quot;selectColor&quot;, event, color)}}\">{{color}}</li>\t\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t\t</ul>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t</div>\t\t\t\t\t\t<template is=\"if\" value=\"{{ltPropStandardColors}}\"><template case=\"true\">\t\t\t\t\t\t<div class=\"lyteColorPicker__palettecontainer\">\t\t\t\t\t\t\t<span class=\"lyteColorPicker__paletteheading\">{{lyteUiI18n(\"Standard.Colors\")}}</span>\t\t\t\t\t\t\t<div class=\"lyteColorPicker__palette\">\t\t\t\t\t\t\t\t<ul class=\"standard__colors\">\t\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{standardColorArray}}\" item=\"color\" index=\"indexVal\">\t\t\t\t\t\t\t\t\t<li class=\"lyteColorPicker__colorpan\" lt-prop-title=\"{{lyteRgbToHex(color)}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;,&quot;showdelay&quot; : &quot;1000&quot;}\" onclick=\"{{action(&quot;selectColor&quot;, event, color)}}\">{{color}}</li>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t</ul>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t</div>\t\t\t\t\t\t</template></template>\t\t\t\t\t\t<template is=\"if\" value=\"{{ltPropAdvancedColorButton}}\"><template case=\"true\">\t\t\t\t\t\t<div class=\"lyteColorPicker__navigatable lyteColorPicker__morecolorbutton\" onclick=\"{{action(&quot;goToAdvancedCP&quot;,event)}}\">\t\t\t\t\t\t\t<span class=\"lyteColorPicker__icon\">\t\t\t\t\t\t\t\t<svg viewBox=\"0 0 600 598\">\t\t\t\t\t\t\t\t\t<path d=\"{{moreColorsPath}}\"></path>\t\t\t\t\t\t\t\t</svg>\t\t\t\t\t\t\t</span>\t\t\t\t\t\t\t<span class=\"lyteColorPicker__text\" style=\"position: absolute; left: 50%; transform: translate(-50%);\">{{lyteUiI18n(\"Advanced.Colors\")}}</span>\t\t\t\t\t\t\t<span class=\"lyteColorpickerForwardArrow h-alignright\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\t\t\t\t\t\t</div>\t\t\t\t\t\t</template></template>\t\t\t\t\t\t<template is=\"if\" value=\"{{ltPropColorPreview}}\"><template case=\"true\">\t\t\t\t\t\t<div class=\"lyteColorPicker__colorfieldcontainer\">\t\t\t\t\t\t\t<div class=\"lyteColorPicker__colorfield\">\t\t\t\t\t\t\t\t<span class=\"lyteColorPicker__colorfieldpreview lyteColorPicker__transparentbg\">\t\t\t\t\t\t\t\t\t<div class=\"lyteColorPicker__dynamiccolor\" lt-prop-title=\"{{lyteUiI18n('Copy.Color.value.to.Clipboard')}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;}\" onmouseover=\"{{action(&quot;onOverColorPreviewDiv&quot;,event,&quot;fromBasic&quot;,&quot;over&quot;)}}\" onmouseout=\"{{action(&quot;onOverColorPreviewDiv&quot;,event,&quot;fromBasic&quot;,&quot;out&quot;)}}\" onclick=\"{{action(&quot;copyValueToClipboard&quot;,&quot;fromBasic&quot;)}}\">\t\t\t\t\t\t\t\t\t\t<div id=\"basciPreviewDivImg\" class=\"clipboardImg basicClipboardPos\"></div>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t\t</span>\t\t\t\t\t\t\t\t<input style=\"width: 157px;\" id=\"readColorValue\" class=\"lyteColorPicker__textbox h-hidecursor\" readonly=\"readonly\">\t\t\t\t\t\t\t</div>\t\t\t\t\t\t</div>\t\t\t\t\t\t</template></template>\t\t\t\t\t</div>\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t<div class=\"lyteColorPicker--advanced\">\t\t\t\t\t\t<div style=\"width: 320px;height: 258px;\">\t\t\t\t\t\t\t<div class=\"lyteColorPicker__maparea\">\t\t\t\t\t\t\t\t<div class=\"colorDiv\" id=\"colorDiv\">\t\t\t\t\t\t\t\t\t<div id=\"lyteCPImgDiv\"></div>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"colorSlider_palette_circle colorSlider_palette_circleBlack\"></div>\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\t<div class=\"lyteColorPicker__previewDiv\" style=\"padding: 3px 0px !important;\">\t\t\t\t\t\t\t<div class=\"colorSlider_hue\">\t\t\t\t\t\t\t\t<div class=\"colorSlider_sliderHandle\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t\t<div class=\"colorSlider_hueBar_border\">\t\t\t\t\t\t\t\t\t<div class=\"colorSlider_hueBar\"></div>\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t<div class=\"previewDiv\" onmouseover=\"{{action(&quot;onOverColorPreviewDiv&quot;,event,&quot;fromAdv&quot;,&quot;over&quot;)}}\" onmouseout=\"{{action(&quot;onOverColorPreviewDiv&quot;,event,&quot;fromAdv&quot;,&quot;out&quot;)}}\" onclick=\"{{action(&quot;copyValueToClipboard&quot;,&quot;fromAdv&quot;)}}\" lt-prop-title=\"{{lyteUiI18n('Copy.Color.value.to.Clipboard')}}\" lt-prop-tooltip-config=\"{&quot;position&quot; : &quot;bottom&quot;}\">\t\t\t\t\t\t\t\t<div id=\"copyColorValueImg\" class=\"clipboardImg advClipboardPos\"></div>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\t</div>\t\t\t\t\t\t<div class=\"lyteColorPicker__previewDiv\">\t\t\t\t\t\t\t<div class=\"selectFormat\">\t\t\t\t\t\t\t\t<lyte-dropdown class=\"cPDropDown\" lt-prop-yield=\"true\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method(&quot;changeFormatView&quot;)}}\">\t\t\t\t\t\t\t\t\t<template is=\"registerYield\" yield-name=\"yield\">\t\t\t\t\t\t\t\t\t\t<lyte-drop-button class=\"colorPickerDD\">\t\t\t\t\t\t\t\t\t\t\t<span class=\"lyteMarginRight\">{{dropButtonValue}}</span>\t\t\t\t\t\t\t\t\t\t\t<lyte-icon class=\"dropdown\"></lyte-icon>\t\t\t\t\t\t\t\t\t\t</lyte-drop-button>\t\t\t\t\t\t\t\t\t\t<lyte-drop-box style=\"width: 83px;min-width:83px!important;\">\t\t\t\t\t\t\t\t\t\t\t<lyte-drop-body>\t\t\t\t\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{ltPropColorFormats}}\" item=\"item\" index=\"indexVal\">\t\t\t\t\t\t\t\t\t\t\t\t\t<lyte-drop-item data-value=\"{{item}}\"> {{item}} </lyte-drop-item>\t\t\t\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</lyte-drop-body>\t\t\t\t\t\t\t\t\t\t</lyte-drop-box>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t</lyte-dropdown>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t<div>\t\t\t\t\t\t\t\t<div class=\"showValue\"><lyte-input id=\"lyteCPShowValue\" lt-prop-type=\"text\" lt-prop-appearance=\"box\" lt-prop-value=\"#000000\" lt-prop-direction=\"vertical\"> </lyte-input></div>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t</div>\t\t\t\t\t\t\t\t\t\t\t\t\t<template is=\"if\" value=\"{{moreColorOptionSelected}}\"><template case=\"true\">\t\t\t\t\t\t\t\t\t\t\t\t\t\t<div class=\"lyteColorPicker__navigatable lyteColorPicker__morecolorbutton\" onclick=\"{{action(&quot;fromAdvCPtoBasic&quot;,event)}}\">\t\t\t\t\t\t\t\t<span class=\"lyteColorpickerBackwardArrow\"></span>\t\t\t\t\t\t\t\t<span class=\"lyteColorPicker__icon h-alignright\" style=\"    margin-top: 1px;\">\t\t\t\t\t\t\t\t\t<svg viewBox=\"0 0 600 598\">\t\t\t\t\t\t\t\t\t\t<path d=\"{{moreColorsPath}}\"></path>\t\t\t\t\t\t\t\t\t</svg>\t\t\t\t\t\t\t\t</span>\t\t\t\t\t\t\t\t<span class=\"lyteColorPicker__text lyteColorpickerText\">{{lyteUiI18n(\"Back.to.Basic.Colors\")}}</span>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t\t\t<div class=\"lyteColorPicker__commandbar\">\t\t\t\t\t\t\t\t<lyte-button lt-prop-appearance=\"primary\" style=\"float: right;\" onclick=\"{{action(&quot;closeColorPicker&quot;,event)}}\">\t\t\t\t\t\t\t\t\t<template is=\"registerYield\" yield-name=\"text\">Close</template>\t\t\t\t\t\t\t\t</lyte-button>\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t</template></template>\t\t\t\t\t\t\t\t\t\t\t</div>\t\t\t\t\t</template></template>\t\t\t\t</lyte-popover-content>\t\t\t</template>\t\t</lyte-popover>\t</template></template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]}]}},"default":{}},{"type":"attr","position":[1,3,1]},{"type":"if","position":[1,3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1,1]},{"type":"text","position":[1,3,0]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3,1,1]},{"type":"for","position":[1,3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}]}},"default":{}},{"type":"text","position":[1,5,1,0]},{"type":"attr","position":[1,5,3,1,1]},{"type":"for","position":[1,5,3,1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}]},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3,1,1]},{"type":"for","position":[1,3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}]}},"default":{}},{"type":"attr","position":[1,9]},{"type":"if","position":[1,9],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1,1]},{"type":"text","position":[1,3,0]}]}},"default":{}},{"type":"attr","position":[1,11]},{"type":"if","position":[1,11],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1,1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,3,3]},{"type":"attr","position":[1,5,1,1]},{"type":"registerYield","position":[1,5,1,1,1],"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3,1,1]},{"type":"for","position":[3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3]}]},{"type":"componentDynamic","position":[1,5,1,1]},{"type":"componentDynamic","position":[1,5,3,1,0]},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,3,1,1]},{"type":"text","position":[1,5,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"registerYield","position":[1,1,1],"dynamicNodes":[]},{"type":"componentDynamic","position":[1,1]}]}},"default":{}}]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[3,1]},{"type":"if","position":[3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1,1]},{"type":"text","position":[1,3,0]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3,1,1]},{"type":"for","position":[1,3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}]}},"default":{}},{"type":"text","position":[1,5,1,0]},{"type":"attr","position":[1,5,3,1,1]},{"type":"for","position":[1,5,3,1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}]},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3,1,1]},{"type":"for","position":[1,3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}]}},"default":{}},{"type":"attr","position":[1,9]},{"type":"if","position":[1,9],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1,1]},{"type":"text","position":[1,3,0]}]}},"default":{}},{"type":"attr","position":[1,11]},{"type":"if","position":[1,11],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1,1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,3,3]},{"type":"attr","position":[1,5,1,1]},{"type":"registerYield","position":[1,5,1,1,1],"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3,1,1]},{"type":"for","position":[3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3]}]},{"type":"componentDynamic","position":[1,5,1,1]},{"type":"componentDynamic","position":[1,5,3,1,0]},{"type":"attr","position":[1,7]},{"type":"if","position":[1,7],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,3,1,1]},{"type":"text","position":[1,5,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"registerYield","position":[1,1,1],"dynamicNodes":[]},{"type":"componentDynamic","position":[1,1]}]}},"default":{}}]}},"default":{}},{"type":"componentDynamic","position":[3]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropShow","ltPropShowTitle","ltPropTitle","ltPropCloseButton","ltPropDraggable","ltPropCloseOnBodyClick","ltPropCloseOnSelection","ltPropAdvancedColorButton","ltPropAppearance","ltPropColorPreview","ltPropStandardColors","ltPropUsedColors","ltPropBasicColorPicker","ltPropSelectedColor","ltPropOriginElement","ltPropWrapperClass","moreColorOptionSelected","ltPropCurrentRgbCode","ltPropBoundry","ltPropScrollable","ltPropNoFillButton","ltPropNoFillLabel","ltPropPaletteLabel","ltPropInline","ltPropColorFormats","availableColors","usedColors","standardColorArray","polygonPoints","noFillPath","moreColorsPath","currentHue","currentBrightness","currentSaturation","paletteSize","circleOffsetSize","circleOffsetBecauseOfWinWidget","posdivElPalette","dragStatus","paletteMaxX","paletteMaxY","okToSelect","clickOnPaletteInProgress","component","hueStatus","poxYHue","poxXHue","dropButtonValue","basicDimensions","advCPDimensions","changedColor"],
	data : function(){
		return {
			//Component Variables
			"ltPropShow" : Lyte.attr("boolean",{"default" : false}),
			"ltPropShowTitle" : Lyte.attr("boolean",{"default" : true}),
			"ltPropTitle" : Lyte.attr("string",{"default" : ""}),
			"ltPropCloseButton" : Lyte.attr("boolean",{"default" : true}),
			"ltPropDraggable" : Lyte.attr("boolean",{"default" : false}),
			"ltPropCloseOnBodyClick" : Lyte.attr("boolean",{"default" : true}),
			"ltPropCloseOnSelection" : Lyte.attr("boolean",{"default" : false}),
			"ltPropAdvancedColorButton" : Lyte.attr("boolean",{"default" : true}),
			"ltPropAppearance" : Lyte.attr("string",{"default" : "callout"}),
			"ltPropColorPreview" : Lyte.attr("boolean",{"default" : true}),
			"ltPropStandardColors" : Lyte.attr("boolean",{"default" : true}),
			"ltPropUsedColors" : Lyte.attr("boolean",{"default" : true}),
			"ltPropBasicColorPicker" : Lyte.attr("boolean",{"default" : true}),
			"ltPropSelectedColor" : Lyte.attr("object",{"default" : null}),
			"ltPropOriginElement" : Lyte.attr("string",{"default" : ""}),
			"ltPropWrapperClass" : Lyte.attr("string",{"default":"lyteColorPickerPopover"}),
			"moreColorOptionSelected" : Lyte.attr("boolean",{"default" : false}),
			"ltPropCurrentRgbCode" : Lyte.attr("string",{ "default" : "90c3d4"}),
			"ltPropBoundry" : Lyte.attr("object",{"default" : null}),
			"ltPropScrollable":Lyte.attr("boolean",{"default": true}),
			"ltPropNoFillButton":Lyte.attr("boolean",{"default":false}),
			"ltPropNoFillLabel":Lyte.attr("string",{"default":""}),
			"ltPropPaletteLabel": Lyte.attr("string",{"default":""}),
			"ltPropInline" : Lyte.attr("boolean",{"default" : false}),
			"ltPropColorFormats" : Lyte.attr("array",{"default" : ["HEX","RGB","HSV","CMYK"]}),

			//Local variables
			"availableColors" : Lyte.attr("array",{"default" : []}),
			"usedColors" : Lyte.attr("array",{"default" : []}),
			"standardColorArray" : Lyte.attr("array",{"default" : []}),
			"polygonPoints" : Lyte.attr("string",{"default" : "4.4,10.3 3.7,9.6 6.7,6.5 3.6,3.4 4.4,2.7 8.1,6.5"}),
			"noFillPath" : Lyte.attr("string",{"default" : "M8,0C3.6,0,0,3.6,0,8s3.6,8,8,8s8-3.6,8-8S12.4,0,8,0z M8,1c1.8,0,3.3,0.7,4.6,1.7l-9.9,9.9C1.7,11.3,1,9.8,1,8 C1,4.1,4.1,1,8,1z M8,15c-1.8,0-3.3-0.7-4.6-1.7l9.9-9.9C14.3,4.7,15,6.2,15,8C15,11.9,11.9,15,8,15z"}),
			"moreColorsPath" : Lyte.attr("string", {"default" : "M299.7-0.2C128.3-0.2-7,134,0.2,305.2C7.4,476.9,138,577.3,259.7,595.9c88.2,13.4,107.8-45.1,87.3-67.3 c-35.5-38.3-22.6-68.6-7.3-82.5c17.4-15.7,50.3-17.3,77.3-13.8c65.5,8.5,175-40,182.2-144.8C611,116.5,471.1-0.2,299.7-0.2z M118.1,299.7c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1 C168.2,277.3,145.8,299.7,118.1,299.7z M217.6,166.6c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1 c27.7,0,50.1,22.4,50.1,50.1C267.7,144.1,245.2,166.6,217.6,166.6z M384.9,166.9c-27.7,0-50.1-22.4-50.1-50.1 c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1C435,144.4,412.6,166.9,384.9,166.9z M485.2,299.9 c-27.7,0-50.1-22.4-50.1-50.1c0-27.7,22.4-50.1,50.1-50.1c27.7,0,50.1,22.4,50.1,50.1C535.2,277.5,512.8,299.9,485.2,299.9z"}),
			

			//AdvColorPicker Local Variables
			"currentHue" : Lyte.attr("number",{ "default" : 0}),
			"currentBrightness" : Lyte.attr("number",{ "default" : 100}),
			"currentSaturation" : Lyte.attr("number",{ "default" : 100}),
			"paletteSize" : Lyte.attr("object",{ "default" : {'height':256,'width':320}}),
			"circleOffsetSize" : Lyte.attr("number",{ "default" : 6}),
			"circleOffsetBecauseOfWinWidget" : Lyte.attr("number",{ "default" : 0}),
			"posdivElPalette" : Lyte.attr("object",{ "default" : {}}),
			"dragStatus" : Lyte.attr("number",{ "default" : 0}),
			"paletteMaxX" : Lyte.attr("number",{ "default" : 0}),
			"paletteMaxY" : Lyte.attr("number",{ "default" : 0}),
			"okToSelect" : Lyte.attr("boolean",{ "default" : true}),
			"clickOnPaletteInProgress" : Lyte.attr("boolean",{ "default" : false}),
			"component" : Lyte.attr("object",{"default" : null}),
			"hueStatus" : Lyte.attr("number",{ "default" : 0}),
			"poxYHue" : Lyte.attr("number", { "default" : 0}),
			"poxXHue" : Lyte.attr("number", { "default" : 0}),
			"dropButtonValue" : Lyte.attr("string",{"default" : "HEX"}),
			"basicDimensions" : Lyte.attr("object",{"default" : {"width" : 252,"height" : 568}}),
			"advCPDimensions" : Lyte.attr("object",{"default" : {"width" : 322,"height" : 393}}),
			"changedColor" : Lyte.attr("object")
		}		
	},
	init : function(){
		var availableColors = [['rgb(255, 255, 255)', 'rgb(239, 22, 22)', 'rgb(239, 130, 22)', 'rgb(239, 177, 22)', 'rgb(93, 195, 90)', 'rgb(56, 215, 187)', 'rgb(22, 208, 239)', 'rgb(57, 142, 243)', 'rgb(197, 22, 239)', 'rgb(239, 22, 111)'],
								['rgb(230, 230, 230)', 'rgb(253, 232, 232)', 'rgb(253, 243, 232)', 'rgb(253, 247, 232)', 'rgb(239, 249, 239)', 'rgb(235, 251, 248)', 'rgb(232, 250, 253)', 'rgb(235, 244, 254)', 'rgb(249, 232, 253)', 'rgb(253, 232, 241)'],
								['rgb(204, 204, 204)', 'rgb(252, 208, 208)', 'rgb(252, 230, 208)', 'rgb(252, 239, 208)', 'rgb(223, 243, 222)', 'rgb(215, 247, 241)', 'rgb(208, 246, 252)', 'rgb(215, 232, 253)', 'rgb(243, 208, 252)', 'rgb(252, 208, 226)'],
								['rgb(153, 153, 153)', 'rgb(249, 162, 162)', 'rgb(249, 205, 162)', 'rgb(249, 224, 162)', 'rgb(190, 231, 189)', 'rgb(175, 239, 228)', 'rgb(162, 236, 249)', 'rgb(176, 210, 250)', 'rgb(232, 162, 249)', 'rgb(249, 162, 197)'],
								['rgb(102, 102, 102)', 'rgb(245, 115, 115)', 'rgb(245, 180, 115)', 'rgb(245, 208, 115)', 'rgb(158, 219, 156)', 'rgb(136, 231, 214)', 'rgb(115, 227, 245)', 'rgb(136, 187, 248)', 'rgb(220, 115, 245)', 'rgb(245, 115, 169)'],
								['rgb(51, 51, 51)', 'rgb(242, 69, 69)', 'rgb(242, 155, 69)', 'rgb(242, 193, 69)', 'rgb(125, 207, 123)', 'rgb(96, 223, 201)', 'rgb(69, 217, 242)', 'rgb(97, 165, 245)', 'rgb(209, 69, 242)', 'rgb(242, 69, 140)'],
								['rgb(25, 25, 25)', 'rgb(171, 12, 12)', 'rgb(171, 91, 12)', 'rgb(171, 125, 12)', 'rgb(56, 146, 53)', 'rgb(32, 158, 136)', 'rgb(12, 148, 171)', 'rgb(12, 97, 198)', 'rgb(140, 12, 171)', 'rgb(171, 12, 77)'],
								['rgb(0, 0, 0)', 'rgb(73, 5, 5)', 'rgb(73, 39, 5)', 'rgb(73, 54, 5)', 'rgb(24, 63, 23)', 'rgb(14, 68, 58)', 'rgb(5, 64, 73)', 'rgb(5, 42, 85)', 'rgb(60, 5, 73)', 'rgb(73, 5, 33)']];
		var standardColorArray = ['rgb(192, 0, 0)','rgb(255, 0, 0)','rgb(255, 192, 0)','rgb(255, 255, 0)','rgb(146, 208, 80)','rgb(0, 176, 80)','rgb(0, 176, 240)','rgb(0, 112, 192)','rgb(0, 32, 96)','rgb(112, 48, 160)'];
		this.setData('availableColors', availableColors);
		this.setData('standardColorArray', standardColorArray);
	},
	
	showColorPicker : function(){
		// debugger
		if(!this.getData('ltPropTitle')){
			this.setData('ltPropTitle',_lyteUiUtils.i18n("Choose.Color"));
		}
		if(!this.getData('ltPropNoFillLabel')){
			this.setData('ltPropNoFillLabel',_lyteUiUtils.i18n("No.Fill"));
		}
		if(!this.getData('ltPropPaletteLabel')){
			this.setData('ltPropPaletteLabel',_lyteUiUtils.i18n("Theme.Colors"));
		}
		if(this.getData('ltPropInline')){
			this.$node.style.display = "block";
			var div = this.$node.querySelector('.lyteColorPicker');
			if(this.getData('ltPropBasicColorPicker')){
				if(this.getData('ltPropColorFormats').length > 0){
					this.setData('dropButtonValue' , this.getData('ltPropColorFormats')[0]);
				}
				// div.style.height = this.getData('basicDimensions').height + "px";
				div.style.width = this.getData('basicDimensions').width + "px";
				this.initializeBasicColorPicker(event || window.event,this.$node);
			}
			else{
				div.style.width = this.getData('advCPDimensions').width + "px";
				this.initializeAdvColorPicker(event || window.event,this.$node);
			}
		}
		else{
			if(this.getData('ltPropShow')){
				if(this.getData('ltPropColorFormats').length > 0){
					this.setData('dropButtonValue' , this.getData('ltPropColorFormats')[0]);
				}
				this.$node.querySelector('.popColorPicker').ltProp("showCloseButton",false);
				if(this.getData('ltPropBoundry')){
					this.$node.querySelector('.popColorPicker').ltProp("boundry",this.getData('ltPropBoundry'));
				}
				this.$node.querySelector('.popColorPicker').ltProp({
					"originElem" : this.getData("ltPropOriginElement"),
					"wrapperClass" : this.getData("ltPropWrapperClass"),
					"type" : this.getData("ltPropAppearance"),
					"closeOnBodyClick" : false,
					"freeze" : false,
					"scrollable" : this.getData("ltPropScrollable"),
					"draggable" : false,
					"show" : true
				});
				this.executeOnBeforeOpen();
			}
			else{
				var ele = document.querySelector('.'+this.getData('ltPropWrapperClass'));
				if(ele && ele.classList.contains('lyteColorpickerVisible')){
					ele.classList.remove('lyteColorpickerVisible');
				}
				this.$node.querySelector('.popColorPicker').ltProp('show',false);
			}
		}
		this.setData('component',this);
	}.observes('ltPropShow').on('didConnect'),

	setColorPreviewAndValue : function(ele,color){
		if(color == "transparent"){
			ele.querySelector('.lyteColorPicker__dynamiccolor').style.backgroundImage = "url('/bower_components/ui-components/components/images/transparent.png')";
		}
		else{
			ele.querySelector('.lyteColorPicker__dynamiccolor').style.backgroundImage = "none";
		}
		ele.querySelector('.lyteColorPicker__dynamiccolor').style.backgroundColor = color;
		ele.querySelector('#readColorValue').value = color;
	},

	initializeAdvColorPicker : function(event,ele){
		var imageObj = ele.querySelector('#lyteCPImgDiv')
		var divElPalette = ele.querySelector('#colorDiv');
		var divElPaletteCircle = ele.querySelector('.colorSlider_palette_circle');
        ele.querySelector('.selectFormat .lyteDummyEventContainer').style.minWidth = "90px";
		
		//Adding Events to the elements
		if(!ColorPicker_EventUtil.__eventBound){
			document.addEventListener('mousemove',function(event){
				ColorPicker_EventUtil.__moveOnPalette(event,ColorPicker_Util.component);
			});
			document.addEventListener('mousemove',function(event){
				ColorPicker_EventUtil.__moveOnHueBar(event,ColorPicker_Util.component);
			});
			document.addEventListener('mouseup',function(event){
				ColorPicker_EventUtil.__endDrag(event,ColorPicker_Util.component);
			});
	        ColorPicker_EventUtil.__eventBound = true;
		}
		ele.querySelector('.colorSlider_hue').addEventListener('mousedown', function(event){
			ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
			return ColorPicker_EventUtil.__initHueMove(event,ColorPicker_Util.component /*document.documentElement.querySelector('lyte-colorpicker').component.getData('component')*/);
		});
		divElPalette.addEventListener('mousedown',function(event){
			ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
			return ColorPicker_EventUtil.__initPaletteMove(event,ColorPicker_Util.component /*document.documentElement.querySelector('lyte-colorpicker').component.getData('component')*/);
		});
		ele.querySelector('.colorSlider_hueBar').addEventListener('mousedown', function(event) {
			ColorPicker_Util.component = ColorPicker_Util.getColorPicker(event.target).component;
            ColorPicker_EventUtil.__moveOnHueBar(event,ColorPicker_Util.component);
        });
		this.setRgbColor("#"+this.getData("ltPropCurrentRgbCode"));
		ele = null;
		divElPalette = null;
		divElPaletteCircle = null;
		imageObj = null;
	},

	
	initializeBasicColorPicker : function(event,ele){
		var liELes = ele.querySelectorAll('.default__colors > li');
		for(var v =0; v<liELes.length ; v++){
			liELes[v].style.background = liELes[v].textContent;
		}
		if(this.getData('ltPropStandardColors')){
			liELes = ele.querySelectorAll('.standard__colors > li');
			for(var v =0; v<liELes.length ; v++){
				liELes[v].style.background = liELes[v].textContent;
			}
		}
		if(this.getData('ltPropUsedColors')){
			liELes = ele.querySelectorAll('.used__colors > li');
			for(var v =0; v<liELes.length ; v++){
				liELes[v].style.background = liELes[v].textContent;
			}
		}
		if(this.getData('ltPropColorPreview')){
			if(this.getData('ltPropCurrentRgbCode')){
				var color = ColorPicker_Util.getRgbColorsByRgbCode(this.getData('ltPropCurrentRgbCode'));
				this.setColorPreviewAndValue(ele,"rgb("+color.red+", "+color.green+", "+color.blue+")");
			}
		}
		liELes = null;
	},

	executeOnBeforeOpen : function(){
		if(this.getMethods('onBeforeOpen')){
			this.executeMethod('onBeforeOpen',this);
		}
	},

	executeOnSelect : function(event){
		if(this.getMethods("onSelect")){
			this.executeMethod("onSelect",event,this.getData('ltPropSelectedColor'));	
		}
		if(this.getData('ltPropCloseOnSelection')){
			this.executeOnClose(event);
			this.setData('ltPropShow',false);
		}
	},

	executeOnOpen : function(){
		if(this.getMethods('onOpen')){
			this.executeMethod('onOpen');
		}
	},

	executeOnClose : function(event){
		if(this.getMethods('onClose')){
			this.executeMethod('onClose',event);
		}
	},

	executeOnChange : function(){
		var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(this.getData('ltPropCurrentRgbCode'));
        var selectedColor = {
        	"hex" : "#"+this.getData('ltPropCurrentRgbCode'),
        	"rgb" : "rgb("+rgbColor.red+", "+rgbColor.green+", "+rgbColor.blue+")"
        };
        this.setData("ltPropSelectedColor",selectedColor);
		if(this.getMethods('onChange')){
			this.executeMethod('onChange',event,selectedColor);
		}
	},

	/*----------------- Start of Utility Methods for Color Picker ---------------*/

	setRgbColor : function(rgbColor) {
        var hsv = ColorPicker_Util.getHsvByRgbCode(rgbColor);
        this.setData('currentHue', hsv.hue);
        this.setData('currentBrightness', hsv.brightness * 100);
        this.setData('currentSaturation', hsv.saturation * 100);
        this.__changeViewAfterColorChange();
    },

    __changeViewAfterColorChange : function() {
        this.__setCurrentRgbCode();
        this.__setPaletteBgColor();
        this.__setSliderPos();
        this.__setBgColorPreviewDiv();
        this.__updateRgbInForm();
        /*this.__updateHsvInForm();*/
        this.__setSmallCirclePosition();
    },
	__setCurrentRgbCode : function() {
        this.setData('ltPropCurrentRgbCode', ColorPicker_Util.getRgbCodeByHsv(this.getData('currentHue'), this.getData('currentSaturation') / 100, this.getData('currentBrightness') / 100));
    },

    __setPaletteBgColor : function() {
        try {
        	if(this.getData('ltPropInline')){
        		this.$node.querySelector('#colorDiv').style.backgroundColor = '#' + ColorPicker_Util.getRgbCodeByHsv(this.getData('currentHue'), 1, 1);
        	}
        	else{
            	this.childComp.querySelector('#colorDiv').style.backgroundColor = '#' + ColorPicker_Util.getRgbCodeByHsv(this.getData('currentHue'), 1, 1);
        	}
        } catch (e) {}
    },

    __setSliderPos: function() {
        var leftPos = Math.round(this.getData('paletteSize').height - ((this.getData('currentHue') / 360) * this.getData('paletteSize').height));
        if(this.getData('ltPropInline')){
        	this.$node.querySelector('.colorSlider_sliderHandle').style.left = leftPos - 9 + "px";
        }
        else{
        	this.childComp.querySelector('.colorSlider_sliderHandle').style.left = leftPos - 9 + "px";
        }
    },

    __setSmallCirclePosition : function() {
    	var currentBrightness = this.getData('currentBrightness');
    	var currentSaturation = this.getData('currentSaturation');
    	var paletteSize = this.getData('paletteSize');
    	var circleOffsetSize = this.getData('circleOffsetSize');
    	var divElPaletteCircle = this.getData('ltPropInline') ? this.$node.querySelector('.colorSlider_palette_circle') : this.childComp.querySelector('.colorSlider_palette_circle');
        var leftPos = Math.round(currentSaturation * (paletteSize.width / 100)) - circleOffsetSize;
        var topPos = paletteSize.height - Math.round(currentBrightness * (paletteSize.height / 100)) - circleOffsetSize;
        divElPaletteCircle.style.left = leftPos + 'px';
        divElPaletteCircle.style.top = topPos + 'px';
        divElPaletteCircle.className = divElPaletteCircle.className.replace('colorSlider_palette_circleBlack', '');
        if (currentBrightness > 80) {
            divElPaletteCircle.className = divElPaletteCircle.className + 'colorSlider_palette_circleBlack';
        }
        divElPaletteCircle = null;
    },

    __setTextSelOk : function(okToS) {
        this.setData('okToSelect', okToS);
    },

    __ffHackWinWidget : function() {
    	var ele = this.getData('ltPropInline') ? this.$node : this.childComp;
        if (ele.querySelector('.lyteColorPicker--advanced').parentNode.className && ele.querySelector('.lyteColorPicker--advanced').parentNode.className.indexOf('windowContent') >= 0 && !document.all) {
            this.setData('circleOffsetBecauseOfWinWidget', 0);
        }
    },

    __setBgColorPreviewDiv : function() {
    	if(this.getData('ltPropInline')){
    		this.$node.querySelector('.previewDiv').style.backgroundColor = '#' + this.getData('ltPropCurrentRgbCode');
    	}
    	else{
    		this.childComp.querySelector('.previewDiv').style.backgroundColor = '#' + this.getData('ltPropCurrentRgbCode');
    	}
    },

    __updateRgbInForm : function(){
    	var ele = this.getData('ltPropInline') ? this.$node : this.childComp;
    	var format = ele.querySelector('.selectFormat').querySelector('lyte-dropdown').getData('ltPropSelected');
    	this.setData('dropButtonValue',format);
    	if(format === "HEX"){
    		ele.querySelector('#lyteCPShowValue').component.$node.ltProp("value",("#" + this.getData("ltPropCurrentRgbCode")));
    	}
    	else if(format === "RGB"){
    		var rgbColor = ColorPicker_Util.getRgbColorsByRgbCode(this.getData("ltPropCurrentRgbCode"));
    		ele.querySelector('#lyteCPShowValue').component.$node.ltProp("value",("rgb("+rgbColor.red+","+rgbColor.green+","+rgbColor.blue+")"));
    	}
    	else if(format === "HSV"){
    		var hue = Math.round(this.getData('currentHue'));
    		var saturation = Math.round(this.getData('currentSaturation'));
    		var valueBrightness = Math.round(this.getData('currentBrightness'));
    		ele.querySelector('#lyteCPShowValue').component.$node.ltProp("value",("hsv("+hue+"°,"+saturation+"%,"+valueBrightness+"%)"));
    	}
    	else if(format === "CMYK"){
    		var rgbColor = ColorPicker_Util.getRgbColorsByHsv(this.getData('currentHue'), this.getData('currentSaturation') / 100, this.getData('currentBrightness') / 100);
    		var cmykColors = ColorPicker_Util.getCmykByRgbColors([rgbColor.red,rgbColor.green,rgbColor.blue]);
    		ele.querySelector('#lyteCPShowValue').component.$node.ltProp("value",("cmyk("+Math.round(cmykColors[0]*100)+"%,"+Math.round(cmykColors[1]*100)+"%,"+Math.round(cmykColors[2]*100)+"%,"+Math.round(cmykColors[3]*100)+"%)"));
    	}
    },

	/*----------------- End of Utility Methods for Color Picker ---------------*/

	methods : {
		closePopColorPicker : function(){
			this.executeOnClose();
			if(this.getData('moreColorOptionSelected')){
				this.setData('moreColorOptionSelected',false);
			}
			this.setData('ltPropShow',false);
		},
		showColorPickerPopover : function(){
			// debugger
			this.childComp = this.$node.querySelector('lyte-popover').component.childComp;
			var ele = document.querySelector('.'+this.getData('ltPropWrapperClass'));
			ele.classList.add('lyteColorpickerVisible');

			//Check the used colors are properly rendered
			if(this.getData('ltPropUsedColors') && (ele.querySelectorAll('.used__colors > li').length < this.getData('usedColors').length)){
				this.setData('ltPropBasicColorPicker',false);
				this.setData('ltPropBasicColorPicker',true);
			}
			//Sometimes the content is not properly rendered when the 
			var headerHeight = ele.querySelector('lyte-popover-header') ? ele.querySelector('lyte-popover-header').getBoundingClientRect().height : 0;
			var contentHeight = this.getData('ltPropBasicColorPicker') ? ele.querySelector('.lyteColorPicker__default').getBoundingClientRect().height : ele.querySelector('.lyteColorPicker--advanced').getBoundingClientRect().height;
			if(this.getData('ltPropBasicColorPicker')){
				ele.querySelector('lyte-popover-content').style.height = contentHeight + "px";
				ele.querySelector('lyte-popover-content').style.maxHeight = contentHeight + "px";
				ele.querySelector('.lytePopover').style.height = (headerHeight + contentHeight + 2) + "px";
				this.initializeBasicColorPicker(event,ele);	
			}
			else{
				ele.querySelector('lyte-popover-content').style.height = contentHeight + "px";
				ele.querySelector('lyte-popover-content').style.maxHeight = contentHeight + "px";
				ele.querySelector('.lytePopover').style.height = (headerHeight + contentHeight + 2) + "px";
				this.initializeAdvColorPicker(event,ele);
			}
			if(this.getData('ltPropDraggable')){
				var drag = ele.querySelector('.lytePopover');
				var handle = ele.querySelector('lyte-popover-header') || ele.querySelector('lyte-popover-content');
				drag.id = "draggableColor";
				handle.id = "draghandle";
				$L('#draggableColor').draggable({
					handle : ['#draghandle']
				})
			}
			this.$node.querySelector('lyte-popover').component.computeOffsetImpl();
			this.executeOnOpen();
			ele = null;
		},

		changeFormatView : function(e,value){
			if(e.currentTarget.tagName == 'LYTE-DROP-BOX'){
	    		this.__updateRgbInForm();
			}
	    }
	},

	actions : {
		selectColor : function(event,color){
			var ele;
			var node;
			if(this.getData('ltPropInline')){
				ele = this.$node.querySelector('.lyteColorPicker');
				node = ele.querySelector('.lyteCPSelectedColor');
			}
			else{
				ele = document.querySelector('.'+this.getData('ltPropWrapperClass'));
				node = ele.querySelector('.lyteCPSelectedColor');
			}
			if(node){
				node.classList.remove('lyteCPSelectedColor');
			}
			event.target.classList.add('lyteCPSelectedColor');
			var colors = this.getData('usedColors');
			if(colors.indexOf(color) != -1){
				colors.splice(colors.indexOf(color), 1);
			}
			colors.push(color);
			this.setData('usedColors',colors);
			if(this.getData('ltPropColorPreview')){
				this.setColorPreviewAndValue(ele,color);
			}
			var rgbColor = color.substring(4,color.length-1).split(",");
			var selectedColor = {
				"hex" : ("#" + ColorPicker_Util.getRgbCodeByRgbColors(rgbColor[0],rgbColor[1],rgbColor[2])),
				"rgb" : color
			};
			this.setData('ltPropCurrentRgbCode',selectedColor.hex.substring(1));
			this.setData('ltPropSelectedColor',selectedColor);
			this.executeOnSelect(event);
		},

		goToAdvancedCP : function(event){
			var ele;
			var color = this.getData('ltPropSelectedColor');
			if(color != null){
				this.setData("ltPropCurrentRgbCode",color.hex ? color.hex.substring(1) : "FF0000");
			}
			this.setData('moreColorOptionSelected',true);
			var advCPDimensions = this.getData('advCPDimensions');
			if(this.getData('ltPropInline')){
				ele = this.$node.querySelector('.lyteColorPicker');
				ele.style.width = advCPDimensions.width + "px";
				this.setData('ltPropBasicColorPicker',false);
			}
			else{
				ele = document.querySelector('.'+this.getData('ltPropWrapperClass'));
				var popOver = ele.querySelector('.lytePopover');
				var popOverOffset = popOver.getBoundingClientRect();
				var headerHeight = popOver.querySelector('lyte-popover-header') ? popOver.querySelector('lyte-popover-header').getBoundingClientRect() : {};
				var height;
				var usedColorsHeight;
				if(this.getData('ltPropUsedColors')){
					usedColorsHeight = popOver.querySelector('.usedColor__container').getBoundingClientRect().height;
					height = popOverOffset.height - usedColorsHeight;
					usedColorsHeight -= popOver.querySelector('.lyteColorPicker__palette').getBoundingClientRect().height;
				}
				else{
					height = popOverOffset.height;
				}
				this.setData('basicDimensions',{"width" : popOverOffset.width, "height" : height, "usedColorsHeight" : usedColorsHeight});
				
				if(popOver.querySelector('lyte-popover-header')){
					popOver.style.height = (advCPDimensions.height + headerHeight.height) + "px";
				}else{
					popOver.style.height = advCPDimensions.height + "px";
				}
				popOver.style.width = advCPDimensions.width + "px";
				popOver.style.maxWidth = advCPDimensions.width + "px";
				popOver.querySelector('lyte-popover-content').style.height = advCPDimensions.height + "px";
				popOver.querySelector('lyte-popover-content').style.maxHeight = advCPDimensions.height + "px";
				this.setData('ltPropBasicColorPicker',false);
				// this.setData('ltPropShow',true);
				this.$node.querySelector('lyte-popover').component.computeOffsetImpl();
				popOverOffset = null;
				headerHeight = null;
				height = null;
				usedColorsHeight = null;
				popOver = null;
			}
			
			this.initializeAdvColorPicker(event,ele);
			ele = null;
			color = null;
			advCPDimensions = null;
		},

		noFillExecute : function(event){
			var color = 'transparent';
			if(this.getData('ltPropColorPreview')){
				this.setColorPreviewAndValue(document.querySelector('.'+this.getData('ltPropWrapperClass')),color);
			}
			var selectedColor = {
				"hex" : undefined,
				"rgb" : color
			};
			this.setData('ltPropSelectedColor',selectedColor);
			this.executeOnSelect(event);
		},

		defaultColorExecute : function(event){
			var color = 'rgb(0, 0, 0)';
			if(this.getData('ltPropColorPreview')){
				this.setColorPreviewAndValue(document.querySelector('.'+this.getData('ltPropWrapperClass')),color);
			}
			var rgbColor = color.substring(4,color.length-1).split(",");
			var selectedColor = {
				"hex" : ("#" + ColorPicker_Util.getRgbCodeByRgbColors(rgbColor[0],rgbColor[1],rgbColor[2])),
				"rgb" : color
			};
			this.setData('ltPropSelectedColor',selectedColor);
			this.executeOnSelect(event);
		},

		closeColorPicker : function(event){
			this.executeOnClose(event);
			this.setData('ltPropShow',false);
		},

		fromAdvCPtoBasic : function(event){
			this.setData('moreColorOptionSelected',false);
			var ele;
			var basicDimensions = this.getData('basicDimensions');
			if(this.getData('ltPropInline')){
				ele = this.$node.querySelector('.lyteColorPicker');
				ele.style.width = basicDimensions.width + "px";
				this.setData('ltPropBasicColorPicker',true);
			}
			else{
				ele = document.querySelector('.'+this.getData('ltPropWrapperClass'));
				var popOver = ele.querySelector('.lytePopover');
				var content = popOver.querySelector('lyte-popover-content');
				var contentHeight = 0;
				var height = 0;
				if(this.getData('ltPropUsedColors')){
					height = basicDimensions.usedColorsHeight + Math.ceil(this.getData('usedColors').length/10) * 22;
					contentHeight = (basicDimensions.height+height) - (popOver.querySelector('lyte-popover-header') ? popOver.querySelector('lyte-popover-header').getBoundingClientRect().height : 0);
				}
				else{
					contentHeight = basicDimensions.height - (popOver.querySelector('lyte-popover-header') ? popOver.querySelector('lyte-popover-header').getBoundingClientRect().height : 0);
				}
				popOver.style.height = (basicDimensions.height + height) + "px";
				content.style.height = contentHeight + "px";
				content.style.maxHeight = contentHeight + "px";
				popOver.style.width = basicDimensions.width + "px";
				popOver.style.maxWidth = basicDimensions.width + "px";
				this.setData('ltPropBasicColorPicker',true);
				this.$node.querySelector('lyte-popover').component.computeOffsetImpl();
			}
			this.initializeBasicColorPicker(event,ele);
			popOver = null;
		},
		copyValueToClipboard : function(prop){
			var ele = this.getData('ltPropInline') ? this.$node : this.childComp;
			if(prop == "fromAdv"){
				ele.querySelector('.previewDiv').querySelector('#copyColorValueImg').style.display = "none";
				var copyColorValue = ele.querySelector('#lyteCPShowValue').querySelector('input');
			}
			if(prop == "fromBasic"){
				var copyColorValue = ele.querySelector('#readColorValue');
			}
			copyColorValue.select();
			try {
				var successful = document.execCommand('copy');
			} catch (err) {
				// console.log('Oops, unable to copy');
			}
		},

		onOverColorPreviewDiv : function(event, type, prop){
			var ele = this.getData('ltPropInline') ? this.$node : this.childComp;
			if(type === "fromAdv"){
				if(prop === "over"){
					ele.querySelector('.previewDiv').querySelector('#copyColorValueImg').style.display = "block";
				}
				if(prop === "out"){
					ele.querySelector('.previewDiv').querySelector('#copyColorValueImg').style.display = "none";
				}
			}
			var node;
			if(this.getData('ltPropInline')){
				node = this.$node.querySelector('#basciPreviewDivImg');
			}
			else{
				node = this.$node.querySelector('lyte-popover').component.childComp.querySelector('#basciPreviewDivImg');
			}
			if(type === "fromBasic"){
				if(prop === "over"){
					node.style.display = "block";
				}
				if(prop === "out"){
					node.style.display = "none";
				}
			}
		}
	}
});

document.addEventListener('click',function(event){
	if(ColorPicker_EventUtil.__stopPropagation){
		ColorPicker_EventUtil.__stopPropagation = false;
		return;
	}
	var ele = event.target;
	while(!$L(ele).hasClass('lyteColorpickerVisible') && ele.tagName != 'LYTE-DROP-BOX' && ele.tagName != 'HTML'){
		ele = ele.parentElement;
		if(!ele){
			return
		}
	}
	if(ele.tagName == 'HTML'){
		var colorpicker = document.querySelector('.lyteColorpickerVisible');
		if(colorpicker && colorpicker.parentElement.parentElement._callee.parentElement.component.getData('ltPropCloseOnBodyClick')){
			colorpicker.parentElement.parentElement._callee.parentElement.ltProp('show',false);
		}
	}
	
},true);


/* NOTES TO SELF ===>
	31-07-2018
	 1. Added ltPropStartDate, ltPropEndDate
 */

Lyte.Component.register("lyte-daterangepicker", {
_template:"<template tag-name=\"lyte-daterangepicker\">\t\t<div class=\"lyteDateRangePickerRow\" onmousedown=\"{{action('mouseDown',event)}}\" onmouseover=\"{{action('mouseOver',event)}}\">\t\t<div class=\"lyteDateRangePickerCol1\">\t\t\t<lyte-calendar nav-yield=\"true\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-max-date=\"{{ltPropMaxDate}}\" lt-prop-min-date=\"{{ltPropMinDate}}\" lt-prop-fill-rows=\"false\" class=\"dRPCalendar1\" on-viewdate-change=\"{{method('viewDateChange','cal1')}}\">\t\t\t\t<template is=\"registerYield\" yield-name=\"navigator\">\t\t\t\t\t<div class=\"lyteDateRPLeftNav\">\t\t\t\t\t\t<span case=\"true\" class=\"lyteCalNav lyteCalyearNavLft\" onclick=\"{{action('previous','Y',event)}}\"></span>\t\t\t        \t<span class=\"lyteCalNav lyteCaldLft\" onclick=\"{{action('previous','M',event)}}\"></span>\t\t\t\t\t</div>\t\t\t\t\t<div class=\"lyteDateRPMonthHeader\">\t\t\t\t\t\t\t\t\t\t\t\t\t<lyte-dropdown class=\"monthDD\" lt-prop-options=\"{{monthNames}}\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method('optionSelected','cal1','M')}}\"></lyte-dropdown>\t\t\t\t\t\t\t<lyte-dropdown class=\"yearDD\" lt-prop-options=\"{{years}}\" lt-prop-tabindex=\"2\" on-option-selected=\"{{method('optionSelected','cal1','Y')}}\"></lyte-dropdown>\t\t\t\t\t\t\t\t\t        </div>\t\t\t\t</template>\t\t\t</lyte-calendar>\t\t</div>\t\t<div class=\"lyteDateRangePickerCol2\">\t\t\t<lyte-calendar nav-yield=\"true\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-max-date=\"{{ltPropMaxDate}}\" lt-prop-min-date=\"{{ltPropMinDate}}\" lt-prop-fill-rows=\"false\" class=\"dRPCalendar2\" select-date=\"false\" on-viewdate-change=\"{{method('viewDateChange','cal2')}}\">\t\t\t\t<template is=\"registerYield\" yield-name=\"navigator\">\t\t\t\t\t<div class=\"lyteDateRPMonthHeader\">\t\t\t\t\t\t\t\t\t\t\t\t\t<lyte-dropdown class=\"monthDD\" lt-prop-options=\"{{monthNames}}\" lt-prop-tabindex=\"1\" on-option-selected=\"{{method('optionSelected','cal2','M')}}\"></lyte-dropdown>\t\t\t\t\t\t\t<lyte-dropdown class=\"yearDD\" lt-prop-options=\"{{years}}\" lt-prop-tabindex=\"2\" on-option-selected=\"{{method('optionSelected','cal2','Y')}}\"></lyte-dropdown>\t\t\t\t\t\t\t\t            </div>\t\t            <div class=\"lyteDateRPRightNav\">\t\t\t            <span case=\"true\" class=\"lyteCalNav lyteCaldRgt\" onclick=\"{{action('next','M',event)}}\"></span>\t\t\t            <span class=\"lyteCalNav lyteCalyearNavRgt\" onclick=\"{{action('next','Y',event)}}\"></span>\t\t\t        </div>\t\t\t\t</template>\t\t\t</lyte-calendar>\t\t</div>\t</div></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"registerYield","position":[1,1,1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[3,1]},{"type":"componentDynamic","position":[3,1]},{"type":"attr","position":[3,3]},{"type":"componentDynamic","position":[3,3]}]},{"type":"componentDynamic","position":[1,1,1]},{"type":"attr","position":[1,3,1]},{"type":"registerYield","position":[1,3,1,1],"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"componentDynamic","position":[1,3]},{"type":"attr","position":[3,1]},{"type":"attr","position":[3,3]}]},{"type":"componentDynamic","position":[1,3,1]}],
_observedAttributes :["monthHeader1","monthHeader2","ltPropCurrentDate","ltPropFormat","ltPropMonthHeaderFormat","shortMonthNames","longMonthNames","ltPropStartYear","ltPropEndYear","ltPropStartDate","ltPropEndDate","years","dateSelected","selectedDate1","selectedDate2","calViewDate1","calViewDate2","tempDate","monthNames","dateNode1","dateNode2","clickCount","ltPropDisabledDates","convertedDates","convert","ltPropMinDate","ltPropMaxDate","internallyChanged"],
    data : function(){
		return {
			"monthHeader1" : Lyte.attr("string",{"default":"Initializing.."}),
			"monthHeader2" : Lyte.attr("string",{"default":"Initializing.."}),
			"ltPropCurrentDate" : Lyte.attr("string",{"default":''}),
			"ltPropFormat" : Lyte.attr("string",{"default":"MM/DD/YYYY"}),
			"ltPropMonthHeaderFormat" : Lyte.attr("string",{"default":"MMM YYYY"}),
			"shortMonthNames": Lyte.attr("array",{"default":['Jan','Feb','Mar','Apr','short.may','Jun','Jul','Aug','Sep','Oct','Nov','Dec']}),
			'longMonthNames': Lyte.attr( 'array', { 
				'default': [
				'January',
				'February',
				'March',
				'April',
				'May',
				'June',
				'July',
				'August',
				'September',
				'October',
				'November',
				'December' 
				]
			} ),
			"ltPropStartYear" : Lyte.attr("number",{"default":1900}),
			"ltPropEndYear" : Lyte.attr("number",{"default":2100}),
			"ltPropStartDate" : Lyte.attr("string",{"default":""}),
			"ltPropEndDate" : Lyte.attr("string",{"default":""}),
			"years" : Lyte.attr("array",{"default":[]}),
			"dateSelected" : Lyte.attr("boolean",{"default" : false}),
			"selectedDate1" : Lyte.attr("string"),
			"selectedDate2" : Lyte.attr("string"),
			"calViewDate1" : Lyte.attr("object"),
			"calViewDate2" : Lyte.attr("object"),
			"tempDate" : Lyte.attr("string"),
			"monthNames" : Lyte.attr("array"),
			"dateNode1" : Lyte.attr("object"),
			"dateNode2" : Lyte.attr("object"),
			"clickCount" : Lyte.attr("number",{"default" : 0}),
			"ltPropDisabledDates" : Lyte.attr("array",{"default" : []}),
			"convertedDates" : Lyte.attr("array",{"default" : []}),
			"convert" : Lyte.attr("number",{"default" : 0}),
			"ltPropMinDate" : Lyte.attr("string",{"default" : ""}),
			"ltPropMaxDate" : Lyte.attr("string",{"default" : ""}),
			"internallyChanged" : Lyte.attr("boolean",{"default" : false})
		}		
	},
	initFunc : function(){
		var year = [];
		for(var i = this.getData("ltPropStartYear");i<=this.getData("ltPropEndYear");i++){
			year.push(i);
		}
		this.setData("years",year);
		var monthNames = [];
		// localeMonthString = [];
		if(this.getData('ltPropMonthHeaderFormat') === 'MMMM YYYY'){
			for(var i = 0; i<12; i++){
				// localeMonthString.push(_lyteUiUtils.i18n(this.getData('longMonthNames')[i]));
				monthNames.push(_lyteUiUtils.i18n(this.getData('longMonthNames')[i]));
			}
		}
		else{
			for(var i = 0; i<12; i++){
				// localeMonthString.push(_lyteUiUtils.i18n(this.getData('shortMonthNames')[i]));
				monthNames.push(_lyteUiUtils.i18n(this.getData('shortMonthNames')[i]));
			}
		}
		this.setData('monthNames',monthNames);
	}.observes('ltPropStartYear','ltPropEndYear').on('init'),
	convertDisabledDates : function(){
		// var disabledDates = this.getData('ltPropDisabledDates');
		// var convertedDates = [];
		// for(var i = 0; i<disabledDates.length; i++){
		// 	convertedDates.push(Date.parse(disabledDates[i]));
		// }
		// this.setData('convertedDates',convertedDates);
		if(this.getData('ltPropDisabledDates').length > 0){
			this.checkAndMarkDisabledDates();
		}
	}.observes("ltPropDisabledDates.[]","convert"),
	setMonths : function(){
		var monthNames = [];
		// localeMonthString = "";
		if(this.getData('ltPropMonthHeaderFormat') === 'MMMM YYYY'){
			for(var i = 0; i<12; i++){
				// localeMonthString += _lyteUiUtils.i18n(this.getData('longMonthNames')[i]);
				monthNames.push(_lyteUiUtils.i18n(this.getData('longMonthNames')[i]));
			}
		}
		else{
			for(var i = 0; i<12; i++){
				// localeMonthString += _lyteUiUtils.i18n(this.getData('shortMonthNames')[i]);
				monthNames.push(_lyteUiUtils.i18n(this.getData('shortMonthNames')[i]));
			}
		}
		this.setData('monthNames',monthNames);
	}.observes('ltPropMonthHeaderFormat'),
	didConnectFunc : function(){
		var cal1 = this.$node.querySelector('.dRPCalendar1');
		var cal2 = this.$node.querySelector('.dRPCalendar2');
		var currentDate = new Date();
		var today = this.getData("ltPropCurrentDate") ? new Date(this.getData("ltPropCurrentDate")) : currentDate;
		var dd = today.getDate();
		var mm = today.getMonth(); //January is 0!
		var yy = today.getFullYear();
		this.setMonthAndYear(cal1,{dd:dd,mm:mm,yy:yy},"cal1");
		if(mm < 11){
			mm += 1
		}
		else{
			mm = 0;
			yy += 1;
		}
		this.setMonthAndYear(cal2,{dd:dd,mm:mm,yy:yy});
		var selected = this.$node.querySelector('.lyteCalSel');
		if(selected){
			var selectedDate = new Date(selected.dataset.date);
			if(selectedDate.getMonth() === currentDate.getMonth() && selectedDate.getDate() === currentDate.getDate() && selectedDate.getFullYear() === currentDate.getFullYear()){
				selected.classList.remove('lyteCalSel');
				selected.classList.add('lyteCalToday');
			}
		}
		if(this.getData('ltPropDisabledDates').length > 0){
			this.setData('convert',this.getData('convert') + 1);
		}
		if(this.getData('ltPropStartDate') && this.getData('ltPropEndDate')){
			this.setData('selectedDate1',this.getData('ltPropStartDate'));
			this.setData('selectedDate2',this.getData('ltPropEndDate'));
			this.checkForSelectedDates(this.getData('ltPropStartDate'),this.getData('ltPropEndDate'));
		}
	}.observes('ltPropCurrentDate','ltPropMinDate','ltPropMaxDate').on('didConnect'),
	changeStartAndEndDate : function(){
		if(!this.getData('internallyChanged')){
			if(this.getData('ltPropStartDate') === "" || this.getData('ltPropEndDate') === ""){
				this.checkAndRemoveAllSelectedClasses();
				this.removeMonthEndAndStart();
			}
			else if(this.getData('ltPropStartDate') && this.getData('ltPropEndDate')){
				this.setData('selectedDate1',this.getData('ltPropStartDate'));
				this.setData('selectedDate2',this.getData('ltPropEndDate'));
				this.checkForSelectedDates(this.getData('ltPropStartDate'),this.getData('ltPropEndDate'));
			}
		}
		else{
			this.setData('internallyChanged',false);
		}
	}.observes('ltPropStartDate','ltPropEndDate'),
	setMonthAndYear : function(cal,date,view){
		cal.ltProp("currentDate",date.mm+1+'/'+date.dd+'/'+date.yy);
		cal.setData('currentDatechanged',cal.getData('currentDatechanged')+1);
		cal.querySelector('.monthDD').ltProp("selected",this.getData("monthNames")[date.mm]);
		cal.querySelector('.yearDD').ltProp("selected",""+date.yy);
		if(view == "cal1"){
			this.setData('calViewDate1',cal.getData('viewDate'));
		}
		else{
			this.setData('calViewDate2',cal.getData('viewDate'));
		}
	},
	selectDates : function(targetDate){
		var nodes = this.$node.querySelectorAll('.lyteCalCdate:not(.lyteCalGray)');
		var initNode = this.getData('dateNode1');
		var target = this.getData('dateNode2');
		var date1 = Date.parse(this.getData('selectedDate1'));
		var date2 = Date.parse(targetDate);
		var node1 = this.$node.querySelector('.lyteDateRPTempFirstDateSelected');
		var node2 = this.$node.querySelector('.lyteDateRPTempLastDateSelected');
		if(node1){
			node1.classList.remove('lyteDateRPTempFirstDateSelected');
		}
		if(node2){
			node2.classList.remove('lyteDateRPTempLastDateSelected');
		}
		this.removeMonthEndAndStart();
		if( date1 < date2){
			for(var i = 0; i<nodes.length; i++){
				var date = Date.parse(nodes[i].dataset.date);
				if(date >= date1 && date <= date2){
					if(nodes[i].classList.contains("lyteCalDisabled")){
						this.checkForBeforeAndAfter(nodes,i,date1,date2);
					}
					else{
						if(date == date1){
							initNode.classList.add('lyteDateRPTempFirstDateSelected');
						}
						else if(date == date2){
							target.classList.add('lyteDateRPTempLastDateSelected');
						}
						else{
							if(!nodes[i].classList.contains("lyteDateRPTempSelected")){
								nodes[i].classList.add("lyteDateRPTempSelected");
							}
						}
						this.checkForMonthEndAndStart(nodes,i,this.getData('selectedDate1'),targetDate);
					}
				}
				else{
					if(nodes[i].classList.contains("lyteDateRPTempSelected") || nodes[i].classList.contains("lyteCalSel")){
						nodes[i].classList.remove("lyteDateRPTempSelected",'lyteCalSel');
					}
				}
			}
		}
		else if(date1 > date2){
			for(var i = 0; i<nodes.length; i++){
				var date = Date.parse(nodes[i].dataset.date);
				if(date >= date2 && date <= date1){
					if(nodes[i].classList.contains("lyteCalDisabled")){
						this.checkForBeforeAndAfter(nodes,i,date2,date1);
					}
					else{
						if(date == date2){
							target.classList.add('lyteDateRPTempFirstDateSelected');
						}
						else if(date == date1){
							initNode.classList.add('lyteDateRPTempLastDateSelected');
						}
						else{
							if(!nodes[i].classList.contains("lyteDateRPTempSelected")){
								nodes[i].classList.add("lyteDateRPTempSelected");
							}
						}
						this.checkForMonthEndAndStart(nodes,i,targetDate,this.getData('selectedDate1'));
					}
				}
				else{
					if(nodes[i].classList.contains("lyteDateRPTempSelected") || nodes[i].classList.contains("lyteCalSel")){
						nodes[i].classList.remove("lyteDateRPTempSelected","lyteCalSel");
					}
				}
			}
		}
		else{
			this.checkAndRemoveAllSelectedClasses();
			this.setData('selectedDate1',targetDate)
			target.classList.add('lyteDateRPTempFirstDateSelected','lyteDateRPTempLastDateSelected');
			this.checkForMonthEndAndStart(nodes,Array.from(nodes).indexOf(target),targetDate,this.getData('selectedDate1'));
		}
		this.setData("tempDate",targetDate);
		
	},
	checkAndMarkDisabledDates : function(){
		var nodes = this.$node.querySelectorAll('.lyteCalCdate:not(.lyteCalGray)');
		if(nodes.length == 0){
			return
		}
		var date;
		for(var j=0; j<nodes.length; j++){
			date = nodes[j].dataset.date;
			if(this.checkForDisabledDates(date)){
				nodes[j].classList.add("lyteCalDisabled");
			}
		}
	},
	checkForDisabledDates : function(date){
		var disabledDates = this.getData('ltPropDisabledDates');
		for(var i = 0; i<disabledDates.length; i++){
			if(new RegExp(disabledDates[i]).test(date)){
				return true;
			}
		}
		return false;
	},
	checkForBeforeAndAfter : function(nodes,pos,startDate,endDate){
		if(pos > 0 && pos < nodes.length-1){
			var date1 = Date.parse(nodes[pos-1].dataset.date);
			var date2 = Date.parse(nodes[pos+1].dataset.date);
			if(date1 >= startDate && date1 <= endDate){
				nodes[pos-1].classList.add('lyteDateRPMonthEndDate');
			}
			if(date2 >= startDate && date2 <= endDate){
				nodes[pos+1].classList.add('lyteDateRPMonthStartDate');
			}
		}
	},
	checkAndRemoveAllSelectedClasses : function(){
		var nodes = Array.from(this.$node.querySelectorAll(".lyteDateRPFirstDateSelected"));
		Lyte.arrayUtils(nodes,"push",(Array.from(this.$node.querySelectorAll(".lyteDateRPLastDateSelected"))));
		Lyte.arrayUtils(nodes,"push",(Array.from(this.$node.querySelectorAll(".lyteDateRPTempLastDateSelected"))));
		Lyte.arrayUtils(nodes,"push",(Array.from(this.$node.querySelectorAll(".lyteDateRPTempFirstDateSelected"))));
		Lyte.arrayUtils(nodes,"push",(Array.from(this.$node.querySelectorAll(".lyteDateRPTempSelected"))));
		Lyte.arrayUtils(nodes,"push",(Array.from(this.$node.querySelectorAll(".lyteCalSel"))));
		Lyte.arrayUtils(nodes,"push",(Array.from(this.$node.querySelectorAll(".lyteCalToday"))));
		for(var i=0;i<nodes.length;i++){
			nodes[i].classList.remove("lyteDateRPFirstDateSelected","lyteDateRPTempSelected","lyteDateRPLastDateSelected","lyteDateRPTempFirstDateSelected","lyteDateRPTempLastDateSelected","lyteCalSel","lyteCalToday");
		}
		this.setData("selectedDate1","");
		this.setData("selectedDate2","");
	},
	checkForMonthEndAndStart : function(nodes,pos,startDate,endDate){
		var allNodes = this.$node.querySelectorAll('.lyteCalCdate');
		var lastNode = allNodes[allNodes.length-1];
		if(nodes[pos].innerText === "1" && Date.parse(nodes[pos].dataset.date) >= Date.parse(startDate) &&  Date.parse(nodes[pos].dataset.date) <= Date.parse(endDate)){
			nodes[pos].classList.remove('lyteDateRPTempSelected');
			nodes[pos].classList.add('lyteDateRPMonthStartDate');
		}
		else if((pos + 1 < nodes.length && nodes[pos + 1].innerText === "1" && Date.parse(nodes[pos + 1].dataset.date) >= Date.parse(startDate) &&  Date.parse(nodes[pos].dataset.date) <= Date.parse(endDate)) || (pos == nodes.length - 1 && nodes[pos].isEqualNode(lastNode) && Date.parse(nodes[pos].dataset.date) >= Date.parse(startDate) &&  Date.parse(nodes[pos].dataset.date) <= Date.parse(endDate))){
			nodes[pos].classList.remove('lyteDateRPTempSelected');
			nodes[pos].classList.add('lyteDateRPMonthEndDate');
		}
	},
	removeMonthEndAndStart : function(){
		var nodes = Array.from(this.$node.querySelectorAll('.lyteDateRPMonthStartDate'));
		Lyte.arrayUtils(nodes,"push",(Array.from(this.$node.querySelectorAll(".lyteDateRPMonthEndDate"))));
		for(var i=0;i<nodes.length;i++){
			nodes[i].classList.remove("lyteDateRPMonthStartDate","lyteDateRPMonthEndDate");
		}
	},
	executeSelected : function(event){
		if(this.getMethods('onDateSelected')){
			var date1 = Date.parse(this.getData('selectedDate1'));
			var date2 = Date.parse(this.getData('selectedDate2'));
			if(date1 <= date2){
				this.setData('internallyChanged',true);
				this.setData('ltPropStartDate',this.getData('selectedDate1'));
				this.setData('internallyChanged',true);
				this.setData('ltPropEndDate',this.getData('selectedDate2'));
				this.executeMethod('onDateSelected',event,this.getData('selectedDate1'),this.getData('selectedDate2'),this);
			}
			else{
				this.setData('internallyChanged',true);
				this.setData('ltPropStartDate',this.getData('selectedDate2'));
				this.setData('internallyChanged',true);
				this.setData('ltPropEndDate',this.getData('selectedDate1'));
				this.executeMethod('onDateSelected',event,this.getData('selectedDate2'),this.getData('selectedDate1'),this);
			}
		}
	},
	checkForSelectedDates : function( startDate, endDate){
		var nodes = this.$node.querySelectorAll('.lyteCalCdate:not(.lyteCalGray)');
		if(startDate && endDate){
			var date1 = Date.parse(startDate);
			var date2 = Date.parse(endDate);
			for(var i = 0 ; i<nodes.length ; i++){
				var date = Date.parse(nodes[i].dataset.date);
				if(date >= date1 && date <= date2){
					if(nodes[i].classList.contains('lyteCalDisabled')){
						this.checkForBeforeAndAfter(nodes,i,date1,date2);
					}
					else{
						if(date == date1){
							nodes[i].classList.add('lyteDateRPFirstDateSelected');
						}
						if(date == date2){
							nodes[i].classList.add('lyteDateRPLastDateSelected');
						}
						if(date !== date1 && date !== date2){
							nodes[i].classList.add('lyteDateRPTempSelected');
						}
						this.checkForMonthEndAndStart(nodes,i,startDate,endDate);
					}
				}
			}
		}
		else{
			if(this.getData('ltPropDisabledDates').length > 0){
				this.checkAndMarkDisabledDates();
			}
			var date1 = this.getData("selectedDate1");
			var date2 = this.getData("selectedDate2");
			var date3 = this.getData("tempDate");
			if(date1 && date2){
				// this.removeMonthEndAndStart();
				date1 = Date.parse(date1);
				date2 = Date.parse(date2);
				if(date1 < date2){
					for(var i = 0 ; i<nodes.length ; i++){
						var date = Date.parse(nodes[i].dataset.date);
						if(date >= date1 && date <= date2){
							if(nodes[i].classList.contains('lyteCalDisabled')){
								this.checkForBeforeAndAfter(nodes,i,date1,date2);
							}
							else{
								if(date == date1){
									nodes[i].classList.add('lyteDateRPFirstDateSelected');
								}
								if(date == date2){
									nodes[i].classList.add('lyteDateRPLastDateSelected');
								}
								if(date !== date1 && date !== date2){
									nodes[i].classList.add('lyteDateRPTempSelected');
								}
								this.checkForMonthEndAndStart(nodes,i,this.getData("selectedDate1"),this.getData("selectedDate2"));
							}
						}
					}
				}
				else{
					for(var i = 0 ; i<nodes.length ; i++){
						var date = Date.parse(nodes[i].dataset.date);
						if(date >= date2 && date <= date1){
							if(nodes[i].classList.contains('lyteCalDisabled')){
								this.checkForBeforeAndAfter(nodes,i,date2,date1);
							}
							else{
								if(date == date2){
									nodes[i].classList.add('lyteDateRPFirstDateSelected');
								}
								if(date == date1){
									nodes[i].classList.add('lyteDateRPLastDateSelected');
								}
								if(date !== date1 && date !== date2) {
									nodes[i].classList.add('lyteDateRPTempSelected');
								}
								this.checkForMonthEndAndStart(nodes,i,this.getData("selectedDate2"),this.getData("selectedDate1"));
							}
						}
					}
				}
			}
			else if(date1 && date3){
				date1 = Date.parse(date1);
				date3 = Date.parse(date3);
				if(date1 < date3){
					for(var i = 0 ; i<nodes.length ; i++){
						var date = Date.parse(nodes[i].dataset.date);
						if(nodes[i].classList.contains('lyteCalDisabled')){
							this.checkForBeforeAndAfter(nodes,i,date1,date3);
						}
						else{
							if(date1 <= date3 && date == date1){
								nodes[i].classList.add('lyteDateRPTempFirstDateSelected');
							}
							else if(date == date3){
								nodes[i].classList.add('lyteDateRPTempLastDateSelected');
							}
							else if(date > date1 && date < date3){
								nodes[i].classList.add('lyteDateRPTempSelected');
							}
						}
					}
				}
				else{
					for(var i = 0 ; i<nodes.length ; i++){
						var date = Date.parse(nodes[i].dataset.date);
						if(nodes[i].classList.contains('lyteCalDisabled')){
							this.checkForBeforeAndAfter(nodes,i,date3,date1);
						}
						else{
							if(date3 <= date1 && date == date1){
								nodes[i].classList.add('lyteDateRPTempFirstDateSelected');
							}
							else if(date == date1){
								nodes[i].classList.add('lyteDateRPTempLastDateSelected');
							}
							else if(date >= date2 && date < date1){
								nodes[i].classList.add('lyteDateRPTempSelected');
							}
						}
					}
				}
			}
		}
	},
	callOnNavigate : function(event,fromMonths,toMonths){
		if(this.getMethods('onNavigation')){
			this.executeMethod('onNavigation',event,fromMonths,toMonths);
		}
	},
	actions :{
		previous: function(opt,event){
			var calendar = this.$node.querySelector('.dRPCalendar1');
			var fromMonths = {"date1":this.getData('monthNames')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear(),
								"date2":this.getData('monthNames')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear()};
			calendar.setData('selectDate',false);
			var dd = 1;
			var mm;
			var yy;
			if(opt == 'M'){
				mm = calendar.getData('viewDate').getMonth() - 1;
			}
			else{
				mm = calendar.getData('viewDate').getMonth();
			}
			if(opt == 'Y'){
				yy = calendar.getData('viewDate').getFullYear() - 1;
			}
			else{
				yy = calendar.getData('viewDate').getFullYear();
			}
			if(mm == -1){
				mm = 11;
				yy -= 1;
			}
			if(yy < this.getData("ltPropStartYear")){
				return;
			}
			this.setMonthAndYear(calendar,{dd:dd,mm:mm,yy:yy},"cal1");
			if(mm < 11){
				mm += 1;
			}
			else{
				mm = 0;
				yy += 1;
			}
			this.setMonthAndYear(this.$node.querySelector('.dRPCalendar2'),{dd:dd,mm:mm,yy:yy});
			this.checkForSelectedDates();
			var toMonths = {"date1":this.getData('monthNames')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear(),
								"date2":this.getData('monthNames')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear()};
			this.callOnNavigate(event,fromMonths,toMonths,this);
		},
		next: function(opt,event){
			var calendar = this.$node.querySelector('.dRPCalendar2');
			calendar.setData('selectDate',false);
			var fromMonths = {"date1":this.getData('monthNames')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear(),
								"date2":this.getData('monthNames')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear()};
			var dd = 1;
			var mm;
			var yy;
			if(opt == 'M'){
				mm = calendar.getData('viewDate').getMonth() + 1;
			}
			else{
				mm = calendar.getData('viewDate').getMonth();
			}
			if(opt == 'Y'){
				yy = calendar.getData('viewDate').getFullYear() + 1;
			}
			else{
				yy = calendar.getData('viewDate').getFullYear();
			}
			if(mm == 12){
				mm = 0;
				yy += 1;
			}
			if(yy > this.getData('ltPropEndYear')){
				return;
			}
			this.setMonthAndYear(calendar,{dd:dd,mm:mm,yy:yy});
			if(mm > 0){
				mm -= 1;
			}
			else{
				mm = 11;
				yy -= 1;
			}
			this.$node.querySelector('.dRPCalendar1').setData('selectDate',false);
			this.setMonthAndYear(this.$node.querySelector('.dRPCalendar1'),{dd:dd,mm:mm,yy:yy},"cal1");
			this.checkForSelectedDates();
			var toMonths = {"date1":this.getData('monthNames')[this.getData('calViewDate1').getMonth()] + " " + this.getData('calViewDate1').getFullYear(),
								"date2":this.getData('monthNames')[this.getData('calViewDate2').getMonth()] + " " + this.getData('calViewDate2').getFullYear()};
			this.callOnNavigate(event,fromMonths,toMonths,this);
		},
		mouseDown : function(event){
			var target = event.target;
			while(target.parentElement){
				if(target.classList.contains('lyteCalCdate')){
					break;
				}
				target = target.parentElement;
			}
			if(target.tagName === "HTML"){
				return;
			}
			var clickCount = this.getData('clickCount');
		 	clickCount++;
		 	this.setData('clickCount',clickCount);
		 	var self = this;
		    if (clickCount === 1) {
		        singleClickTimer = setTimeout(function() {
		            clickCount = 0;
		            self.setData('clickCount',clickCount);
		        }, 400);
		    } else if (clickCount === 2) {
		        clearTimeout(singleClickTimer);
		        clickCount = 0;
		        this.setData('clickCount',clickCount);
		        // var target = event.target;
		        if(target.classList.contains("lyteCalCdate")){
					if(!target.classList.contains("lyteCalGray")){
						this.checkAndRemoveAllSelectedClasses();
						this.removeMonthEndAndStart();
						this.setData('dateNode1',target);
						this.setData('dateNode2',target);
						target.classList.add('lyteDateRPFirstDateSelected','lyteDateRPLastDateSelected');
						var nodes = this.$node.querySelectorAll('.lyteCalCdate:not(.lyteCalGray)');
						this.checkForMonthEndAndStart(nodes,Array.from(nodes).indexOf(target),target.dataset.date,target.dataset.date);
						this.setData('selectedDate1',target.dataset.date);
						this.setData('selectedDate2',target.dataset.date);
						this.setData('dateSelected',false);
						this.executeSelected(event);
					}
				}
		        return;
		    }
			
			if(target.classList.contains("lyteCalCdate")){
				if(!target.classList.contains("lyteCalGray")){
					if(!this.getData('dateSelected')){
						if(this.getMethods('firstSelection')){
							this.executeMethod('firstSelection',event,this);
						}
						this.checkAndRemoveAllSelectedClasses();
						this.removeMonthEndAndStart();
						this.setData('dateNode1',target);
						target.classList.add("lyteDateRPTempFirstDateSelected");
						target.classList.add("lyteDateRPTempLastDateSelected");
						var nodes = this.$node.querySelectorAll('.lyteCalCdate:not(.lyteCalGray)');
						this.checkForMonthEndAndStart(nodes,Array.from(nodes).indexOf(target),target.dataset.date,target.dataset.date);
						this.setData('selectedDate1',target.dataset.date);
						this.setData('dateSelected',true);
					}
					else{
						if(this.getMethods('secondSelection')){
							this.executeMethod('secondSelection',event,this);
						}
						if(target.classList.contains('lyteDateRPTempSelected')){
							target.classList.remove('lyteDateRPTempSelected');
						}
						var date1 = Date.parse(this.getData('selectedDate1'));
						var date2 = Date.parse(target.dataset.date);
						if(date1 <= date2){
							this.getData('dateNode1').classList.remove('lyteDateRPTempFirstDateSelected');
							this.getData('dateNode1').classList.add('lyteDateRPFirstDateSelected');
							this.getData('dateNode2').classList.remove('lyteDateRPTempLastDateSelected');
							this.getData('dateNode2').classList.add('lyteDateRPLastDateSelected');
						}
						else{
							this.getData('dateNode1').classList.remove('lyteDateRPTempLastDateSelected');
							this.getData('dateNode1').classList.add('lyteDateRPLastDateSelected');
							this.getData('dateNode2').classList.remove('lyteDateRPTempFirstDateSelected');
							this.getData('dateNode2').classList.add('lyteDateRPFirstDateSelected');
						}
						this.setData('selectedDate2',target.dataset.date);
						this.setData('tempDate',"");
						this.setData('dateSelected',false);
						this.executeSelected(event);
					}
				}
			}
		},
		mouseOver : function(event){
			if(this.getData("dateSelected")){
				var target = event.target;
				while(target.parentElement){
					if(target.classList.contains('lyteCalCdate')){
						break;
					}
					target = target.parentElement;
				}
				if(target.tagName === "HTML"){
					return;
				}
				if(target.classList.contains("lyteCalCdate")){
					if(!target.classList.contains("lyteCalGray")){
						this.setData('dateNode2',target);
						this.selectDates(target.dataset.date);
					}
				}
			}
		}
	},
	methods : {
		optionSelected : function(cal,opt,event,selected,comp){
			if(this.getMethods('ddOptionSelected')){
				this.executeMethod('ddOptionSelected',event,selected,comp,cal,opt);
			}
			if(cal == "cal1"){
				var calendar = this.$node.querySelector('.dRPCalendar1');
				calendar.setData('selectDate',false);
				var dd = 1;
				var mm;
				var yy;
				if(opt == 'M'){
					mm = this.getData('monthNames').indexOf(selected);
				}
				else{
					mm = calendar.getData('viewDate').getMonth();
				}
				if(opt == 'Y'){
					yy = parseInt(selected);
				}
				else{
					yy = calendar.getData('viewDate').getFullYear();
				}
				if(mm > 10 && yy == this.getData('ltPropEndYear')){
					if(selected == 'DEC'){
						calendar.querySelector('.monthDD').ltProp("selected",this.getData("monthNames")[calendar.getData('viewDate').getMonth()]);
					}
					else{
						calendar.querySelector('.yearDD').ltProp("selected",""+calendar.getData('viewDate').getFullYear());
					}
					// console.log("returning "+mm+" "+yy);
					return;
				}
				this.setMonthAndYear(calendar,{dd:dd,mm:mm,yy:yy},"cal1");
				if(mm < 11){
					mm += 1;
				}
				else{
					mm = 0;
					yy += 1;
				}
				this.setMonthAndYear(this.$node.querySelector('.dRPCalendar2'),{dd:dd,mm:mm,yy:yy});
			}
			else if(cal == "cal2"){
				var calendar = this.$node.querySelector('.dRPCalendar2');
				calendar.setData('selectDate',false);
				var dd = 1;
				var mm;
				var yy;
				if(opt == 'M'){
					mm = this.getData('monthNames').indexOf(selected);
				}
				else{
					mm = calendar.getData('viewDate').getMonth();
				}
				if(opt == 'Y'){
					yy = selected;
				}
				else{
					yy = calendar.getData('viewDate').getFullYear();
				}
				if(mm < 1 && yy == this.getData('ltPropStartYear')){
					if(selected == 'JAN'){
						calendar.querySelector('.monthDD').ltProp("selected",this.getData("monthNames")[calendar.getData('viewDate').getMonth()]);
					}
					else{
						calendar.querySelector('.yearDD').ltProp("selected",""+calendar.getData('viewDate').getFullYear());
					}
					// console.log("returning "+mm+" "+yy);
					return;
				}
				this.setMonthAndYear(calendar,{dd:dd,mm:mm,yy:yy});
				if(mm > 0){
					mm -= 1;
				}
				else{
					mm = 11;
					yy -= 1;
				}
				this.$node.querySelector('.dRPCalendar1').setData('selectDate',false);
				this.setMonthAndYear(this.$node.querySelector('.dRPCalendar1'),{dd:dd,mm:mm,yy:yy},"cal1");
			}
			this.checkForSelectedDates();
		},
		viewDateChange : function(cal,comp,viewDate){
			if(cal == "cal1" /*&& this.getData('calViewDate1').toString() != viewDate.toString()*/){
				var dd = 1;
				var mm = viewDate.getMonth();
				var yy = viewDate.getFullYear();
				comp.$node.querySelector('.monthDD').ltProp("selected",this.getData("monthNames")[mm]);
				comp.$node.querySelector('.yearDD').ltProp("selected",""+yy);
				// if(mm < 11){
				// 	mm += 1;
				// }
				// else{
				// 	mm = 0;
				// 	yy += 1;
				// }
				// this.setMonthAndYear(this.$node.querySelector('.dRPCalendar2'),{dd:dd,mm:mm,yy:yy});
			}
			else if(cal == "cal2"/* && this.getData('calViewDate2').toString() != viewDate.toString()*/){
				var dd = 1;
				var mm = viewDate.getMonth();
				var yy = viewDate.getFullYear();
				comp.$node.querySelector('.monthDD').ltProp("selected",this.getData("monthNames")[mm]);
				comp.$node.querySelector('.yearDD').ltProp("selected",""+yy);
				// if(mm > 0){
				// 	mm -= 1;
				// }
				// else{
				// 	mm = 11;
				// 	yy -= 1;
				// }
				// this.setMonthAndYear(this.$node.querySelector('.dRPCalendar1'),{dd:dd,mm:mm,yy:yy});
			}
		}
	}
});

Lyte.Component.register("lyte-dateselect", {
_template:"<template tag-name=\"lyte-dateselect\">\t<lyte-popover lt-prop-show=\"{{lbind(ltPropShow)}}\" lt-prop-type=\"{{ltPropType}}\" lt-prop-freeze=\"{{ltPropFreeze}}\" lt-prop-show-close-button=\"{{ltPropShowCloseButton}}\" lt-prop-close-on-escape=\"{{ltPropCloseOnEscape}}\" lt-prop-origin-elem=\"{{ltPropOriginElem}}\" lt-prop-placement=\"{{ltPropPlacement}}\" lt-prop-scrollable=\"{{ltPropScrollable}}\" lt-prop-draggable=\"{{ltPropDraggable}}\" lt-prop-allow-multiple=\"{{ltPropAllowMultiple}}\" lt-prop-max-height=\"{{ltPropMaxHeight}}\" lt-prop-max-width=\"{{ltPropMaxWidth}}\" lt-prop-width=\"{{ltPropWidth}}\" lt-prop-height=\"{{ltPropHeight}}\" lt-prop-wrapper-class=\"{{concat(ltPropWrapperClass, if(showOpen, 'lyteDateSelectWrapper opened', 'lyteDateSelectWrapper'))}}\" lt-prop-boundry=\"{{ltPropBoundry}}\" lt-prop-duration=\"{{ltPropDuration}}\" lt-prop-offset=\"{{ltPropOffset}}\" lt-prop-bind-to-body=\"{{ltPropBindToBody}}\" lt-prop-content-padding=\"{{ltPropContentPadding}}\" lt-prop-dimmer=\"{{ltPropDimmer}}\" on-before-show=\"{{method( 'beforeShow' )}}\" on-show=\"{{method( 'show' )}}\" on-before-close=\"{{method( 'beforeClose' )}}\" on-close=\"{{method( 'close' )}}\" on-resize=\"{{method( 'resize' )}}\" on-scroll=\"{{method( 'scroll' )}}\"> \t\t<template is=\"registerYield\" yield-name=\"popover\">\t\t\t<template is=\"if\" value=\"{{ltPropHeaderYield}}\"><template case=\"true\">\t\t\t\t<lyte-popover-header>\t\t\t\t\t<lyte-yield yield-name=\"header\"></lyte-yield>\t\t\t\t</lyte-popover-header>\t\t\t</template></template>\t\t\t<lyte-popover-content class=\"lyteDateSelect\">\t\t\t\t<div class=\"lytelist\">\t\t\t\t\t<template is=\"forIn\" object=\"{{ltPropOptions}}\" value=\"value\" key=\"key\">\t\t\t\t\t\t<lyte-item key-val=\"{{key}}\" onclick=\"{{action('itemclick', key, this, event)}}\">{{lyteUiI18n(key)}}</lyte-item>\t\t\t\t\t</template>\t\t\t\t</div>\t\t\t\t<div>\t\t\t\t\t<template is=\"if\" value=\"{{ltPropOptions.customRange}}\"><template case=\"true\">\t\t\t\t\t\t<div id=\"lyteRangeCalendar\" style=\"max-width: 0;width: 630px;\" class=\"lyteDateSelectHidden\">\t\t\t\t\t\t\t\t<lyte-daterangepicker lt-prop-current-date=\"{{ltPropCurrentDate}}\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-month-header-format=\"{{ltPropMonthHeaderFormat}}\" short-month-names=\"{{shortMonthNames}}\" long-month-names=\"{{longMonthNames}}\" lt-prop-start-year=\"{{ltPropStartYear}}\" lt-prop-end-year=\"{{ltPropEndYear}}\" lt-prop-start-date=\"{{lbind(ltPropStartDate)}}\" lt-prop-end-date=\"{{lbind(ltPropEndDate)}}\" cal-view-date1=\"{{lbind(ltPropStartDateObject)}}\" cal-view-date2=\"{{lbind(ltPropEndDateObject)}}\" on-navigation=\"{{method('navigation')}}\" on-date-selected=\"{{method('dateselected')}}\" dd-option-selected=\"{{method( 'ddoption' )}}\" second-selection=\"{{method('secondDateSelectd')}}\" first-selection=\"{{method('ddoption')}}\"></lyte-daterangepicker>\t\t\t\t\t\t\t<lyte-button lt-prop-name=\"{{ltPropName}}\" lt-prop-autofocus=\"{{ltPropAutofocus}}\" lt-prop-appearance=\"{{ltPropAppearance}}\" lt-prop-id=\"{{ltPropId}}\" lt-prop-button-type=\"{{ltPropButtonType}}\" lt-prop-value=\"{{ltPropValue}}\" lt-prop-tabindex=\"{{ltPropTabindex}}\" lt-prop-style=\"{{ltPropStyle}}\" lt-prop-size=\"{{ltPropSize}}\" lt-prop-background-color=\"{{ltPropBackgroundColor}}\" lt-prop-color=\"{{ltPropColor}}\" lyte-shortcut=\"{{lyteShortcut}}\" lt-prop-class=\"{{ltPropClass}}\" onclick=\"{{action('singleClick', 'customRange', event)}}\" lt-prop-disabled=\"{{ltPropDisabled}}\">\t\t\t\t\t\t\t\t<template is=\"registerYield\" yield-name=\"text\">\t\t\t\t\t\t\t\t\tdone\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</lyte-button>\t\t\t\t\t\t</div>\t\t\t\t\t</template></template>\t\t\t\t\t<template is=\"if\" value=\"{{ltPropOptions.specificDate}}\"><template case=\"true\">\t\t\t\t\t \t<div id=\"lyteSingleCalendar\" style=\"max-width: 0;width: 300px;\" class=\"lyteDateSelectHidden\">\t\t\t\t\t\t\t <lyte-calendar lt-prop-fill-rows=\"{{ltPropFillRows}}\" lt-prop-number-of-rows=\"{{ltPropNumberOfRows}}\" lt-prop-yield=\"{{ltPropYield}}\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-end-date=\"{{lbind(ltPropEndDate)}}\" lt-prop-start-date=\"{{lbind(ltPropStartDate)}}\" lt-prop-current-date=\"{{lbind(ltPropCurrentDate)}}\" lt-prop-year=\"{{lbind(ltPropYear)}}\" lt-prop-month-header=\"{{lbind(ltPropMonthHeader)}}\" on-date-selected=\"{{method('dateselected1')}}\" lt-prop-min-date=\"{{lbind(ltPropMinDate)}}\" lt-prop-max-date=\"{{lbind(ltPropMaxDate)}}\" lt-prop-start-week-day=\"{{lbind(ltPropStartWeekDay)}}\">\t\t                             <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\"> \t\t                                <template is=\"registerYield\" yield-name=\"footer\">\t\t                                    <lyte-yield yield-name=\"footer\"></lyte-yield>\t\t                                </template>\t\t                             </template></template>   \t\t                      </lyte-calendar> \t\t                      <lyte-button lt-prop-name=\"{{ltPropName}}\" lt-prop-autofocus=\"{{ltPropAutofocus}}\" lt-prop-appearance=\"{{ltPropAppearance}}\" lt-prop-id=\"{{ltPropId}}\" lt-prop-button-type=\"{{ltPropButtonType}}\" lt-prop-value=\"{{ltPropValue}}\" lt-prop-tabindex=\"{{ltPropTabindex}}\" lt-prop-style=\"{{ltPropStyle}}\" lt-prop-size=\"{{ltPropSize}}\" lt-prop-background-color=\"{{ltPropBackgroundColor}}\" lt-prop-color=\"{{ltPropColor}}\" lyte-shortcut=\"{{lyteShortcut}}\" lt-prop-class=\"{{ltPropClass}}\" onclick=\"{{action('singleClick', 'specificDate', event)}}\" lt-prop-disabled=\"{{ltPropDisabled}}\">\t\t\t\t\t\t\t\t<template is=\"registerYield\" yield-name=\"text\">\t\t\t\t\t\t\t\t\tdone\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</lyte-button>\t\t\t\t\t\t</div>\t\t\t\t\t</template></template>\t\t\t\t\t</div>\t\t\t</lyte-popover-content>\t\t\t<template is=\"if\" value=\"{{ltPropFooterYield}}\"><template case=\"true\">\t\t\t\t<lyte-popover-footer>\t\t\t\t\t<lyte-yield yield-name=\"footer\"></lyte-yield>\t\t\t\t</lyte-popover-footer>\t\t\t</template></template>\t\t</template>\t</lyte-popover>\t</template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[3,1,1]},{"type":"forIn","position":[3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"attr","position":[3,3,1]},{"type":"if","position":[3,3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"registerYield","position":[1,3,1],"dynamicNodes":[]},{"type":"componentDynamic","position":[1,3]}]}},"default":{}},{"type":"attr","position":[3,3,3]},{"type":"if","position":[3,3,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1],"dynamicNodes":[{"type":"insertYield","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"registerYield","position":[1,3,1],"dynamicNodes":[]},{"type":"componentDynamic","position":[1,3]}]}},"default":{}},{"type":"componentDynamic","position":[3]},{"type":"attr","position":[5]},{"type":"if","position":[5],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}],
_observedAttributes :["ltPropSelected","ltPropOptions","ltPropFooterYield","ltPropHeaderYield","ltPropDisabled","ltPropName","ltPropAutofocus","ltPropAppearance","ltPropId","ltPropButtonType","ltPropValue","ltPropTabindex","ltPropStyle","ltPropSize","ltPropBackgroundColor","ltPropColor","lyteShortcut","ltPropClass","ltPropCurrentDate","ltPropFormat","ltPropMonthHeaderFormat","shortMonthNames","longMonthNames","ltPropStartYear","ltPropEndYear","ltPropStartDate","ltPropEndDate","ltPropFillRows","ltPropNumberOfRows","ltPropMinDate","ltPropMaxDate","ltPropStartWeekDay","daysOfWeek","ltPropYear","viewDate","ltPropShow","ltPropType","ltPropFreeze","ltPropShowCloseButton","ltPropCloseOnEscape","ltPropOriginElem","ltPropPlacement","ltPropScrollable","ltPropDraggable","ltPropAllowMultiple","ltPropMaxHeight","ltPropMaxWidth","ltPropWidth","ltPropHeight","ltPropWrapperClass","ltPropBoundry","ltPropCloseOnBodyClick","ltPropDuration","ltPropOffset","ltPropBindToBody","ltPropContentPadding","ltPropDimmer","showOpen"],

	init : function(){
		if( this.getMethods( 'beforeRender' ) ) {
			this.executeMethod( 'beforeRender', this.$node )
		}
	},

	didConnect : function(){
		this._end = this.transitionEndEventHide.bind( this )
		this._start = this.transitionEndEventShow.bind( this )
		this._popover = this.$node.querySelector( 'lyte-popover' )
		if( this.getMethods( 'afterRender' ) ) {
			this.executeMethod( 'afterRender', this.$node )
		}
	},

	data : function(){
		return {

			ltPropSelected : Lyte.attr('string', { default : 'specificDate'}),
			ltPropOptions : Lyte.attr( 'object', { default : {
				today :  true,
				yesterday : true,
				last7days : true,
				last30days : true,
				thisWeek : true,
				thisMonth : true,
				specificDate : true,
				customRange : true
			}}),
			ltPropFooterYield : Lyte.attr( 'boolean', { default : false } ),
			ltPropHeaderYield : Lyte.attr( 'boolean', { default : false } ),

			// button props

			ltPropDisabled : Lyte.attr( 'boolean', { default : true } ),
			'ltPropName': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropAutofocus': Lyte.attr( 'boolean', {
				'default': false
			} ),
			'ltPropAppearance': Lyte.attr( 'string', {
				'default': 'primary'
			} ),
			'ltPropId': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropButtonType': Lyte.attr( 'string', {
				'default': 'button'
			} ),
			'ltPropValue': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropTabindex': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropStyle': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropSize': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropBackgroundColor': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'ltPropColor': Lyte.attr( 'string', {
				'default': undefined
			} ),
			'lyteShortcut': Lyte.attr( 'object', {
				'default': {}
			} ),
			'ltPropClass':Lyte.attr( 'string', {
				'default': ''
			} ),

			// data for date range picker
			ltPropCurrentDate : Lyte.attr( "string" , { "default" :'' } ),
			ltPropFormat : Lyte.attr( "string", { "default" : "MM/DD/YYYY" } ),
			ltPropMonthHeaderFormat : Lyte.attr( "string", { "default" : "MMM YYYY" } ),
			shortMonthNames : Lyte.attr( "array" , { "default" : [ 'Jan', 'Feb', 'Mar', 'Apr', 'short.may', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ]}),
			longMonthNames : Lyte.attr( 'array', { 
				'default': [
				'January',
				'February',
				'March',
				'April',
				'May',
				'June',
				'July',
				'August',
				'September',
				'October',
				'November',
				'December' 
				]
			} ),
			ltPropStartYear : Lyte.attr( "number" , { "default" : 1900 } ),
			ltPropEndYear : Lyte.attr( "number", { "default" : 2100 } ),
			ltPropStartDate : Lyte.attr( "string", { "default" : "" } ),
			ltPropEndDate : Lyte.attr( "string", { "default" : "" } ),
			// ltPropStartDateObject : Lyte.attr( "object" ),
			// ltPropEndDateObject : Lyte.attr("object"),

			// data for single calendar
			ltPropFillRows : Lyte.attr('boolean', {default : false}),
			ltPropNumberOfRows : Lyte.attr('number', {default : 6}),
			ltPropMinDate : Lyte.attr('string', { default : ""}),
			ltPropMaxDate : Lyte.attr('string', { default : ""}),
			ltPropStartWeekDay : Lyte.attr('number', { default : 1}),
			daysOfWeek : Lyte.attr("array",{"default":['Sun','Mon','Tue','Wed','Thu','Fri','Sat']}),
			ltPropYear : Lyte.attr("boolean",{"default":true}),
			viewDate : Lyte.attr("object",{"default":{}}),

			// data for popover
			ltPropShow : Lyte.attr("boolean", { "default" : false } ),
            ltPropType : Lyte.attr( "string", { "default" : "box" } ),
            ltPropFreeze : Lyte.attr( "boolean", { "default" : false } ),
            ltPropShowCloseButton : Lyte.attr( "boolean", { "default" : false } ),
            ltPropCloseOnEscape : Lyte.attr( "boolean", { "default" : true } ),
            ltPropOriginElem : Lyte.attr( "string", { "default" : "" } ),
            "ltPropPlacement":Lyte.attr("string",{"default":""}),
            "ltPropScrollable":Lyte.attr("boolean",{"default": false}),
            "ltPropDraggable":Lyte.attr("boolean",{"default": true}),
            "ltPropAllowMultiple":Lyte.attr("boolean",{"default": false}),
            "ltPropMaxHeight":Lyte.attr("string",{"default":""}),
            "ltPropMaxWidth":Lyte.attr("string",{"default":""}),
            "ltPropWidth":Lyte.attr("string",{"default":""}),
            "ltPropHeight":Lyte.attr("string",{"default":"370px"}),
            "ltPropWrapperClass":Lyte.attr("string",{"default":""}),
            "ltPropBoundry" : Lyte.attr("object",{"default":{}}),
            "ltPropCloseOnBodyClick" : Lyte.attr("boolean",{"default" : false}),
            "ltPropDuration" : Lyte.attr("number",{"default" : 800}),
            "ltPropOffset" : Lyte.attr("object",{"default" : {}}),
            "ltPropBindToBody" : Lyte.attr("boolean",{"default":false}),
            "ltPropContentPadding":Lyte.attr("string",{"default":"0"}),
            "ltPropDimmer":Lyte.attr("object",{"default":{"color":"black","opacity":"0.4"}}),

            // system

            showOpen : Lyte.attr( 'boolean', { default : false} )

		}		
	},

	didDestroy : function(){
		// document.body.removeChild( this.childComp );
	},

	selectedValFunc : function(arg){
		if( !this.getData( 'ltPropShow' ) ) {
			return;
		}
		var selected = this.getData( 'ltPropSelected' );
		arg = arg || {};
		var el = this._popover.component.actualModalDiv || this.$node.querySelector( '.lytePopover' )
		$L.fastdom.mutate(function(){
			var elem, val1 = el.querySelector( '#lyteRangeCalendar' ), val2 = el.querySelector( '#lyteSingleCalendar' );
			if( selected == 'specificDate'){
				this.animate( val2, val1 )
			} else if ( selected == 'customRange' ) {
				this.animate( val1, val2 )
			}
			else if( arg.oldValue == 'specificDate' && val2 ){
				this.animate( null, val2 )
			} else if ( arg.oldValue == 'customRange' && val1 ){
				this.animate( null, val1 )
			} 
			else {
				if([ 'customRange', 'specificDate' ].indexOf( arg.newValue ) == -1 ) {
					this.setData( 'ltPropShow', false )
				}
			}

			if( arg && arg.oldValue == 'customRange' ) {
				this.setData( 'ltPropStartDate' , '')
				this.setData( 'ltPropStartDate' , '')
			} else if( arg && arg.oldValue == "specificDate" ) {
				this.setData( 'ltPropCurrentDate', '' )
			}
		}.bind( this )) 
	},

	selectionObs : function(arg){
		this.selectedValFunc( arg )
	}.observes( 'ltPropSelected' ),

	animate : function( animate, hide ){
		// show hide animation starts here can't use fastdom due to delay
		if( hide && !hide.classList.contains( 'lyteDateSelectHidden' ) && !hide._hideStart ) {
			hide._hideStart = true;
			if( animate ){
				hide._animate = animate;
				animate.addEventListener( 'transitionend', this._start )
				// this.setCrctPos( animate )
			} 
			else if( animate == null ) {
				this._hide = true
				hide.addEventListener( 'transitionend', this._end )
				hide.style.maxWidth = 0;
				return
			}
			hide.addEventListener( 'transitionend', this._end )
			hide.style.maxWidth = 0;
			return;
		}
	   if( animate && !animate._showstart && animate.classList.contains( 'lyteDateSelectHidden' ) ) {
	   		animate.addEventListener( 'transitionend', this._start )
	   	    this.startAnime( animate )
	   	    // setTimeout( function(){
	   	    // 	this.setCrctPos( animate )
	   	    // }.bind( this ) , 40 )
	   }
	},

	// setCrctPos : function( elem ) {
	// 	// adjusting positions
	// 	$L.fastdom.measure(function(){
	// 		var pos = this._popover.ltProp( 'positionNew' ),
	// 		act = this._popover.component.actualModalDiv || this.$node.querySelector( '.lytePopover' ), currLeft = parseInt( act.style.left ), originElem = document.querySelector( this.getData( 'ltPropOriginElem' ).trim() ).getBoundingClientRect(),
	// 		elemWidth = act.querySelector('.lytelist').getBoundingClientRect().width, actWid = act.getBoundingClientRect(), currLeft, gcstyle = window.getComputedStyle(act.querySelector('lyte-popover-content'));
	// 		if( currLeft < originElem.left ){
	// 			if( pos == 'left' ){
	// 				currLeft = Math.max( 0, originElem.left - this._callout - elemWidth - parseInt( gcstyle.paddingRight ) - parseInt( gcstyle.paddingLeft ))
	// 			} else {
	// 				currLeft = Math.min( originElem.left, window.innerWidth - elemWidth);
	// 			}
	// 		}
	// 		$L.fastdom.mutate(function(){
				
	// 			if( currLeft != undefined ) {
	// 				act.style.left = currLeft + 'px';
	// 			}
	// 		}.bind( this ))
	// 	}.bind( this ))
	// },

	getCrctLeft : function( elem ){
		// calculating positions
	   var act = this._popover.component.actualModalDiv || this.$node.querySelector( '.lytePopover' ), currLeft = parseInt( act.style.left ), originElem = document.querySelector( this.getData( 'ltPropOriginElem' ).trim() ).getBoundingClientRect()
	   if( this._popover.ltProp( 'positionNew' ) == 'left' ) {
		   if( currLeft < originElem.left ){
		   		var elemWidth = parseInt( elem.style.width ), actWid = act.getBoundingClientRect();
		   		currLeft = originElem.left - elemWidth - actWid.width - this._callout;
		   }
	   } else {
	   		var wwidth = window.innerWidth;
	   		if( currLeft > wwidth ) {
	   			currLeft = wwidth - elemWidth - actWid.width - this._callout
	   		}
	   }
	   if( currLeft != undefined ) {
	   	  act.style.left = Math.max( currLeft, 0 ) + 'px';
	   }
	},

	startAnime : function(elem){
		// animation start
		elem.classList.remove( 'lyteDateSelectHidden' )
		setTimeout(function(){
			elem.style.removeProperty('max-width')
			elem._showstart = true;
		}.bind( this ), 20)
		this.getCrctLeft(elem)
	},

	transitionEndEventHide : function(event){
		// animation end
		 if( event.propertyName != 'max-width' ) {
		 	return
		 }
		var _this = event.target;
		_this.classList.add( 'lyteDateSelectHidden' );
		_this.removeEventListener( 'transitionend', this._end );
		delete _this._hideStart;
		if( _this._animate ){
			this.startAnime(_this._animate)
			delete _this._animate;
		} else if( this._hide ) {
			delete this._hide;
			this.setData( 'ltPropShow', false )
		}
	},

	transitionEndEventShow : function(event){
		// animation end
		if( event.propertyName != 'max-width' ) {
		 	return
		 }
		var _this = event.target
		delete _this._showstart;
		_this.removeEventListener('transitionend', this._start )
		if( this._arg ) {
			if( this.getMethods( 'onShow' ) ){
				this.executeMethod( 'onShow', this._arg)
			}
			delete this._arg;
		}
	},

	methods : {
		beforeShow : function(){
			var selected = this.getData( 'ltPropSelected' )
			var el = this._popover.component.actualModalDiv || this.$node.querySelector( '.lytePopover' ), elem;
			if( selected == 'customRange' ) {
				elem = el.querySelector( '#lyteRangeCalendar')
			} else if( selected == 'specificDate' ) {
				elem = el.querySelector( '#lyteSingleCalendar')
			}
			if( elem ) {
				$L.fastdom.mutate(function(){
					elem.classList.remove( 'lyteDateSelectHidden' )
					elem.style.removeProperty('max-width')
				})
			}
			if( this.getMethods( 'onBeforeShow' ) ){
				return this.executeMethod( 'onBeforeShow' )
			}
		},

		show : function( arg){
			var el = this._popover.component.actualModalDiv || this.$node.querySelector( '.lytePopover' )
			$L.fastdom.measure(function(){
				if( this._popover.ltProp('positionNew') == 'left' ) {
					var elBcr = el.getBoundingClientRect(), originElem = document.querySelector( this.getData( 'ltPropOriginElem' ).trim() ).getBoundingClientRect()
					if( elBcr.right < originElem.left){
						this._callout = originElem.left - elBcr.right;
					} else {
						this._callout = 0
					}
				} else {
					this._callout = 0
				}
			}.bind(this))
			$L.fastdom.mutate(function(){
				var selected = this.getData( 'ltPropSelected' )
				var selEl = el.querySelector("[key-val = '"+ selected +"']:not(.lyteCalendarSelected)");
				if( selEl ) {
					selEl.classList.add('lyteCalendarSelected')
				}
				this.setData( 'showOpen' , true)

				if( this.getMethods( 'onShow' ) ){
					this.executeMethod( 'onShow', arg)
				}
			}.bind(this))
		},

		beforeClose : function(){
			if( this.getMethods( 'onBeforeClose' ) ){
				return this.executeMethod( 'onBeforeClose', arguments[ 0 ], arguments[ 1 ] )
			}
		},

		close : function(){
			this.setData( 'ltPropDisabled', true )
			this.setData( 'showOpen' , false)
			if( this.getMethods( 'onClose' ) ){
				this.executeMethod( 'onClose', arguments[ 0 ] )
			}
			this.setData( 'ltPropCurrentDate', '' )
			this.setData( 'ltPropStartDate' , '')
			this.setData( 'ltPropStartDate' , '')
		},

		resize : function(){
			if( this.getMethods( 'onResize' ) ){
				this.executeMethod( 'onResize', arguments[ 0 ], arguments[ 1 ] )
			}
		},

		scroll : function(){
			if( this.getMethods( 'onScroll' ) ){
				return this.executeMethod( 'onScroll', arguments[ 0 ], arguments[ 1 ] )
			}
		},

		dateselected : function( event, date, object){
			this.setData( 'ltPropDisabled', false )
			if( this.getMethods( 'onRangeDateSelected' ) ){
				return this.executeMethod( 'onRangeDateSelected', event, data, object )
			}
		},

		dateselected1 : function( event, date, object){
			this.setData( 'ltPropDisabled', false )
			if( this.getMethods( 'onSingleDateSelected' ) ){
				return this.executeMethod( 'onSingleDateSelected', event, data, object )
			}
		},

		navigation : function( arg1, arg2, arg3 ) {
			this.setData( 'ltPropDisabled', true )
			this.setData( 'ltPropCurrentDate', '' )
			this.setData( 'ltPropStartDate' , '')
			this.setData( 'ltPropStartDate' , '')
			if( this.getMethods( 'onNavigation' ) ) {
				this.executeMethod( 'onNavigation', arg1, arg2, arg3 )
			}
		},

		secondDateSelectd : function(){
			this.setData( 'ltPropDisabled', false )
		},

		ddoption : function(){
			this.setData( 'ltPropDisabled', true )
		}
	},

	actions : {
		itemclick : function( key, _this, event){
			this.setData( 'ltPropDisabled', true )
			var prevSel = $L('.lyteCalendarSelected', _this.parentElement)
			if( prevSel.e.length ) {
				prevSel.removeClass( 'lyteCalendarSelected' )
			}
			_this.classList.add('lyteCalendarSelected')
			this.$node.ltProp( 'selected', key );
			if([ 'customRange', 'specificDate' ].indexOf( key ) == -1 ) {
				if( this.getMethods( 'onSelect' ) ) {
					this.executeMethod( 'onSelect', key, event, this.$node)
				}
			}
		},

		singleClick : function(key, event ){
			if( this.getMethods( 'onSelect' ) ) {
				if( key == 'customRange' ) {
					this.executeMethod( 'onSelect', key, event, this.$node, this.getData( 'ltPropStartDate' ), this.getData( 'ltPropEndDate' ) )
				} else {
					this.executeMethod( 'onSelect', key, event, this.$node, this.getData( 'ltPropCurrentDate' ) )
				}
			}
			this.setData( 'ltPropShow', false )
		}
	}
});

Lyte.Component.register("lyte-dragdrop", {
_template:"<template tag-name=\"lyte-dragdrop\">\t<div class=\"lyteDragDropFields\">\t\t<div class=\"lyteDragDropColumns\">\t\t\t<div class=\"lyteDragDropFL lytePosRel\">\t\t\t\t<span class=\"lyteDragDropHeading\">{{ltPropAvailableLabel}}</span>\t\t\t\t\t<div class=\"lyteDragDropAvailable\">\t\t\t\t\t<span class=\"lyteSelectedNone\" id=\"AvailableNone\">{{ltPropAvailablelistEmptyMessage}}</span>\t\t\t\t\t<template is=\"if\" value=\"{{ltPropEnableSearch}}\">\t\t\t\t\t<template case=\"true\">\t\t\t\t\t<div class=\"lytePosRel\">\t\t\t\t\t\t<lyte-search style=\"display: block;\" lt-prop-style=\"{{ltPropSearchStyle}}\" lt-prop-query-selector=\"{{querySelector}}\" lt-prop-appearance=\"box\" lt-prop-error=\"{{ltPropErrorMessage}}\" lt-prop-width=\"464px\"></lyte-search>\t\t\t\t\t\t</div>\t\t\t\t\t<ul class=\"lyteAvailableUL\" id=\"sortableSec\">\t\t\t\t\t<template is=\"for\" items=\"{{ltPropAvailablelist}}\" item=\"item\">                     \t<li class=\"filterlabel sortableElem\" data-pos=\"{{item.pos}}\" data-propvalue=\"{{item}}\" onmousedown=\"{{action('mouseDown', event)}}\" onmouseover=\"{{action('mouseOver',event)}}\" onmouseout=\"{{action('mouseOut', event)}}\">                     \t\t<span class=\"item\">{{item.name}}</span>                     \t\t<template is=\"if\" value=\"{{ltPropDraggable}}\">                     \t\t\t<template case=\"true\">                     \t\t\t\t<template is=\"if\" value=\"{{ltPropEnableIcon}}\">                     \t\t\t\t\t<template case=\"true\"><span class=\"lyteDragDropAdd\"></span></template>                     \t\t\t\t</template>                     \t\t\t</template>                     \t\t</template>                     \t</li>\t\t\t\t\t</template>                    </ul>                    </template>                    <template case=\"false\">\t\t\t\t\t<ul class=\"lyteAvailableUL\" id=\"sortableSec\" style=\"height: 336px;\">\t\t\t\t\t<template is=\"for\" items=\"{{ltPropAvailablelist}}\" item=\"item\">                     \t<li class=\"filterlabel sortableElem\" data-pos=\"{{item.pos}}\" data-propvalue=\"{{item}}\" onmousedown=\"{{action('mouseDown', event)}}\" onmouseover=\"{{action('mouseOver',event)}}\" onmouseout=\"{{action('mouseOut', event)}}\">                     \t\t<span class=\"item\">{{item.name}}</span>                     \t\t<template is=\"if\" value=\"{{ltPropDraggable}}\">                     \t\t\t<template case=\"true\">                     \t\t\t\t<template is=\"if\" value=\"{{ltPropEnableIcon}}\">                     \t\t\t\t\t<template case=\"true\"><span class=\"lyteDragDropAdd\"></span></template>                     \t\t\t\t</template>                     \t\t\t</template>                     \t\t</template>                     \t</li>\t\t\t\t\t</template>                    </ul>                    </template>\t\t\t\t\t</template>\t\t\t\t</div>\t\t\t</div>\t\t\t<template is=\"if\" value=\"{{ltPropDraggable}}\">\t\t\t\t<template case=\"true\">\t\t\t\t\t<div class=\"lyteDragDropFL lytePosRel\">\t\t\t\t\t\t<span class=\"lyteDragDropHeading\">{{ltPropSelectedLabel}}</span>\t\t\t\t\t\t\t<div class=\"lyteDragDropSelected\">\t\t\t\t\t\t\t<span class=\"lyteSelectedNone\" id=\"SelectedNone\">{{ltPropSelectedlistEmptyMessage}}</span>\t\t\t\t\t\t\t<ul class=\"lyteSelectedUL\" id=\"dropSec\">\t\t\t\t\t\t\t<template is=\"for\" items=\"{{ltPropSelectedlist}}\" item=\"item\">\t\t                     \t<li data-pos=\"{{item.pos}}\" data-propvalue=\"{{item}}\" onmousedown=\"{{action('mouseDown', event)}}\" onmouseover=\"{{action('mouseOver',event)}}\" onmouseout=\"{{action('mouseOut', event)}}\">\t\t                     \t\t<span>{{item.name}}</span>\t\t                     \t\t<template is=\"if\" value=\"{{ltPropEnableIcon}}\">\t\t                     \t\t\t<template case=\"true\"><span class=\"lyteDragDropRemove\"></span></template>\t\t                     \t\t</template>\t\t                     \t</li>\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</ul>\t\t\t\t\t\t</div>\t\t\t\t\t</div>\t\t\t\t</template>\t\t\t</template>\t\t</div>\t</div></template>",
_dynamicNodes : [{"type":"text","position":[1,1,1,1,0]},{"type":"text","position":[1,1,1,3,1,0]},{"type":"attr","position":[1,1,1,3,3]},{"type":"if","position":[1,1,1,3,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[3,1]},{"type":"for","position":[3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]}]}},"default":{}},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"text","position":[1,3,1,0]},{"type":"attr","position":[1,3,3,1]},{"type":"for","position":[1,3,3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}]}},"default":{}}],
_observedAttributes :["ltPropAvailablelist","ltPropSelectedlist","ltPropMultiselect","ltPropEnableSearch","ltPropEnableIcon","ltPropDraggable","ltPropErrorMessage","ltPropAvailablelistEmptyMessage","ltPropSelectedlistEmptyMessage","ltPropSearchStyle","ltPropAvailableLabel","ltPropSelectedLabel","clickCount","component","placeholder","div","offset","isDown","isMoved","top","bottom","prevScrollTop","multiSelectedItems","keyPressed","keyValue","prevMode","checkSelection","querySelector","left","right","availableList","selectedList","checkOnDidconnect","draggedItems"],
	init : function(){
		if(!this.getData('ltPropErrorMessage')){
			this.setData('ltPropErrorMessage',_lyteUiUtils.i18n("no.results.found"));
		}
		this.setData('ltPropAvailableLabel',_lyteUiUtils.i18n("Available"));
		this.setData('ltPropSelectedLabel',_lyteUiUtils.i18n("Selected"));
	},
	didConnect : function() {

		var dragdrops = document.querySelectorAll('lyte-dragdrop');
		for(var v = 0 ; v < dragdrops.length; v++){
			if(dragdrops[v] == this.$node){
				// console.log(v);
				this.$node.querySelector('#sortableSec').classList.add('searchable'+v);
				this.setData('querySelector',{'scope':'.searchable'+v,'target':'.filterlabel','search':'.item'});
				// console.log(this.getData('querySelector'));
				break;
			}
		}
		this.setData('checkOnDidconnect',true);
	},
	data : function(){
        return {
			"ltPropAvailablelist" : Lyte.attr("array",{"default":[]}),
			"ltPropSelectedlist" : Lyte.attr("array",{"default":[]}),
			"ltPropMultiselect" : Lyte.attr("boolean",{"default":true}),
			"ltPropEnableSearch" : Lyte.attr("boolean",{"default":true}),
			"ltPropEnableIcon" : Lyte.attr("boolean",{"default":true}),
			"ltPropDraggable" : Lyte.attr("boolean",{"default":true}),
			"ltPropErrorMessage" : Lyte.attr("string",{"default":""}),
			"ltPropAvailablelistEmptyMessage" : Lyte.attr("string",{"default" : "Empty List"}),
			"ltPropSelectedlistEmptyMessage" : Lyte.attr("string",{"default" : "Drop Here"}),
			"ltPropSearchStyle" : Lyte.attr("string",{"default" : ""}),
			"ltPropAvailableLabel" : Lyte.attr("string"),
			"ltPropSelectedLabel" : Lyte.attr("string"),

			/*local variables of the component*/
			"clickCount" : Lyte.attr("number",{"default":0}),
			"component" : Lyte.attr("object",{"default":null}),
			"placeholder" : Lyte.attr("object",{"default":null}),
			"div" : Lyte.attr("object",{"default":null}),
			"offset" : Lyte.attr("array",{"default":[0,0]}),
			"isDown" : Lyte.attr("boolean",{"default":false}),
			"isMoved" : Lyte.attr("boolean",{"default":false}),
			"top" : Lyte.attr("number",{"default":0}),
			"bottom" : Lyte.attr("number",{"default":0}),
			"prevScrollTop" : Lyte.attr("number",{"default":0}),
			"multiSelectedItems" : Lyte.attr("array",{"default":[]}),
			"keyPressed" : Lyte.attr("boolean",{"default":false}),
			"keyValue" : Lyte.attr("number",{"default":0}),
			"prevMode" : Lyte.attr("string",{"default":""}),
			"checkSelection" : Lyte.attr("boolean",{"default":false}),
			"querySelector" : Lyte.attr("object",{"default":{'scope':'#sortableSec','target':'.filterlabel','search':'.item'}}),
			"left" : Lyte.attr("boolean",{"default":false}),
			"right" : Lyte.attr("boolean",{"default":false}),
			"availableList" : Lyte.attr("array",{"default" : []}),
			"selectedList" : Lyte.attr("array",{"default" : []}),
			"checkOnDidconnect" : Lyte.attr("boolean",{"default" : false}),
			"draggedItems" : Lyte.attr("array",{"default" : []})
		}
	},

	makeDroppable : function(current){
		var dropables1 = this.$node.querySelectorAll('#sortableSec>li');
		var dropables2 = this.$node.querySelectorAll('#dropSec>li');
		if(dropables1.length > 0){
			for(var i = 0; i<dropables1.length ; i++){
				if(dropables1[i] !== current){
					dropables1[i].classList.add('dropable');
				}
			}
		}
		if(dropables2.length > 0){
			for(var i = 0; i<dropables2.length ; i++){
				if(dropables2[i] !== current){
					dropables2[i].classList.add('dropable');
				}
			}
		}
	},

	showMsgForEmpty : function(){
		if(this.getData('ltPropAvailablelist').length > 0){
			this.$node.querySelector('#AvailableNone').style.visibility = "hidden";
		}
		if(this.getData('ltPropAvailablelist').length == 0){
			this.$node.querySelector('#AvailableNone').style.visibility = "visible";
		}
		if(this.getData('ltPropDraggable')){
			if(this.getData('ltPropSelectedlist').length == 0){
		    	this.$node.querySelector('#SelectedNone').style.visibility = "visible";
		    }
		    if(this.getData('ltPropSelectedlist').length > 0){
		    	this.$node.querySelector('#SelectedNone').style.visibility = "hidden";
		    }
		}
	}.observes('ltPropAvailablelist.[]','ltPropSelectedlist.[]','checkOnDidconnect'),

	removeDropable : function(current){
		var dropables1 = this.$node.querySelectorAll('#sortableSec>li');
		var dropables2 = this.$node.querySelectorAll('#dropSec>li');
		if(dropables1.length > 0){
			for(var i = 0; i<dropables1.length ; i++){
				if(dropables1[i] !== current){
					dropables1[i].classList.remove('dropable');
				}
			}
		}
		if(dropables2.length > 0){
			for(var i = 0; i<dropables2.length ; i++){
				if(dropables2[i] !== current){
					dropables2[i].classList.remove('dropable');
				}
			}
		}
	},


	generateArray : function(){
		// this.hideOrShowMessageOnEmpty("availableList","Empty Array");
		var array1 = Array.from(this.$node.querySelectorAll("#sortableSec>li"));
		var array2 = Array.from(this.$node.querySelectorAll("#dropSec>li"));
		//console.log(array2);
		ltPropAvailablelist = [];
		ltPropSelectedlist = [];
		for(var i = 1 ; i<=array1.length ; i++){
			var obj = this.getElement(array1[i-1]);
			if(obj){
				obj.pos = i;
				ltPropAvailablelist.push(obj);
			}
		}
		for(var i = 1 ; i<=array2.length; i++){
			var obj = this.getElement(array2[i-1]);
			obj.pos = i;
			ltPropSelectedlist.push(obj);
		}
	    this.setData('availableList',ltPropAvailablelist);
	    this.setData('selectedList',ltPropSelectedlist);
	},

	removeClass : function(){
		var array1 = Array.from(this.$node.querySelectorAll("#sortableSec>li"));
		var array2 = Array.from(this.$node.querySelectorAll("#dropSec>li"));
		for(var v = 0 ; v< array1.length ; v++){
			if(array1[v].classList.contains('lyteDraggableElem')){
				array1[v].classList.remove('lyteDraggableElem');
			}
		}
		for(var v = 0 ; v< array2.length ; v++){
			if(array2[v].classList.contains('lyteDraggableElem')){
				array2[v].classList.remove('lyteDraggableElem');
			}
		}
	},

	//Push the selected items in the array based on their position in DOM
	positionalPush : function(item,tempArray){
		var multiSelectedItems = this.getData('multiSelectedItems');
		var pos = 0;
		for(var v = 0 ; v < multiSelectedItems.length ; v++){
			if(multiSelectedItems[v].offsetTop > item.offsetTop){
				break;
			}
			else{
				++pos;
			}
		}
		multiSelectedItems.splice(pos,0,item);
		this.setData('multiSelectedItems',multiSelectedItems);
	},


	//Adds the selected items to an array for multiselected drag and drop
	addToArray : function(item,mode){
		if(mode === "single"){
			var multiSelectedItems = this.getData('multiSelectedItems');
			var emptyArray = [];
			if(multiSelectedItems.length > 0){
				var array1 = Array.from(this.$node.querySelectorAll("#sortableSec>li"));
				var array2 = Array.from(this.$node.querySelectorAll("#dropSec>li"));
				var lastItem = multiSelectedItems[multiSelectedItems.length - 1];
				var indexOfLastItem = array1.indexOf(lastItem);
				if(indexOfLastItem == -1){
					indexOfLastItem = array2.indexOf(lastItem);
					var index = array2.indexOf(item);
					if(index == -1){
						this.setData('multiSelectedItems',emptyArray);
						this.removeClass();
						this.addToArray(item,mode);
					}
					else{
						this.positionalPush(item);
						if(!(item.classList.contains('lyteDraggableElem'))){
							item.classList.add('lyteDraggableElem');
						}
					}
				}
				else{
					var index = array1.indexOf(item);
					if(index == -1){
						this.setData('multiSelectedItems',emptyArray);
						this.removeClass();
						this.addToArray(item,mode);
					}
					else{
						this.positionalPush(item);
						if(!(item.classList.contains('lyteDraggableElem'))){
							item.classList.add('lyteDraggableElem');
						}
					}
				}
			}
			else{
				this.getData('multiSelectedItems').push(item);
				if(!(item.classList.contains('lyteDraggableElem'))){
					item.classList.add('lyteDraggableElem');
				}
			}
			this.setData('prevMode',mode);
		}
		if(mode == "multiple"){
			if(this.getData('prevMode') == "multiple" || this.getData('prevMode')== ""){
				this.removeClass();
				var newMultiSelectedItems = [];
				var array1 = Array.from(this.$node.querySelectorAll("#sortableSec>li"));
				var array2 = Array.from(this.$node.querySelectorAll("#dropSec>li"));
				var index = array1.indexOf(item);
				if(index == -1){
					index = array2.indexOf(item);
					for(var v = 0;v <= index; v++){
						newMultiSelectedItems.push(array2[v]);
						array2[v].classList.add('lyteDraggableElem');
					}
				}
				else{
					for(var v = 0;v <= index; v++){
						newMultiSelectedItems.push(array1[v]);
						array1[v].classList.add('lyteDraggableElem');
					}
				}
				this.setData('multiSelectedItems',newMultiSelectedItems);
			}
			if(this.getData('prevMode') == "single"){
				var array1 = Array.from(this.$node.querySelectorAll("#sortableSec>li"));
				var array2 = Array.from(this.$node.querySelectorAll("#dropSec>li"));
				var multiSelectedItems = this.getData('multiSelectedItems');
				if(multiSelectedItems.length > 0){
					var lastItem = multiSelectedItems[multiSelectedItems.length - 1];
					var indexOfLastItem = array1.indexOf(lastItem);
					if(indexOfLastItem == -1){
						indexOfLastItem = array2.indexOf(lastItem);
						var index = array2.indexOf(item);
						if(index == -1){
							this.setData('prevMode',mode);
							this.removeClass();
							this.addToArray(item,mode);
						}
						else{
							if(indexOfLastItem != -1){
								if(indexOfLastItem <= index){
									for(var v = indexOfLastItem; v <= index ; v++){
										if(multiSelectedItems.indexOf(array2[v]) == -1){
											array2[v].classList.add('lyteDraggableElem');
											this.positionalPush(array2[v]);
										}
									}
								}
								else{
									for(var v = index; v <= indexOfLastItem ; v++){
										if(multiSelectedItems.indexOf(array2[v]) == -1){
											array2[v].classList.add('lyteDraggableElem');
											this.positionalPush(array2[v]);
										}
									}
								}
							}
						}
					}
					else{
						var index = array1.indexOf(item);
						if(index === -1){
							this.setData('prevMode',mode);
							this.removeClass();
							this.addToArray(item,mode);
						}
						else{
							if(indexOfLastItem != -1){
								if(indexOfLastItem <= index){
									for(var v = indexOfLastItem; v <= index ; v++){
										if(multiSelectedItems.indexOf(array1[v]) == -1){
											array1[v].classList.add('lyteDraggableElem');
											this.positionalPush(array1[v]);
										}
									}
								}
								else{
									for(var v = index; v <= indexOfLastItem ; v++){
										if(multiSelectedItems.indexOf(array1[v]) == -1){
											array1[v].classList.add('lyteDraggableElem');
											this.positionalPush(array1[v]);
										}
									}
								}
							}
						}
					}
				}
				else{
					this.setData('prevMode',mode);
					this.removeClass();
					this.addToArray(item,mode);
				}
				
			}
			this.setData('prevMode',mode);
		}
	},

	//Removes some items from the array
	removeFromArray : function(item){
		if(this.getData('multiSelectedItems').length > 0){
			var index = this.getData('multiSelectedItems').indexOf(item);
			this.getData('multiSelectedItems').splice(index,1);
		}
	},
	
	//Gets the top and bottom for multiSelected items
	getTopNBottom : function(prop){
		if(prop === "top"){
			return this.getData('multiSelectedItems')[0].getBoundingClientRect().top;
		}
		if(prop == "bottom"){
			return this.getData('multiSelectedItems')[this.getData('multiSelectedItems').length - 1].getBoundingClientRect().bottom;
		}
	},

	//Adds class to the selected items to identify them as droppable
	makeDroppableMultiple : function(array){
		var dropables1 = Array.from(this.$node.querySelectorAll('#sortableSec>li'));
		var dropables2 = Array.from(this.$node.querySelectorAll('#dropSec>li'));
		if(dropables1.indexOf(array[0]) == -1){
			if(dropables1.length > 0){
				for(var i = 0; i<dropables1.length ; i++){
					dropables1[i].classList.add('dropable');
				}
			}
			if(dropables2.length > 0){
				for(var i = 0; i<dropables2.length ; i++){
					flag = false;
					for(var j = 0; j<array.length; j++){
						if(dropables2[i] == array[j]){
							flag = true;
							break;
						}
					}
					if(!flag){
						dropables2[i].classList.add('dropable');
					}
				}
			}
		}
		else{
			if(dropables1.length > 0){
				for(var i = 0; i<dropables1.length ; i++){
					flag = false;
					for(var j = 0; j<array.length; j++){
						if(dropables1[i] == array[j]){
							flag = true;
							break;
						}
					}
					if(!flag){
						dropables1[i].classList.add('dropable');
					}
				}
			}
			if(dropables2.length > 0){
				for(var i = 0; i<dropables2.length ; i++){
					dropables2[i].classList.add('dropable');
				}
			}
		}
	},

	//Removes class from the selected items after they are dropped
	removeDropableMultiple : function(array){
		var dropables1 = Array.from(this.$node.querySelectorAll('#sortableSec>li'));
		var dropables2 = Array.from(this.$node.querySelectorAll('#dropSec>li'));
		if(dropables1.indexOf(array[0]) == -1){
			if(dropables1.length > 0){
				for(var i = 0; i<dropables1.length ; i++){
					dropables1[i].classList.remove('dropable');
				}
			}
			if(dropables2.length > 0){
				for(var i = 0; i<dropables2.length ; i++){
					flag = false;
					for(var j = 0; j<array.length; j++){
						if(dropables2[i] == array[j]){
							flag = true;
							break;
						}
					}
					if(!flag){
						dropables2[i].classList.remove('dropable');
					}
				}
			}
		}
		else{
			if(dropables1.length > 0){
				for(var i = 0; i<dropables1.length ; i++){
					flag = false;
					for(var j = 0; j<array.length; j++){
						if(dropables1[i] == array[j]){
							flag = true;
							break;
						}
					}
					if(!flag){
						dropables1[i].classList.remove('dropable');
					}
				}
			}
			if(dropables2.length > 0){
				for(var i = 0; i<dropables2.length ; i++){
					dropables2[i].classList.remove('dropable');
				}
			}
		}
	},

	checkElement : function(ele){
		if((ele == this.$node.querySelector('#sortableSec')) || (ele == this.$node.querySelector('#dropSec'))){
			return true;
		}
		return false;
	},

	checkPossiblePosition : function(ele,prop){
		var array = Array.from(this.$node.querySelectorAll('#'+ele.id+' > li'));
		if(prop == "single"){
			if(array.length > 0){
				var lastChild = array[array.length - 1];
				if(this.getData('div').getBoundingClientRect().top > lastChild.getBoundingClientRect().bottom){
					return true
				}
			}
			else{
				return true;
			}
		}
		if(prop == "multiple"){
			if(array.length > 0){
				var lastChild = array[array.length - 1];
				var top = this.getTopNBottom("top");
				if(top > lastChild.getBoundingClientRect().bottom){
					return true;
				} 
			}
			else{
				return true;
			}
		}
		return false;
	},

	checkIfDroppable : function(elem,prop){
		if(prop === "multiple"){
			var multiSelectedItems = this.getData('multiSelectedItems');
			if((multiSelectedItems[0].parentElement.id === elem.id) && elem.id === "sortableSec" && (elem.querySelectorAll('li').length === multiSelectedItems.length) && multiSelectedItems[0].getBoundingClientRect().left < (elem.getBoundingClientRect().left + multiSelectedItems[0].getBoundingClientRect().width / 2)){
				return true;
			}
			if((multiSelectedItems[0].parentElement.id === elem.id) && elem.id === "dropSec" && (elem.querySelectorAll('li').length === multiSelectedItems.length) && multiSelectedItems[0].getBoundingClientRect().right > (elem.getBoundingClientRect().right - multiSelectedItems[0].getBoundingClientRect().width / 2)){
				return true;
			}
		}
		if(prop === "single"){
			var div = this.getData('div');
			if((div.parentElement.id === elem.id) && elem.id === "sortableSec" && (elem.querySelectorAll('li').length === 1) && div.getBoundingClientRect().left < (elem.getBoundingClientRect().left + div.getBoundingClientRect().width / 2)){
				return true;
			}
			if((div.parentElement.id === elem.id) && elem.id === "dropSec" && (elem.querySelectorAll('li').length === 1) && div.getBoundingClientRect().right > (elem.getBoundingClientRect().right - div.getBoundingClientRect().width / 2)){
				return true;
			}
		}
		return false;
	},

	//Moves the item from one div to another when the icon is clicked or double click happens on the item
	appendElement : function(event,prop){
		// console.log(event.target.parentElement);
		var elem = event.target;
		var element;
		if(prop == 'span'){
			if(elem.classList.contains('lyteDragDropAdd') && this.onClickFunction(event,this.getElement(elem.parentElement),"availableList")){
				// this.$node.querySelector('#dropSec').appendChild(elem.parentElement);
				element = this.getElement(elem.parentElement);
				Lyte.arrayUtils(this.getData('ltPropAvailablelist'),'removeAt',this.getElementPosition(this.getData('ltPropAvailablelist'),element),1);
				Lyte.arrayUtils(this.getData('ltPropSelectedlist'),'push',element);
				element = null;
				this.generateArray();
				this.onDropFunction(event);
			}
			if(elem.classList.contains('lyteDragDropRemove') && this.onClickFunction(event,this.getElement(elem.parentElement),"selectedList")){
				// this.$node.querySelector('#sortableSec').appendChild(elem.parentElement);
				element = this.getElement(elem.parentElement);
				Lyte.arrayUtils(this.getData('ltPropSelectedlist'),'removeAt',this.getElementPosition(this.getData('ltPropSelectedlist'),element),1);
				Lyte.arrayUtils(this.getData('ltPropAvailablelist'),'push',element);
				element = null;
				this.generateArray();
				this.onDropFunction(event);
			}
		}
		else{
			while(elem){
				if(elem.parentElement && elem.parentElement.id == 'sortableSec' && this.onClickFunction(event,this.getElement(elem),"availableList")){
					element = this.getElement(elem);
					Lyte.arrayUtils(this.getData('ltPropAvailablelist'),'removeAt',this.getElementPosition(this.getData('ltPropAvailablelist'),element),1);
					Lyte.arrayUtils(this.getData('ltPropSelectedlist'),'push',element);
					element = null;
					this.generateArray();
					this.onDropFunction(event);
					break;
				}
				if(elem.parentElement && elem.parentElement.id == 'dropSec' && this.onClickFunction(event,this.getElement(elem),"selectedList")){
					element = this.getElement(elem);
					Lyte.arrayUtils(this.getData('ltPropSelectedlist'),'removeAt',this.getElementPosition(this.getData('ltPropSelectedlist'),element),1);
					Lyte.arrayUtils(this.getData('ltPropAvailablelist'),'push',element);
					element = null;
					this.generateArray();
					this.onDropFunction(event);
					break;
				}
				elem = elem.parentElement;
			}
		}
		
	},

	removeStyle : function(obj){
		obj.style.left = "";
    	obj.style.top = "";
    	// obj.style.zIndex = "";
    	obj.style.boxSizing = "";
    	obj.style.width = "";
    	obj.style.height = "";
    	obj.style.position = "";
    	obj.style.visibility = "";
	},

	getElement : function(elem){
		if(elem.dataset.propvalue){
			return JSON.parse(elem.dataset.propvalue);
		}
		return null;
	},

	getElementPosition : function(arrayElm,elem){
		for(var i =0;i<arrayElm.length;i++){
			var flag = true;
			for (var key in arrayElm[i]){
				if(arrayElm[i][key] != elem[key]){
					flag = false;
					break;
				}
			}
			if(flag){
				return i;
			}
		}
		return -1;
	},

	hideOrShowMessageOnEmpty : function(prop,msg){
		if(prop == "availableList"){
			if(this.getData('ltPropAvailablelist').length > 0){
				this.$node.querySelector('#AvailableNone').style.visibility = "hidden";
			}
			else{
				if(msg){
					this.$node.querySelector('#AvailableNone').innerHTML = msg;
				}
				this.$node.querySelector('#AvailableNone').style.visibility = "visible";
			}
		}
		else if(prop == "selectedList"){
			if(this.getData('ltPropSelectedlist').length > 0){
				this.$node.querySelector('#SelectedNone').style.visibility = "hidden";
			}
			else{
				if(msg){
					this.$node.querySelector('#SelectedNone').innerHTML = msg;
				}
				this.$node.querySelector('#SelectedNone').style.visibility = "visible";
			}
		}
		
	},

	selectFunction : function(event,target){
		var fromList = target.parentElement.id == "sortableSec" ? "availableList" : "selectedList"; 
		var returnVal;
		if(this.getMethods("onSelect")){
			returnVal = this.executeMethod("onSelect",event,this.getElement(target),this.getData('ltPropAvailablelist'),this.getData('ltPropSelectedlist'),fromList);	
		}
		return (returnVal == undefined) ? true : returnVal;
	},

	onDragFunction : function(event){
		var items;
		if(this.getData('ltPropMultiselect')){
			items = this.getData('multiSelectedItems');
		}
		else{
			items = this.getData('div');
		}
		if(this.getMethods("onDrag")){
			this.executeMethod("onDrag",event,items);	
		}
	},

	onBeforeDropFunction : function(event){
		var returnVal;
		var items = [];
		if(this.getData('ltPropMultiselect')){
			for(var i = 0; i<this.getData('multiSelectedItems').length ;i++){
				items.push(this.getElement(this.getData('multiSelectedItems')[i]));
			}
		}
		else{
			items.push(this.getElement(this.getData('div')));
		}
		this.setData("draggedItems",items);
		if(this.getMethods("onBeforeDrop")){
			returnVal = this.executeMethod("onBeforeDrop",event,items,this.getData('ltPropAvailablelist'),this.getData('ltPropSelectedlist'));	
		}
		return (returnVal == undefined) ? true : returnVal;
	},

	onDropFunction : function(event){
		if(this.getMethods("onDrop")){
			this.executeMethod("onDrop",event,this.getData('draggedItems'),this.getData('availableList'),this.getData('selectedList'));	
		}
	},

	onClickFunction : function(event,element,fromList){
		var returnVal;
		var items = [];
		items.push(element);
		this.setData('draggedItems',items);
		if(this.getMethods("onClick")){
			returnVal = this.executeMethod("onClick",event,element,this.getData('ltPropAvailablelist'),this.getData('ltPropSelectedlist'),fromList);
		}
		return (returnVal == undefined) ? true : returnVal;
	},

	 actions : {
	 	mouseDown : function(event){
	 		if(event.which == 3){
	 			return;
	 		}
	 		event.preventDefault();

	 		//Disable right click on the sortable elements to avoid unwanted behaviour
	 		if(event.which == 3){
	 			return;
	 		}
		 	var clickCount = this.getData('clickCount');
		 	clickCount++;
		 	this.setData('clickCount',clickCount);
		 	var self = this;
		    if (clickCount === 1) {
		        singleClickTimer = setTimeout(function() {
		            clickCount = 0;
		            self.setData('clickCount',clickCount);
		        }, 400);
		    } else if (clickCount === 2) {
		        clearTimeout(singleClickTimer);
		        clickCount = 0;
		        this.setData('clickCount',clickCount);
		        this.appendElement(event);
		        return;
		    }
	 		var target;
			var elem = event.target;
			// console.log(elem);
			if(elem.classList.contains('lyteDragDropAdd')){
				this.appendElement(event,'span');
			}
			else if(elem.classList.contains('lyteDragDropRemove')){
				this.appendElement(event,'span');
			}
			else{
				if(elem.tagName.toLowerCase() == 'span'){
					target = event.target.parentElement;
					// console.log(target);
				}
				else{
					target = event.target;
				}
			}
			
			if(target && this.selectFunction(event,target)){
				var targetOffset = target.getBoundingClientRect();
				var parentOffset = target.offsetParent.getBoundingClientRect();
				var height = target.clientHeight;
				var width = target.clientWidth;
				var multiSelectedItems = this.getData('multiSelectedItems');
				/*---- Multiple DragDrop ----*/
				if(this.getData('ltPropMultiselect')){
		 			if(multiSelectedItems.length > 0 && (multiSelectedItems.indexOf(target) != -1)){
						this.setData('offset',[
							event.clientX - targetOffset.left,
					        event.clientY - targetOffset.top
						]);
			 			this.setData('div',target);
						// console.log(this.getData('div'));
						var div = this.getData('div');
						var height = target.clientHeight;
						var width = target.clientWidth;
						// div.style.zIndex = 1001;
						div.style.left = (targetOffset.left - parentOffset.left) + 'px';
						div.style.top = (targetOffset.top - parentOffset.top) + 'px';
						// console.log('pointedItem left->',target.getBoundingClientRect().left)
						// console.log('pointedItem top->',target.getBoundingClientRect().top)
						div.style.boxSizing = "border-box";
						div.style.width = width +'px';
						div.style.height = height +'px';
						div.style.position = "absolute";
						div.classList.add('lyteDraggableElem');

						this.setData('placeholder',document.createElement('li'));
						var placeholder = this.getData('placeholder');
						placeholder.setAttribute("id","dummy");
						placeholder.style.width = width +'px';
						placeholder.style.height = height +'px';
						placeholder.style.boxSizing = "border-box";
						
						
						div.parentNode.insertBefore(placeholder, div);
						this.setData('checkSelection', true);
					}
					else{
						var keyValue = this.getData('keyValue');
			 			if(keyValue == 91 || keyValue == 93 || keyValue == 224){
			 				//console.log("here");
			 				//this.setData('keyValue',"");
		 					if(target.classList.contains('lyteDraggableElem')){
					    		target.classList.remove('lyteDraggableElem');
					    		this.removeFromArray(target);
					    	}
					    	else{
					    		target.classList.add('lyteDraggableElem');
					    		this.addToArray(target,'single');
					    	}

			 			}
			 			else if(keyValue == 16){
			 				//this.setData('keyValue',"");
		 					if(target.classList.contains('lyteDraggableElem')){
					    		target.classList.remove('lyteDraggableElem');
					    		this.addToArray(target,'multiple');
					    	}
					    	else{
					    		target.classList.add('lyteDraggableElem');
					    		this.addToArray(target,'multiple');
					    	}
			 			}
			 			else if(keyValue == 0){
		 					if(target.classList.contains('lyteDraggableElem')){
		 						if(this.getData('prevMode') == "multiple"){
		 							this.removeClass();
		 							this.setData('multiSelectedItems',[]);
						    		target.classList.add('lyteDraggableElem');
						    		this.getData('multiSelectedItems').push(target);
		 						}
		 						else{
		 							target.classList.remove('lyteDraggableElem');
					    			this.removeFromArray(target);
		 						}
		 						this.setData('prevMode','single');
					    	}
					    	else{
					    		this.removeClass();
					    		this.setData('multiSelectedItems',[]);
					    		target.classList.add('lyteDraggableElem');
					    		this.getData('multiSelectedItems').push(target);
					    		this.setData('prevMode','single');
					    	}
			 			}
			 			this.setData('offset',[
							event.clientX - targetOffset.left,
					        event.clientY - targetOffset.top
						]);
			 			this.setData('div',target);
						// console.log(this.getData('div'));
						var div = this.getData('div');
						var height = target.clientHeight;
						var width = target.clientWidth;
						// div.style.zIndex = 1001;
						div.style.left = (targetOffset.left - parentOffset.left) + 'px';
						div.style.top = (targetOffset.top - parentOffset.top) + 'px';
						// console.log('pointedItem left->',target.getBoundingClientRect().left)
						// console.log('pointedItem top->',target.getBoundingClientRect().top)
						div.style.boxSizing = "border-box";
						div.style.width = width +'px';
						div.style.height = height +'px';
						div.style.position = "absolute";
						div.classList.add('lyteDraggableElem');

						this.setData('placeholder',document.createElement('li'));
						var placeholder = this.getData('placeholder');
						placeholder.setAttribute("id","dummy");
						placeholder.style.width = width +'px';
						placeholder.style.height = height +'px';
						placeholder.style.boxSizing = "border-box";
						
						
						div.parentNode.insertBefore(placeholder, div);
			 		}
			 		this.setData('isDown',true);
				}
				 /*----Single drag and drop----*/
		 		 else{
		 			this.removeClass();
					//source = event.target;
					target.classList.add('lyteDraggableElem');
					this.setData('offset',[
						event.clientX - targetOffset.left,
				        event.clientY - targetOffset.top
					]);
					var isScrolled = false;
					
					this.setData('div',target);
					var div = this.getData('div');
					this.setData('isDown',true);//isDown = true;
					// div.style.zIndex = 1001;
					div.style.left = (targetOffset.left - parentOffset.left) + 'px';
					// var parentScrollTop = target.parentElement.scrollTop;
					// if(target.offsetTop > target.parentElement.offsetTop + target.parentElement.getBoundingClientRect().height){
					// 	div.style.top = (targetOffset.top - parentTop /*- parentScrollTop - height*/) + 'px';
					// 	// isScrolled = true;
					// }
					// else{
					div.style.top = (targetOffset.top - parentOffset.top) + 'px';
					// }
					// console.log('left->',target.getBoundingClientRect().left)
					// console.log('top->',target.getBoundingClientRect().top)
					div.style.boxSizing = "border-box";
					//debugger;
					div.style.width = width +'px';
					div.style.height = height +'px';
					div.style.position = "absolute";
					div.classList.add('lyteDraggableElem');

					this.setData('placeholder', document.createElement('li'));//placeholder = document.createElement('li');
					var placeholder = this.getData('placeholder');
					placeholder.setAttribute('id','dummy');
					
					placeholder.style.width = width +'px';
					placeholder.style.height = height +'px';
					placeholder.style.boxSizing = "border-box";
					
					
					div.parentNode.insertBefore(placeholder, div);
		 		}
		 		
				
		 		// this.selectFunction(event);
			}
			// console.log(this.getData('multiSelectedItems'));
		},

		mouseOver : function(event){
			// console.log(event.target);
			var target;
			var elem = event.target;
			if(elem.tagName.toLowerCase() == 'span'){
				target = event.target.parentElement;
				// console.log(target);
			}
			else{
				target = event.target;
			}
			if(target.classList.contains('lyteDraggableElem')){
				if(target.parentElement.id == "sortableSec"){
					if(target.querySelector('.lyteDragDropAdd')){
						target.querySelector('.lyteDragDropAdd').style.visibility = "hidden";
					}
				}
				if(target.parentElement.id == "dropSec"){
					if(target.querySelector('.lyteDragDropRemove')){
						target.querySelector('.lyteDragDropRemove').style.visibility = "hidden";
					}
				}
			}
			else{
				if(target.parentElement.id == "sortableSec"){
					if(target.querySelector('.lyteDragDropAdd')){
						target.querySelector('.lyteDragDropAdd').style.visibility = "visible";
					}
				}
				if(target.parentElement.id == "dropSec"){
					if(target.querySelector('.lyteDragDropRemove')){
						target.querySelector('.lyteDragDropRemove').style.visibility = "visible";
					}
				}
			}

		},

		mouseOut : function(event){
			var elem = event.target;
			if(elem.tagName.toLowerCase() == 'span'){
				target = event.target.parentElement;
				// console.log(target);
			}
			else{
				target = event.target;
			}
			if(target.parentElement.id == "sortableSec"){
				if(target.querySelector('.lyteDragDropAdd')){
					target.querySelector('.lyteDragDropAdd').style.visibility = "hidden";
				}
			}
			if(target.parentElement.id == "dropSec"){
				if(target.querySelector('.lyteDragDropRemove')){
					target.querySelector('.lyteDragDropRemove').style.visibility = "hidden";
				}
			}
		}	
	}


	
});

if (document.readyState === "complete" || document.readyState === "interactive"){
	addEvent();
}
else{
	document.addEventListener("DOMContentLoaded", function(event){
		addEvent(event);
	});
}

function addEvent(event){

var mousePosition;
var elemBelow;
var id;
var dropablePlace;
var prevTop = 0;
var component;
var side;
//console.log(component);
document.addEventListener('mouseup',function(event){
	var component;
	var target = event.target;
	while(target.parentElement){
		target = target.parentElement;
		if(target.tagName.toLowerCase() == 'lyte-dragdrop'){
			component=target.component;
			break;
		}
	}
	//component = component.component;
	if(component && component.getData('isDown')){
		component.setData('isDown',false);
		if(component.getData('isMoved')){
			component.setData('isMoved',false);
			var returnVal = component.onBeforeDropFunction(event);
			if(returnVal){
				if(component.getData('ltPropMultiselect') && component.getData('multiSelectedItems').length > 1 ){
					var placeholder = component.getData('placeholder');
					// console.log(placeholder);
					// console.log(placeholder.getBoundingClientRect().left)
					// console.log(placeholder.getBoundingClientRect().top)
					//debugger
					var placeholderOffset = placeholder.getBoundingClientRect();
					var multiSelectedItems = component.getData('multiSelectedItems');
					for(var v =0; v<multiSelectedItems.length ;v++){
						multiSelectedItems[v].style.visibility = "hidden";
					}
					var elem = document.elementFromPoint(placeholderOffset.left,placeholderOffset.top - 4);
					for(var v =0; v<multiSelectedItems.length ;v++){
						multiSelectedItems[v].style.visibility = "visible";
					}
					// console.log(elem);
					var parentListOfObjects = multiSelectedItems[0].parentElement.id == "sortableSec" ? "ltPropAvailablelist" : "ltPropSelectedlist";
					var parentListOfPlaceholder = placeholder.parentElement.id == "sortableSec" ? "ltPropAvailablelist" : "ltPropSelectedlist";
					var objects = [];
					for(var v = 0; v <multiSelectedItems.length ; v++){
						objects.push(component.getElement(multiSelectedItems[v]));
					}
					for(var i = 0 ; i < objects.length ; i++){
						Lyte.arrayUtils(component.getData(parentListOfObjects),'removeAt',component.getElementPosition(component.getData(parentListOfObjects),objects[i]),1);
					}
					var prevEle = placeholder.previousElementSibling;
					while(prevEle && prevEle.tagName == "TEMPLATE"){
						prevEle = prevEle.previousElementSibling;
					}
					if(prevEle){
						Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'insertAt',component.getElementPosition(component.getData(parentListOfPlaceholder),component.getElement(prevEle))+1,objects);
					}
					else{
						var nextEle = placeholder.nextElementSibling;
						while(nextEle && nextEle.tagName == "TEMPLATE"){
							nextEle = nextEle.nextElementSibling;
						}
						if(nextEle){
							Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'insertAt',component.getElementPosition(component.getData(parentListOfPlaceholder),component.getElement(nextEle)),objects);
						}
						else{
							Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'push',objects);
						}
					}

					placeholder.parentElement.removeChild(placeholder);
					component.setData('multiSelectedItems',[]);
					component.setData('prevMode','');
					component.setData('keyPressed',false);
					component.setData('keyValue','');
					component.setData('placeholder','');
					component.generateArray();
					prevTop = 0;
				}
				else{
					var div = component.getData('div');
					var elemData = component.getElement(div);
					// component.getData('placeholder').parentElement.replaceChild(div,component.getData('placeholder'));
					var placeholder = component.getData('placeholder');
					var prevEle = placeholder.previousElementSibling;
					var parentListOfDiv = div.parentElement.id == 'sortableSec' ? "ltPropAvailablelist" : "ltPropSelectedlist";
					var parentListOfPlaceholder = placeholder.parentElement.id == 'sortableSec' ? "ltPropAvailablelist" : "ltPropSelectedlist";
					while(prevEle && prevEle.tagName == "TEMPLATE"){
						prevEle = prevEle.previousElementSibling;
					}
					if(prevEle){
						Lyte.arrayUtils(component.getData(parentListOfDiv),'removeAt',component.getElementPosition(component.getData(parentListOfDiv),elemData),1);
						Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'insertAt',component.getElementPosition(component.getData(parentListOfPlaceholder),component.getElement(prevEle))+1,elemData);
					}
					else{
						var nextEle = placeholder.nextElementSibling;
						while(nextEle && (nextEle.tagName == "TEMPLATE" || nextEle.isEqualNode(div))){
							nextEle = nextEle.nextElementSibling;
						}
						if(nextEle){
							Lyte.arrayUtils(component.getData(parentListOfDiv),'removeAt',component.getElementPosition(component.getData(parentListOfDiv),elemData),1);
							Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'insertAt',component.getElementPosition(component.getData(parentListOfPlaceholder),component.getElement(nextEle)),elemData);
						}
						else{
							Lyte.arrayUtils(component.getData(parentListOfDiv),'removeAt',component.getElementPosition(component.getData(parentListOfDiv),elemData),1);
							Lyte.arrayUtils(component.getData(parentListOfPlaceholder),'push',elemData);
						}
					}
					if(component.$node.querySelector('#sortableSec').contains(component.$node.querySelector('#dummy'))){
			    		component.$node.querySelector('#sortableSec').removeChild(component.$node.querySelector('#dummy'));
			    	}
			    	if( component.getData('ltPropDraggable') && component.$node.querySelector('#dropSec').contains(component.$node.querySelector('#dummy'))){
			    		component.$node.querySelector('#dropSec').removeChild(component.$node.querySelector('#dummy'));
			    	}
			    	// component.removeStyle(div);
			    	// div.classList.remove('lyteDraggableElem');
					component.removeDropable(div);
				    component.generateArray();
				}
				component.onDropFunction(event);
			}
			else{
				if(component.getData('ltPropMultiselect') && component.getData('multiSelectedItems').length > 1 ){
					var multiSelectedItems = component.getData('multiSelectedItems');
					for(var i = 0; i<multiSelectedItems.length;i++){
						component.removeStyle(multiSelectedItems[i]);
						multiSelectedItems[i].classList.remove('lyteDraggableElem');
					}
					component.removeDropableMultiple(multiSelectedItems);
					component.setData('multiSelectedItems',[]);
					component.setData('prevMode','');
					component.setData('keyPressed',false);
					component.setData('keyValue','');
					component.setData('placeholder','');
					prevTop = 0;
				}
				else{
					component.removeStyle(component.getData('div'));
			    	component.getData('div').classList.remove('lyteDraggableElem');
					component.removeDropable(component.getData('div'));
				}
				component.getData('placeholder').remove();
			}
		}
		else{
			var div = component.getData('div');
			component.getData('placeholder').parentElement.replaceChild(div,component.getData('placeholder'));
			if(component.$node.querySelector('#sortableSec').contains(component.$node.querySelector('#dummy'))){
	    		component.$node.querySelector('#sortableSec').removeChild(component.$node.querySelector('#dummy'));
	    	}
	    	if( component.getData('ltPropDraggable') && component.$node.querySelector('#dropSec').contains(component.$node.querySelector('#dummy'))){
	    		component.$node.querySelector('#dropSec').removeChild(component.$node.querySelector('#dummy'));
	    	}
			component.removeStyle(div);
			if(component.getData('checkSelection')){
				var keyValue = component.getData('keyValue');
				if(keyValue == 91 || keyValue == 93 || keyValue == 224){
					div.classList.remove('lyteDraggableElem');
					component.removeFromArray(div);
				}
				if(keyValue == 16){
					component.removeClass();
					component.setData('multiSelectedItems',[]);
					component.addToArray(div,"multiple");
					component.setData('prevMode','multiple');
				}
				if(keyValue == 0){
					component.removeClass();
					component.setData('multiSelectedItems',[]);
					component.getData('multiSelectedItems').push(div);
					// component.setData('multiSelectedItems',);
					div.classList.add('lyteDraggableElem');
					component.setData('prevMode','single');
				}
				component.setData('checkSelection',false);
			}
		}
	}
	else{
		var selectedElems = document.querySelectorAll('.lyteDraggableElem');
		if(selectedElems){
			for(var i = 0;i<selectedElems.length;i++){
				selectedElems[i].classList.remove('lyteDraggableElem');
			}
		}
	}
},false);

document.addEventListener('mousemove',function(event){
	//console.log("Here mouse move");
	var component;
	var target = event.target;
	while(target.parentElement){
		//console.log(target.parentElement);
		target = target.parentElement;
		if(target.tagName.toLowerCase() == 'lyte-dragdrop'){
			component=target.component;
			break;
		}
	}
	//component = component.component;
	if(component && component.getData('isDown')){
		component.setData('isMoved',true);
		// if(component.getData('ltPropDraggable')){
			var div = component.getData('div');
			var parentOffset = div.offsetParent.getBoundingClientRect();
			var divOffset = div.getBoundingClientRect();
			var width = divOffset.width;
			var height = divOffset.height;
			mousePosition = {
	            x : event.clientX,
	            y : event.clientY
	        };
	        div.style.left = (mousePosition.x - component.getData('offset')[0]) - parentOffset.left + 'px';
		    div.style.top  = (mousePosition.y - component.getData('offset')[1]) - parentOffset.top + 'px';
			if(component.getData('ltPropMultiselect') && component.getData('multiSelectedItems').length > 1){
			
				var multiSelectedItems = component.getData('multiSelectedItems');
				var index = multiSelectedItems.indexOf(div);
				
		        for(var v = index-1 ; v >= 0 ; v--){
		        	multiSelectedItems[v].style.left = div.offsetLeft + 'px' ;
		        	multiSelectedItems[v].style.top = (multiSelectedItems[v+1].offsetTop - height) + 'px';
		        	// multiSelectedItems[v].style.zIndex = 1001;
		        	multiSelectedItems[v].style.boxSizing = "border-box";
		        	multiSelectedItems[v].style.width = width + 'px';
		        	multiSelectedItems[v].style.height = height + 'px';
		        	multiSelectedItems[v].style.position = "absolute";
		        	multiSelectedItems[v].classList.add('lyteDraggableElem');
		        }
		        for(var v = index+1 ; v < multiSelectedItems.length ; v++){
		        	multiSelectedItems[v].style.left = div.offsetLeft + 'px';
		        	multiSelectedItems[v].style.top = (multiSelectedItems[v-1].offsetTop + height) + 'px';
		        	// multiSelectedItems[v].style.zIndex = 1001;
		        	multiSelectedItems[v].style.boxSizing = "border-box";
		        	multiSelectedItems[v].style.width = width + 'px';
		        	multiSelectedItems[v].style.height = height + 'px';
		        	multiSelectedItems[v].style.position = "absolute";
		        	multiSelectedItems[v].classList.add('lyteDraggableElem');
		        }

		        var placeholder = component.getData('placeholder');
		        var totalHeight = multiSelectedItems.length * height;
		        if(totalHeight > placeholder.getBoundingClientRect().height){
		        	if(document.getElementById('sortableSec').contains(document.getElementById('dummy'))){
			    		document.getElementById('sortableSec').removeChild(document.getElementById('dummy'));
			    	}
			    	if(component.getData('ltPropDraggable') && document.getElementById('dropSec').contains(document.getElementById('dummy'))){
			    		document.getElementById('dropSec').removeChild(document.getElementById('dummy'));
			    	}
			    	placeholder.style.height = totalHeight + 'px';
			    	placeholder.classList.add('lyteDragDropDropable');
			    	component.setData('placeholder',placeholder);
			    	div.parentElement.insertBefore(component.getData('placeholder'),div);
		        }
		        var top = component.getTopNBottom('top');
		        var bottom = component.getTopNBottom('bottom');
		        var placeholderOffset = placeholder.getBoundingClientRect();
		        var placeholderParentOffset = placeholder.parentElement.getBoundingClientRect();
		        divOffset = div.getBoundingClientRect();
		        
		        //for scrolling top or bottom
		        if(top < placeholderParentOffset.top){
		        	// console.log("scrolling up");
		        	if((placeholder.parentElement.scrollTop > 0) && (placeholder.parentElement.scrollTop <= (placeholder.parentElement.scrollHeight - placeholderParentOffset.height)) ){
		        		placeholder.parentElement.scrollTop -= placeholderParentOffset.top - top;
		        	}
		        }
		        if(bottom > placeholderParentOffset.bottom){
		        	// console.log("scrolling down");
		        	if(placeholder.parentElement.scrollTop <= placeholder.parentElement.scrollHeight - placeholderParentOffset.height ){
		        		placeholder.parentElement.scrollTop += bottom - placeholderParentOffset.bottom;
		        	}
		        }

		        component.makeDroppableMultiple(multiSelectedItems);

		        elementAtLeft = document.elementFromPoint(divOffset.left - 1, event.clientY);
		        elementAtRight = document.elementFromPoint(divOffset.right + 1, event.clientY);

		        // console.log("leftEle" , elementAtLeft);
		        // console.log("rightEle" , elementAtRight);
		        
		        dropablePlaceLeft = elementAtLeft.closest('.dropable');
		        dropablePlaceRight = elementAtRight.closest('.dropable');

		        if(!component.getData('left') && dropablePlaceLeft && (divOffset.left < (dropablePlaceLeft.getBoundingClientRect().right - divOffset.width / 2))){
					// console.log("inside left");
					
					if(divOffset.bottom > dropablePlaceLeft.getBoundingClientRect().bottom){
						
						dropablePlaceLeft.after(placeholder);
					}
					else{
						
						dropablePlaceLeft.parentElement.insertBefore(placeholder,dropablePlaceLeft);
					}
					component.setData('left',true);
					component.setData('right',false);
					side = "left";
				}
				else if(!component.getData('right') && dropablePlaceRight && (divOffset.right > (dropablePlaceRight.getBoundingClientRect().left + divOffset.width / 2))){
					// console.log("inside right");
					if(divOffset.bottom > dropablePlaceRight.getBoundingClientRect().bottom){
						
						dropablePlaceRight.after(placeholder);
					}
					else{
						
						dropablePlaceRight.parentElement.insertBefore(placeholder,dropablePlaceRight);
					}
					component.setData('right',true);
					component.setData('left',false);
					side = "right";
					
				}
				else if(elementAtLeft && component.checkElement(elementAtLeft) && component.checkPossiblePosition(elementAtLeft,"multiple") && (divOffset.left < (elementAtLeft.getBoundingClientRect().right - divOffset.width / 2))){
					
					elementAtLeft.appendChild(placeholder);
					component.setData('left',false);
					component.setData('right',false);
				}
				else if(elementAtRight && component.checkElement(elementAtRight) && component.checkPossiblePosition(elementAtRight,"multiple") && (divOffset.right > (elementAtRight.getBoundingClientRect().left + divOffset.width / 2))){
					
					elementAtRight.appendChild(placeholder);
					component.setData('left',false);
					component.setData('right',false);
				}
				else{
					// console.log("inside else");
					if(top < prevTop){
						// if(side){
							if(side == "left"){
								elemBelow = document.elementFromPoint(divOffset.left,top-1);
							}
							else if(side == "right"){
								elemBelow = document.elementFromPoint(divOffset.right,top-1);	
							}
							else{
								elemBelow = document.elementFromPoint(event.clientX,top-1);
							}
						// }
		        		if(!elemBelow){
		        			return;
		        		}
		        		dropablePlace = elemBelow.closest('.dropable');
		        		// console.log(dropablePlace);
		        		if(dropablePlace && (divOffset.left > (dropablePlace.parentElement.getBoundingClientRect().right - divOffset.width / 2) ||
							divOffset.right <(dropablePlace.parentElement.getBoundingClientRect().left + divOffset.width / 2))){
							// console.log("getting return");
							return
						}
						// console.log("top",dropablePlace);
		        		if(dropablePlace && dropablePlace != component.$node.querySelector('#dummy')){
		        			if(top < dropablePlace.getBoundingClientRect().bottom - 16){
		        				// console.log("going up");
		        	
						    	dropablePlace.parentElement.insertBefore(placeholder,dropablePlace);
		        			}
		        		}
		        		if((elemBelow.id === "sortableSec" || elemBelow.id === "dropSec") && component.checkIfDroppable(elemBelow,"multiple")){
		        			// console.log("top",elemBelow);
		        			elemBelow.appendChild(placeholder);
		        		}
			        }
		        	else{
		        		
							if(side == "left"){
								elemBelow = document.elementFromPoint(divOffset.left,bottom+1);
							}
							else if(side == "right"){
								elemBelow = document.elementFromPoint(divOffset.right,bottom+1);	
							}
							else{
								elemBelow = document.elementFromPoint(event.clientX,bottom+1);
							}
						
		        		if(!elemBelow){
		        			return;
		        		}
		        		
		        		dropablePlace = elemBelow.closest('.dropable');
		        		if(dropablePlace && (divOffset.left > (dropablePlace.parentElement.getBoundingClientRect().right - divOffset.width / 2) ||
							divOffset.right <(dropablePlace.parentElement.getBoundingClientRect().left + divOffset.width / 2))){
							// console.log("getting return");
							return
						}
						// console.log("down",dropablePlace);
		        		if(dropablePlace && dropablePlace != component.$node.querySelector('#dummy')){
		        			if(bottom >= dropablePlace.getBoundingClientRect().top + 16){
		        				// console.log('going down');
		        	
						    	dropablePlace.after(placeholder);
		        			}
		        		}
		        		if((elemBelow.id === "sortableSec" || elemBelow.id === "dropSec") && component.checkIfDroppable(elemBelow,"multiple")){
		        			// console.log("down",elemBelow);
		        			elemBelow.appendChild(placeholder);
		        		}
		        	}
				}
				// console.log("left ====>" + component.getData('placeholder').getBoundingClientRect().left);
		  //       console.log("top ====>" + component.getData('placeholder').getBoundingClientRect().top);
		        prevTop = top;
			}
			

			/*---Single drag and drop----*/
			else{
				// var div = component.getData('div');
				// mousePosition = {
		  //           x : event.clientX,
		  //           y : event.clientY
		  //       };
		        // var parent = div.offsetParent;
		        // div.style.left = (mousePosition.x - component.getData('offset')[0]) - parentOffset.left + 'px';
		        // div.style.top  = (mousePosition.y - component.getData('offset')[1]) - parentOffset.top + 'px';
		        //div.parentNode.insertBefore(component.getData('placeholder'), div);
		        var placeholder = component.getData('placeholder');
		        var placeholderParentOffset = placeholder.parentElement.getBoundingClientRect();
		        divOffset = div.getBoundingClientRect();
		        if(divOffset.top < placeholderParentOffset.top){
		        	if((placeholder.parentElement.scrollTop > 0) && (placeholder.parentElement.scrollTop <= (placeholder.parentElement.scrollHeight - placeholderParentOffset.height)) ){
		        		placeholder.parentElement.scrollTop -= placeholderParentOffset.top - divOffset.top;
		        	}
		        }
		        if(divOffset.bottom > placeholderParentOffset.bottom){
		        	if(placeholder.parentElement.scrollTop <= placeholder.parentElement.scrollHeight - placeholderParentOffset.height ){
		        		placeholder.parentElement.scrollTop += divOffset.bottom - placeholderParentOffset.bottom;
		        	}
		        }

		        component.makeDroppable(div);

		        elementAtLeft = document.elementFromPoint(divOffset.left - 1, event.clientY);
		        elementAtRight = document.elementFromPoint(divOffset.right + 1, event.clientY);

		        // console.log("leftEle" , elementAtLeft);
		        // console.log("rightEle" , elementAtRight);
		        droppableLeft = elementAtLeft.closest('.dropable');
		        droppableRight = elementAtRight.closest('.dropable');


		        maxAllowableWidth = divOffset.width / 2;

		        if(droppableLeft && (divOffset.left < (droppableLeft.getBoundingClientRect().right - maxAllowableWidth))){
		        	// console.log("inside left");
		        	if(divOffset.bottom > droppableLeft.getBoundingClientRect().bottom){
		        		droppableLeft.after(placeholder);
		        	}
		        	else{
		        		droppableLeft.parentElement.insertBefore(placeholder,droppableLeft);
		        	}
		        }
		        else if(droppableRight && (divOffset.right > (droppableRight.getBoundingClientRect().left + maxAllowableWidth))){
		        	// console.log("inside right");
		        	if(divOffset.bottom > droppableRight.getBoundingClientRect().bottom){
		        		droppableRight.after(placeholder);
		        	}
		        	else{
		        		droppableRight.parentElement.insertBefore(placeholder,droppableRight);
		        	}
		        }
		        else if(elementAtLeft && component.checkElement(elementAtLeft) && component.checkPossiblePosition(elementAtLeft,"single") && (divOffset.left < (elementAtLeft.getBoundingClientRect().right - maxAllowableWidth))){
		        	// console.log("inside parent left");
		        	elementAtLeft.appendChild(placeholder);
		        }
		        else if(elementAtRight && component.checkElement(elementAtRight) && component.checkPossiblePosition(elementAtRight,"single") && (divOffset.right > (elementAtRight.getBoundingClientRect().left + maxAllowableWidth))){
		        	// console.log("inside parent right");
		        	elementAtRight.appendChild(placeholder);
		        }
		        else{
		        	// console.log("inside here");
		        	div.style.visibility = "hidden";
		        	elemBelow = document.elementFromPoint(event.clientX,event.clientY);
		        	div.style.visibility = "visible";

		        	if(!elemBelow){
		        		return;
		        	}

		        	dropablePlace = elemBelow.closest('.dropable');
		        	if(dropablePlace && (divOffset.left > (dropablePlace.getBoundingClientRect().right - maxAllowableWidth) || divOffset.right < (dropablePlace.getBoundingClientRect().left + maxAllowableWidth))){
		        		return;
		        	}
		        	else{
		        		if(dropablePlace && dropablePlace != component.$node.querySelector('#dummy')){
		        			if(divOffset.top < dropablePlace.getBoundingClientRect().top){
		        				dropablePlace.parentElement.insertBefore(placeholder,dropablePlace);
		        			}
		        			if(divOffset.bottom > dropablePlace.getBoundingClientRect().bottom){
		        				dropablePlace.after(placeholder);
		        			}
		        		}
		        	}
		        	if((elemBelow.id === "sortableSec" || elemBelow.id === "dropSec") && component.checkIfDroppable(elemBelow,"single")){
	        			// console.log(elemBelow);
	        			elemBelow.appendChild(placeholder);
	        		}
		        }
				component.getData('placeholder').classList.add('lyteDragDropDropable');
			}
		component.onDragFunction(event);
	}


},false);

// document.addEventListener('dragstart',function(event){
// 	event.preventDefault();
// },false);


document.addEventListener('keydown',function(event){
	var component = document.querySelectorAll('lyte-dragdrop');
	for(var v = 0; v<component.length; v++){
		var elem = component[v].component;
		elem.setData('keyPressed',true);
		var keyValue = event.which;
		elem.setData('keyValue',keyValue);
		// console.log(keyValue);
	}
	
},false);

document.addEventListener('keyup',function(event){
	var component = document.querySelectorAll('lyte-dragdrop');
	for(var v = 0; v<component.length; v++){
		var elem = component[v].component;
		elem.setData('keyPressed',false);
		elem.setData('keyValue',0);
	}
	
},false);

};


/* wrap show hide in another function */
/* 
issues:  backspace selects an item
multiselect callout
setproperwidth
enter on hover causes a problem
ltPropShow might invoke callbacks more than once because we are closing it and opening it
*/
Lyte.Component.register( 'lyte-dropdown', {
_template:"<template tag-name=\"lyte-dropdown\">\t<template is=\"if\" value=\"{{expHandlers(ltPropHover,'==',true)}}\"><template case=\"true\">\t\t<template is=\"if\" value=\"{{expHandlers(multiple,'==',true)}}\"><template case=\"true\">\t\t\t<template is=\"if\" value=\"{{expHandlers(search,'==',true)}}\"><template case=\"true\">\t\t\t\t<template is=\"if\" value=\"{{expHandlers(drophead,'==','noyield')}}\"><template case=\"true\">\t\t\t\t\t<lyte-drop-button>\t\t\t\t\t\t<div class=\"lyteMultiselect\">\t\t\t\t\t\t\t<template is=\"if\" value=\"{{expHandlers(allSelected.length,'!==',0)}}\"><template case=\"true\">\t\t\t\t\t\t\t\t<ul class=\"lyteMultipleSelect\">\t\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{allSelected}}\" item=\"item\" index=\"indexVal\">\t\t\t\t\t\t\t\t\t\t<li data-value=\"{{item['value']}}\">\t\t\t\t\t\t\t\t\t\t\t<span class=\"lyteDropdownVisible\">{{item['display']}}</span>\t\t\t\t\t\t\t\t\t\t\t<lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove>\t\t\t\t\t\t\t\t\t\t</li>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t</ul>\t\t\t\t\t\t\t</template></template>\t\t\t\t\t\t\t<input type=\"text\" placeholder=\"{{ltPropPlaceholder}}\" class=\"lyteDropdownTextField\" autocomplete=\"off\" tabindex=\"{{ltPropTabindex}}\" onclick=\"{{action('showHide',event)}}\">\t\t\t\t\t\t</div>\t\t\t\t\t</lyte-drop-button>\t\t\t\t</template><template case=\"false\">\t\t\t\t</template></template>\t\t\t</template><template case=\"false\">\t\t\t\t<template is=\"if\" value=\"{{expHandlers(drophead,'==','noyield')}}\"><template case=\"true\">\t\t\t\t\t<div class=\"lyteDummyEventContainer\" onclick=\"{{action('showHide',event)}}\" onkeyup=\"{{action('checkKey',event)}}\" tabindex=\"{{ltPropTabindex}}\">\t\t\t\t\t\t<lyte-drop-button>\t\t\t\t\t\t\t<template is=\"if\" value=\"{{expHandlers(allSelected.length,'==',0)}}\"><template case=\"true\">\t\t\t\t\t\t\t\t<span class=\"lyteDropPlaceholderMultiple\">{{ltPropPlaceholder}}</span>\t\t\t\t\t\t\t</template></template>\t\t\t\t\t\t\t<ul class=\"lyteMultipleSelect\">\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{allSelected}}\" item=\"item\" index=\"indexVal\">\t\t\t\t\t\t\t\t\t<li data-value=\"{{item['value']}}\">\t\t\t\t\t\t\t\t\t\t<span class=\"lyteDropdownVisible\">{{item['display']}}</span>\t\t\t\t\t\t\t\t\t\t<lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove>\t\t\t\t\t\t\t\t\t</li>\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</ul>\t\t\t\t\t\t</lyte-drop-button>\t\t\t\t\t</div>\t\t\t\t</template><template case=\"false\">\t\t\t\t</template></template>\t\t\t</template></template>\t\t</template><template case=\"false\">\t\t\t<div onmouseenter=\"{{action('showHide',event,'enter')}}\" onmouseleave=\"{{action('closeIt',event)}}\" class=\"lyteDummyEventContainer\" tabindex=\"{{ltPropTabIndex}}\" style=\"\">\t\t\t\t<template is=\"if\" value=\"{{expHandlers(drophead,'==','noyield')}}\"><template case=\"true\">\t\t\t\t\t<lyte-drop-button>\t\t\t\t\t\t<template is=\"if\" value=\"{{ltPropDisplayValue}}\"><template case=\"true\">\t\t\t\t\t\t\t<span class=\"lyteMarginRight\">{{ltPropDisplayValue}}</span>\t\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t\t\t<span class=\"lyteDropPlaceholderNormal\">{{ltPropPlaceholder}}</span>\t\t\t\t\t\t</template></template>\t\t\t\t\t\t<lyte-icon class=\"{{ltPropIconClass}}\"></lyte-icon>\t\t\t\t\t</lyte-drop-button>\t\t\t\t</template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(drophead,'==','yield')}}\"><template case=\"true\">\t\t\t\t\t\t\t\t\t</template></template></template></template>\t\t\t</div>\t\t</template></template>\t</template><template case=\"false\">\t\t<template is=\"if\" value=\"{{expHandlers(multiple,'==',true)}}\"><template case=\"true\">\t\t\t<template is=\"if\" value=\"{{expHandlers(search,'==',true)}}\"><template case=\"true\">\t\t\t\t<template is=\"if\" value=\"{{expHandlers(drophead,'==','noyield')}}\"><template case=\"true\">\t\t\t\t\t<lyte-drop-button onclick=\"{{action('showHide',event)}}\">\t\t\t\t\t\t<div class=\"lyteMultiselect\">\t\t\t\t\t\t\t<template is=\"if\" value=\"{{expHandlers(allSelected.length,'!==',0)}}\"><template case=\"true\">\t\t\t\t\t\t\t\t<ul class=\"lyteMultipleSelect\">\t\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{allSelected}}\" item=\"item\" index=\"indexVal\">\t\t\t\t\t\t\t\t\t\t<li data-value=\"{{item['value']}}\">\t\t\t\t\t\t\t\t\t\t\t<span class=\"lyteDropdownVisible\">{{item['display']}}</span>\t\t\t\t\t\t\t\t\t\t\t<lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove>\t\t\t\t\t\t\t\t\t\t</li>\t\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t\t</ul>\t\t\t\t\t\t\t</template></template>\t\t\t\t\t\t\t<input type=\"text\" placeholder=\"{{ltPropPlaceholder}}\" class=\"lyteDropdownTextField\" autocomplete=\"off\" tabindex=\"{{ltPropTabindex}}\">\t\t\t\t\t\t</div>\t\t\t\t\t</lyte-drop-button>\t\t\t\t</template><template case=\"false\">\t\t\t\t\t<div class=\"lyteDummyEventContainer\" tabindex=\"{{ltPropTabIndex}}\" style=\"\" onclick=\"{{action('showHide',event)}}\">\t\t\t\t\t</div>\t\t\t\t</template></template>\t\t\t</template><template case=\"false\">\t\t\t\t<div class=\"lyteDummyEventContainer\" onclick=\"{{action('showHide',event)}}\" onkeyup=\"{{action('checkKey',event)}}\" tabindex=\"{{ltPropTabindex}}\">\t\t\t\t<template is=\"if\" value=\"{{expHandlers(drophead,'==','noyield')}}\"><template case=\"true\">\t\t\t\t\t<lyte-drop-button>\t\t\t\t\t\t<template is=\"if\" value=\"{{expHandlers(allSelected.length,'==',0)}}\"><template case=\"true\">\t\t\t\t\t\t\t<span class=\"lyteDropPlaceholderMultiple\">{{ltPropPlaceholder}}</span>\t\t\t\t\t\t</template></template>\t\t\t\t\t\t<ul class=\"lyteMultipleSelect\">\t\t\t\t\t\t\t<template is=\"for\" items=\"{{allSelected}}\" item=\"item\" index=\"indexVal\">\t\t\t\t\t\t\t\t<li data-value=\"{{item['value']}}\">\t\t\t\t\t\t\t\t\t<span class=\"lyteDropdownVisible\">{{item['display']}}</span>\t\t\t\t\t\t\t\t\t<lyte-drop-remove class=\"lyteCloseIcon\"></lyte-drop-remove>\t\t\t\t\t\t\t\t</li>\t\t\t\t\t\t\t</template>\t\t\t\t\t\t</ul>\t\t\t\t\t</lyte-drop-button>\t\t\t\t</template><template case=\"false\">\t\t\t\t</template></template>\t\t\t\t</div>\t\t\t</template></template>\t\t</template><template case=\"false\">\t\t\t<div onclick=\"{{action('showHide',event)}}\" class=\"lyteDummyEventContainer\" tabindex=\"{{ltPropTabIndex}}\" style=\"\">\t\t\t\t<template is=\"if\" value=\"{{expHandlers(drophead,'==','noyield')}}\"><template case=\"true\">\t\t\t\t\t<lyte-drop-button>\t\t\t\t\t\t<template is=\"if\" value=\"{{ltPropDisplayValue}}\"><template case=\"true\">\t\t\t\t\t\t\t<span class=\"lyteMarginRight\">{{ltPropDisplayValue}}</span>\t\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t\t\t<span class=\"lyteDropPlaceholderNormal\">{{ltPropPlaceholder}}</span>\t\t\t\t\t\t</template></template>\t\t\t\t\t\t<lyte-icon class=\"{{ltPropIconClass}}\"></lyte-icon>\t\t\t\t\t</lyte-drop-button>\t\t\t\t</template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(drophead,'==','yield')}}\"><template case=\"true\">\t\t\t\t\t\t\t\t\t</template></template></template></template>\t\t\t</div>\t\t</template></template>\t</template></template>\t\t<template is=\"if\" value=\"{{expHandlers(ltPropHover,'==',false)}}\"><template case=\"true\">\t\t\t<template is=\"if\" value=\"{{expHandlers(dropbody,'==','noyield')}}\"><template case=\"true\">\t\t\t\t<lyte-drop-box class=\"lyteDropdownHidden\">\t\t\t\t<lyte-drop-body>\t\t\t\t\t<template is=\"for\" items=\"{{ltPropOptions}}\" item=\"item\" index=\"indexVal\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(item)}}\"><template case=\"true\">\t\t\t\t\t\t\t<lyte-drop-group>\t\t\t\t\t\t\t\t<lyte-drop-label>{{lyteUiReturnOnlyKey(item)}}</lyte-drop-label>\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{lyteUiReturnValueBy(item,lyteUiReturnOnlyKey(item))}}\" item=\"subitem\" index=\"indexval\">\t\t\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIsObject(subitem)}}\"><template case=\"true\">\t\t\t\t\t\t\t\t\t\t<lyte-drop-item data-value=\"{{subitem[ltPropSystemValue]}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,subitem[ltPropSystemValue])}}\">{{subitem[ltPropUserValue]}}</lyte-drop-item>\t\t\t\t\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t\t\t\t\t\t<lyte-drop-item data-value=\"{{subitem}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,subitem)}}\">{{subitem}}</lyte-drop-item>\t\t\t\t\t\t\t\t\t</template></template>\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</lyte-drop-group>\t\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIsObject(item)}}\"><template case=\"true\">\t\t\t\t\t\t\t\t<lyte-drop-item data-value=\"{{item[ltPropSystemValue]}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,item[ltPropSystemValue])}}\">{{item[ltPropUserValue]}}</lyte-drop-item>\t\t\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t\t\t\t<lyte-drop-item data-value=\"{{item}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,item)}}\">{{item}}</lyte-drop-item>\t\t\t\t\t\t\t</template></template>\t\t\t\t\t\t</template></template>\t\t\t\t\t</template>\t\t\t\t\t\t\t\t\t</lyte-drop-body>\t\t\t\t</lyte-drop-box>\t\t\t</template><template case=\"false\">\t\t\t</template></template>\t\t\t<div class=\"lyteLoadMsg\" style=\"display:none;\">Loading</div>\t\t</template><template case=\"false\">\t\t\t<template is=\"if\" value=\"{{expHandlers(dropbody,'==','noyield')}}\"><template case=\"true\">\t\t\t\t<lyte-drop-box>\t\t\t\t<lyte-drop-body>\t\t\t\t\t<template is=\"for\" items=\"{{ltPropOptions}}\" item=\"item\" index=\"indexVal\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(item)}}\"><template case=\"true\">\t\t\t\t\t\t\t<lyte-drop-group>\t\t\t\t\t\t\t\t<lyte-drop-label>lyteUiReturnOnlyKey(item)</lyte-drop-label>\t\t\t\t\t\t\t\t<template is=\"for\" items=\"{{lyteUiReturnValueBy(item,lyteReturnOnlyKey(item))}}\" item=\"subitem\" index=\"indexval\">\t\t\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIsObject(subitem)}}\"><template case=\"true\">\t\t\t\t\t\t\t\t\t\t<lyte-drop-item data-value=\"{{subitem[ltPropSystemValue]}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,subitem[ltPropSystemValue])}}\">{{subitem[ltPropUserValue]}}</lyte-drop-item>\t\t\t\t\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t\t\t\t\t\t<lyte-drop-item data-value=\"{{subitem}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,subitem)}}\">{{subitem}}</lyte-drop-item>\t\t\t\t\t\t\t\t\t</template></template>\t\t\t\t\t\t\t\t</template>\t\t\t\t\t\t\t</lyte-drop-group>\t\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIsObject(item)}}\"><template case=\"true\">\t\t\t\t\t\t\t\t<lyte-drop-item data-value=\"{{item[ltPropSystemValue]}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,item[ltPropSystemValue])}}\">{{item[ltPropUserValue]}}</lyte-drop-item>\t\t\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t\t\t\t<lyte-drop-item data-value=\"{{item}}\" disabled=\"{{lyteUiCheckDisabled(ltPropDisabledList,item)}}\">{{item}}</lyte-drop-item>\t\t\t\t\t\t\t</template></template>\t\t\t\t\t\t</template></template>\t\t\t\t\t</template>\t\t\t\t</lyte-drop-body>\t\t\t\t</lyte-drop-box>\t\t\t</template><template case=\"false\">\t\t\t</template></template>\t\t\t<div class=\"lyteLoadMsg\" style=\"display:none;\">Loading</div>\t\t</template></template>\t\t<lyte-yield yield-name=\"yield\" style=\"display: none;\"></lyte-yield></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]}]}]}},"default":{}},{"type":"attr","position":[1,1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[1,1,3,1]},{"type":"for","position":[1,1,3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]}]},{"type":"componentDynamic","position":[1,1]}]},"false":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]}]}]}},"default":{}},{"type":"attr","position":[1,1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[1,3,1]},{"type":"for","position":[1,3,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,3]}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[1,3]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}},"default":{}}]}},"default":{}}]}},"default":{}},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1,1]},{"type":"for","position":[1,1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[]}},"default":{}}]}},"default":{}},{"type":"insertYield","position":[5]}],
_observedAttributes :["changeItToInvoke","dummy1","dummy2","ltPropRemoveMultiple","ltPropYield","ltPropType","ltPropTabindex","ltPropShow","ltPropFreeze","ltPropOptions","ltPropUserValue","ltPropSystemValue","ltPropPosition","ltPropIconClass","ltPropSelected","ltPropCallout","ltPropPlaceholder","ltPropDisabled","ltPropHover","ltPropNoResult","ltPropInputClass","allSelected","ltPropBoundary","pos","firePos","ltPropAjaxRequest","firstRequest","ltPropDisplayValue","ltPropDisabledList","ltPropAnimate","ltPropSetPos"],
	init: function() {
		var type = this.getData( 'ltPropType' ),
		sel = this.getData( 'ltPropSelected' );
		this._close = this.closeDrop1.bind( this )

		// if( !Lyte.Component.registeredHelpers.lyteUiIsEmptyObject( this.getData( 'ltPropAjaxRequest' ) ) ) {
		// 	this.fetchData();
		// }

		if( !document.getElementById( 'lytedropdownfreezelayer' ) ) {
			var fzl ;
			fzl = document.createElement( 'div' );
			fzl.setAttribute( 'id', 'lytedropdownfreezelayer' );
			fzl.style.display = 'none';
			fzl.style.opacity = '0.01';
			fzl.style.background = '#fff';
			document.body.appendChild( fzl );
		}

		// Create toggle function
		this.$node.toggle = function( event, type ) {
			var val = event ? event : undefined;
			if( this.component.getData( 'ltPropDisabled' ) ) {
				return ;
			}

			this.constructor._actions.showHide.call(this.component, val, type, true);
		}


		if( type.indexOf( 'multiple' ) !== -1 
			|| type.indexOf( 'multisearch' ) !== -1 
		) {
			this.setData( 'multiple', true );
			this.setData( 'allSelected', [] );
			if( !sel ) {
				this.setData( 'ltPropSelected', '[]' );
			}

			if( type.indexOf('multisearch') !== -1 ) {
				this.setData( 'search', true );
			}
		}
	},

	didDestroy: function() {
		var body = this.childComp,
		mut = this.$node.mutobserver;

		if( body ) {
			body.remove();
		}

		if( mut ) {
			mut.disconnect()
		}
	},

	// Do a dfs to find the types of dropdown
	getChildren: function( childs ) {
		var head = this.getData( 'drophead' ),
		body = this.getData( 'dropbody' ),
		tag, i = 0, drop = this.$node;

		if( head === 'yield' && body === 'yield' ) {
			return ;
		}

		for( ; i < childs.length; i++ ) {

			tag = childs[i].tagName;
			if( tag === 'LYTE-DROPDOWN' 
				|| tag === 'TEMPLATE'
			) {
				continue;
			}

			if( tag === 'LYTE-DROP-BOX' ) {
				this.setData( 'dropbody', 'yield' );
				drop.querySelector( 'lyte-drop-box' ).classList.add( 'lyteDropdownHidden' );
			}
			else if( tag === 'LYTE-DROP-BUTTON' ) {
				this.setData( 'drophead', 'yield' );
				LyteComponent.appendChild( drop.querySelector( '.lyteDummyEventContainer' ), drop.querySelector( 'lyte-drop-button' ) );
				i--;
			}
			else {
				this.getChildren( childs[ i ].children );
			}
		}
	},

	didConnect: function() {

		var drop = this.$node,
		link = this.childComp,
		yd = drop.querySelector( 'lyte-yield' ),
		ph = this.getData( 'ltPropPlaceholder' ),
		hover = this.getData( 'ltPropHover' ),
		sel = this.getData( 'ltPropSelected' ),
		options = this.getData( 'ltPropOptions' ),
		type = this.getData( 'ltPropType' ),
		disabled = this.getData( 'ltPropDisabled' ),
		index = this.getData( 'ltPropTabindex' ),
		show = this.getData( 'ltPropShow' ),
		list = this.getData( 'ltPropDisabledList' ),
		disp = this.getData( 'ltPropDisplayValue' ),
		button, box, config, div, span, node, tab, head, body, boxes;


		this.getChildren( yd.children );
		head = this.getData( 'drophead' );
		body = this.getData( 'dropbody' );
		if( head !== 'yield' ) {
			this.setData( 'drophead', head = 'noyield' );
		}

		if( body !== 'yield') {
			this.setData( 'dropbody', body = 'noyield' );
		}

		box = drop.querySelector( 'lyte-drop-box' )

		// Mutation observer
		drop.mutobserver = new MutationObserver( function( mutations ) {
			if( this._prevent ) {
				return
			}
			if( this._hgtRemoval ) {
				delete this._hgtRemoval;
				return
			}
			var dropbox = this.childComp ? this.childComp : drop.querySelector( 'lyte-drop-box' ), ev, i,
			// Added so that users can now set the left and top in onBeforeShow callback without setCss interfering with it.
			manual = this.getData( 'ltPropSetPos' );

			if( manual 
				|| dropbox.classList.contains( 'lyteDropdownHidden' ) 
			) {
				return ;
			}

			if( this.getData( 'multiple' ) ) {
				var notselected = false
				for( i = 0; i < mutations.length; i++ ) {
					var allCases = mutations[i].type == 'childList' 
								   	&& mutations[i].target.tagName == 'LYTE-DROP-ITEM' 
								   	|| mutations[i].attributeName == 'selected' 
								   	|| (
										mutations[i].attributeName == 'class' 
										// Prevent firing when setting class to lyteArrow span
										&& ( !mutations[ i ].target.classList.contains( 'lyteArrow' )

											// Prevent firing when setting the lyteDropdownCurrent class for the lyte-drop-item
											// We want to fire in the other cases
											&& (
												mutations[ i ].target.tagName === 'LYTE-DROP-ITEM' ?
												!this.hasClassToggled( mutations[ i ], 'lyteMenuSelected' )
												: true
											)
										)
									) 
									|| ( 
										mutations[i].attributeName == 'style' 
										&& mutations[i].target.tagName != 'LYTE-DROP-BOX' 
										&& !mutations[i].target.classList.contains( 'lyteArrow' )
									);

					if( allCases ) {
						notselected = true
						break;
					}
				}

				if( notselected ) {
					$L.fastdom.measure( function() {
						// Not putting inside fastdom because it causes a jitter 
						if( this.data.ltPropAnimate ) {
							this._hgtRemoval = true
							this.childComp.querySelector( 'lyte-drop-body' ).style.height = '';
						}
						this.setCss();
						this.openSlideAnimate()
						if( this.getData( 'call' ) && this.getMethods( 'onShow' ) ) {
							ev = this.getData( 'call' );
							ev = ev === true ? undefined : ev;
							this.setData( 'call', null );
							this.executeMethod( 'onShow', ev, this );
						}
					}, this );
				}
			}
			else {
				var notselected = false
				var stylemutations = false
				for( i = 0; i < mutations.length; i++ ) {
					if( mutations[i].attributeName == 'style' 
						&& mutations[i].target.tagName == 'LYTE-DROP-BOX' 
					) {
						stylemutations = true
					}
				}

				for( i = 0; i < mutations.length; i++ ) {
					var allCases = // Fire when new children are added to the dropdown
									mutations[i].type == 'childList' 
									&& mutations[i].target.tagName == 'LYTE-DROP-ITEM' 
									|| (
										mutations[i].attributeName == 'style' 

										// Prevent firing when setting styles to drop-box
										&& mutations[i].target.tagName != 'LYTE-DROP-BOX'

										// Prevent firing when setting styles to lyteArrow 
										&& !mutations[i].target.classList.contains('lyteArrow')
									) 
									|| (
										mutations[i].attributeName == 'class'
										&& mutations[ i ].type === 'attributes'

										// Prevent firing when setting class to lyteArrow span
										&& ( !mutations[i].target.classList.contains( 'lyteArrow' )

											// Prevent firing when setting the lyteDropdownCurrent class for the lyte-drop-item
											// We want to fire in the other cases
											&& (
												mutations[ i ].target.tagName === 'LYTE-DROP-ITEM' ?
												!this.hasClassToggled( mutations[ i ], 'lyteMenuSelected' )
												: true
											)
										)
									);

					// If a class mutation happened,check if there is a style mutation in LYTE-DROP-BOX. If there is then do nothing
					if( allCases 
						&& mutations[ i ].attributeName == 'class' 
						&& mutations[ i ].target.tagName == 'LYTE-DROP-BOX' 
					) {
						if( !stylemutations ) {
							notselected = true
							break;
						}
					}
					else if( allCases && !stylemutations ) {
						notselected = true
					}
				}

				if( notselected ) {
					$L.fastdom.measure( function() { 
						// Not putting inside fastdom because it causes a jitter 
						if( this.data.ltPropAnimate ) {
							this._hgtRemoval = true
							this.childComp.querySelector( 'lyte-drop-body' ).style.height = '';
						}
						this.setCss();
						this.openSlideAnimate()
						if( this.getData( 'call' ) && this.getMethods( 'onShow' ) ) {
							ev = this.getData( 'call' );
							ev = ev === true ? undefined : ev;
							this.setData( 'call', null );
							this.executeMethod( 'onShow', ev, this );
						}
					}, this );
				}
			}

			if( this.getData( 'call' ) && this.getMethods( 'onShow' ) ) {
				ev = this.getData( 'call' );
				ev = ev === true ? undefined : ev;
				this.setData( 'call', null );
				this.executeMethod( 'onShow', ev, this );
			}
		}.bind( this ) );

		config = { 
			attributes: true,
			childList : true,
			subtree: true,
			attributeOldValue: true 
		};

		drop.mutobserver.observe( box, config );
		// Mutation observer ends

		div = document.createElement( 'div' );
		div.setAttribute( 'class', 'lyteDropdownNoResult' );
		div.textContent = _lyteUiUtils.i18n( 'no.results.found' );
		div.style.display = 'none';

		box.appendChild( div );
		box.addEventListener( 'click', function( event ) {
			this.actions.processElements.call( this, event );
		}.bind( this ) );

		if( hover ) {
			box.addEventListener( 'mouseout', function( event ) {
				this.actions.closeIt.call( this, event );
			}.bind( this ) );
		}

		span = document.createElement( 'span' );
		span.setAttribute( 'class', 'lyteArrow' );
		box.insertBefore( span, box.children[ 0 ] );

		//We need to set the first value in the dropdown as the selected one
		if( !ph && !disp && !sel && options.length > 0 ) {
			var firstElement = options[ 0 ],
			flag = false,
			value;

			if( firstElement.constructor == Object ) {
           		if( Object.keys( firstElement ).length == 1 ) {
	              	value = firstElement[ Object.keys( firstElement )[ 0 ] ];
	              	if( value.constructor == Array ) {
	                   	flag = true
	               	}
	            }   
           	}

           	if( flag ) {
           		if ( Object.prototype.toString.call( value[ 0 ] ) === '[object Object]' ) {
           			this.setData( 'ltPropSelected', value[ 0 ][ this.getData( 'ltPropSystemValue' ) ] );
           		}
           		else{
           			this.setData( 'ltPropSelected', value[ 0 ] );
           		}
           	}
           	else{
           		if ( Object.prototype.toString.call( firstElement ) === '[object Object]' ) {
           			this.setData( 'ltPropSelected', firstElement[ this.getData( 'ltPropSystemValue' ) ] );
           		}
           		else {
           			this.setData( 'ltPropSelected', firstElement );
           		}
           	}	
		}
		else if(
			!ph
			&& !disp
			&& !this.getData( 'ltPropSelected' ) 
			&& body == 'yield' 
			&& type !== 'multiple' 
			&& type !== 'multisearch'
		) { 
			boxes = drop.querySelectorAll( 'lyte-drop-body' );
			node = boxes[ boxes.length - 1 ].querySelector( 'lyte-drop-item' );
			if( node ) {
				node.setAttribute( 'selected', true );
			}
		}

		tab = drop.querySelector('[tabindex]');
		if( disabled ) {
			tab.classList.add( 'lyteDropdown-disabled' );
			tab.setAttribute( 'tabindex', -1 );
		}
		else {
			tab.classList.remove( 'lyteDropdown-disabled' )
			tab.setAttribute( 'tabindex', index );
		}

		tab.addEventListener( 'keyup', function( event ) {
			drop.constructor._actions.checkKey.call( this, event );
		}.bind( this ) );

		// Bad way to trigger an observer
		this.setData( 'changeItToInvoke', this.getData( 'changeItToInvoke' ) + 1 );

		if( show ) {
			this.setData( 'ltPropShow', false );
			drop.toggle();

			$L.fastdom.measure( function() {
				tab.focus();
				var pos = drop.getBoundingClientRect();

				// This doesn't work exactly it can be behind a overflow'd div and still not be visible.
				if( pos.left < 0 
					|| pos.top < 0 
				) { 
					drop.scrollIntoView();
				}
			} );
			
		}

		link = this.childComp;
		if( link ) {
			link.querySelectorAll( 'lyte-drop-body' )[ link.querySelectorAll( 'lyte-drop-body' ).length - 1 ].addEventListener( 'scroll', function( event ) {
				this.callOnScroll( event, this );
			}.bind( this ) );
		}
		else {
			drop.querySelectorAll( 'lyte-drop-body' )[drop.querySelectorAll( 'lyte-drop-body' ).length - 1 ].addEventListener( 'scroll', function( event ) {
				this.callOnScroll( event, this );
			}.bind( this ) );
		}

		if( 
			options.length > 0 
			&& list.length > 0 
		) {
			this.addDisabledClass( drop.querySelectorAll( 'lyte-drop-item' ) );
		}
		
	},

	openSlideAnimate : function() {
		if( this.getData( 'ltPropAnimate' ) ){
			if( this._preventSetcss ) {
				return
			}
			this._preventSetcss = true
			this._prevent = true
			var box = this.childComp ? this.childComp : this.$node.querySelector('lyte-drop-box') 
			var elem = this.childComp ? this.childComp.querySelector('lyte-drop-body') : this.$node.querySelector('lyte-drop-body');
			this._oriStyle = elem.style.height;
			// animation starts from zero
			elem.style.height = 0;
			// for invert animation
			if( [ 'up', 'upLeft', 'upRight' ].indexOf( this.getData( 'pos' ) ) != -1 ) {
				box.style.top = parseInt( box.style.top ) + this._hgt - this._header - this._footer + 'px';
			}
			setTimeout( function(){
				// animation class added
				box.classList.add( 'lyteAnimate' );
				setTimeout( function(){
					// invert anime starts
					if( [ 'up', 'upLeft', 'upRight' ].indexOf( this.getData( 'pos' ) ) != -1 ) {
						box.style.top = parseInt( box.style.top ) - this._hgt + this._header + this._footer + 'px';
					}
					// height animate starts
					elem.style.height = this._hgt - this._header - this._footer + 'px';
					setTimeout( function(){
						delete this._prevent;
					}.bind(this), 20)	
				}.bind(this), 20)	
			}.bind(this), 20)
		}
	},

	closeDrop : function( link, event, freeze ){
		if( this._prevent ) {
			return
		}
		if( this.getData( 'ltPropAnimate' ) ) {
			this._prevent = true;
			this._arguments = arguments;
			$L.fastdom.mutate( function(){
				var box = this.childComp ? this.childComp : this.$node.querySelector('lyte-drop-box') 
				var elem = this.childComp ? this.childComp.querySelector('lyte-drop-body') : this.$node.querySelector('lyte-drop-body');
				// height set to zero for hide animation
				elem.style.height = 0;
				// invert animation
				if( [ 'up', 'upLeft', 'upRight' ].indexOf( this.getData( 'pos' ) ) != -1 ) {
					box.style.top = parseInt( box.style.top ) + this._hgt - this._header - this._footer + 'px';
				}
				this._elem = elem;
				this._box = box;
				elem.addEventListener( 'transitionend', this._close )					
			}.bind(this))
		} else {
			this.closeDrop1( link, event, freeze )
		}
	},

	closeDrop1 : function( link, event, freeze){
		if( this._arguments ) {
			link = this._arguments[ 0 ], event = this._arguments[ 1 ], freeze = this._arguments[ 2 ]
			this._elem.style.height = this._oriStyle;
			//animate class removal
			this._box.classList.remove( 'lyteAnimate' );
			this._elem.removeEventListener( 'transitionend', this._close )	
			delete this._hgt; delete this._oriStyle; delete this._arguments; delete this._elem; delete this._box; delete this._header; delete this._footer
		}
		link.classList.add( 'lyteDropdownHidden' );
		var freezeLayer = document.querySelector( '#lytedropdownfreezelayer' )
		if( freezeLayer ){
			document.querySelector( '#lytedropdownfreezelayer' ).style.display = 'none'
		}
		// link.style.top = '';
		link.style.left = '';
		if( freeze ) {
			document.body.style.overflow = this.bodyoverflow ? this.bodyoverflow : ''
		}
		if( this.getMethods( 'onHide' ) ) {
			this.executeMethod( 'onHide', event, this );
		}

		this.setData( 'pos', '' );
		delete this._prevent;delete this._preventSetcss;
	},

	callOnScroll: function( event ) {
		var dropBody = this.childComp.querySelector('lyte-drop-body'),
		ajax = this.getData( 'ltPropAjaxRequest' );
		if( this.getMethods('onScroll') ) {
			this.executeMethod( 'onScroll', event, this );
		}

		// if( 
		// 	( dropBody.offsetHeight + dropBody.scrollTop == dropBody.scrollHeight ) 
		// 	&& !Lyte.Component.registeredHelpers.lyteUiIsEmptyObject( ajax ) 
		// ) {
		// 	this.fetchData();
		// }
	},

	// fetchData: function() {
	// 	var request = this.getData("ltPropAjaxRequest");
	// 	var param = request.param ? request.param : null;
	// 	var method = request.method ? request.method : 'GET';
	// 	var reqHeader = request.header && request.header.name ? request.header.name : "Content-type";
 //        var reqHeaderVal = request.header && request.header.value ? request.header.value : "application/x-www-form-urlencoded";
	// 	var self = this;
	// 	var httpRequest = new XMLHttpRequest();

	//     if (!httpRequest) {
	//       alert('Giving up :( Cannot create an XMLHTTP instance');
	//       return false;
	//     }
	//     httpRequest.onreadystatechange = function() {
	// 	    if (httpRequest.readyState === XMLHttpRequest.DONE) {
	// 	      if (httpRequest.status === 200) {
	// 	      	var key = self.getData('ltPropAjaxRequest').key;
	// 	      	if (self.getData('firstRequest')) {
	// 		  		self.setData('ltPropOptions',JSON.parse(httpRequest.responseText)[key]);
	// 		  		self.setData('ltPropSelected',self.getData('ltPropOptions')[0][self.getData('ltPropSystemValue')]);
	// 		  		self.setData('firstRequest',false);
	// 		  		// alert(httpRequest.responseText);
	// 		      }else{
	// 		      		var options = JSON.parse(httpRequest.responseText)[key];
	// 		      		Lyte.arrayUtils(self.getData('ltPropOptions'),"push",options);
	// 		      }
	// 	      } else {
	// 	        alert('There was a problem with the request.');
	// 	      }
	// 	    }
	// 	  }
	// 	if(method === "GET" && param){
	// 		httpRequest.open(method, request.url+'?'+param, true);
	// 		param = null;
	// 	}
	// 	else{
	//     	httpRequest.open(method, request.url, true);
	// 	}
	// 	httpRequest.setRequestHeader(reqHeader, reqHeaderVal);
	//     httpRequest.send(param);
	// },

	addDisabledClass: function( elements ) {
		var i = 0, e, ele;
		for( ; i < elements.length; i++ ) {
			ele = elements[ i ];
			if( ele.getAttribute( 'disabled' ) == 'true' ) {
				ele.classList.add( 'lyteDropdown-disabled' );
			}
			else if( ele.classList.contains( 'lyteDropdown-disabled' ) ) {
				ele.classList.remove( 'lyteDropdown-disabled' );
			}
		}
	},

	onChangeInDisabledList: function() {
		var elements = this.childComp ? this.childComp.querySelectorAll('lyte-drop-item') : this.$node.querySelector('lyte-drop-item');
		for(var i = 0; i<elements.length; i++){
			elements[i].setAttribute('disabled',Lyte.Component.registeredHelpers.lyteUiCheckDisabled(this.getData('ltPropDisabledList'),elements[i].dataset.value));
		}
		this.addDisabledClass(elements);

	}.observes('ltPropDisabledList'),

	firePosCallBack: function() {
		var pos = this.getData( 'pos' );

		if( this.getMethods( 'onPositionChanged' ) && pos !== '') {
			this.executeMethod( 'onPositionChanged', pos, this);
		}
	}.observes(
		'pos',
		'firePos'
	),

	returnValueBy: function( content, key ) {
		if( key ) {
			return content[ key ];
		}

		return content;
	},

	findParent: function() {
		var tag = this.$node;

		if( this.getData( 'buttondisplay' ) ) {
			return tag.querySelector('.lyteDropdownButtonContainer')
		}
		else if( this.getData( 'multiple' ) ) {
			return tag.querySelector( '.lyteMultiselect' );
		}
		else{
			return tag.querySelector( '.lyteDropdownElement1' );
		}
	},

	setProperWidth: function( dropdownbutton, bcr, dropdownwidth ) {
		// Incomplete function - will probably add it later			
	},
	/*
		Calculate left of dropdown container when it has to come below/above the select element when it exceeds window.innerWidth and there is space to the right
	*/
	setLeftExceedForDown: function( element, container, bcr, containerbcr, xscroll ) {
		var scrolledLeft = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		elementWidth = elementBCR.width,
		containerBCR = containerbcr,
		containerWidth = containerBCR.width,
		total = scrolledLeft + elementLeft + elementWidth - containerWidth;

		return total
	},
	/*
		Calculate left of dropdown container when it has to come below/above the select element when it doesn't exceed window.innerWidth
	*/
	setLeftNotExceedForDown: function( element, bcr, xscroll ) {
		var scrolledLeft = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		total = scrolledLeft + elementLeft;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come above the select element
	*/
	setTopAboveForDown: function( element, container, bcr, containerbcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		containerBCR = containerbcr,
		containerHeight = containerBCR.height,
		total = scrolledHeight + elementTop  - containerHeight;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come below the select element
	*/
	setTopBelowForDown: function( element, bcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		elementHeight = elementBCR.height,
		total = scrolledHeight + elementTop + elementHeight;

		return total
	},
	/*
		Calculate left of dropdown container when it has to come to right of the select element
	*/
	setLeftForRight:function( element, bcr, xscroll ) {
		var scrolledWidth = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		elementWidth = elementBCR.width,
		total = scrolledWidth + elementLeft + elementWidth;

		return total
	},
	/*
		Calculate right of dropdown container when it has to come to left of the select element of right dropdown
	*/
	setRightForRight: function( element, container, bcr, elembcr, xscroll ) {
		var scrolledWidth = xscroll,
		elementBCR = bcr,
		containerBCR = elembcr,
		elementLeft = elementBCR.left,
		containerWidth = containerBCR.width,
		total = scrolledWidth + elementLeft - containerWidth;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come to right of dropdown and there is space below
	*/
	setTopForRight:function( element, bcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		total = scrolledHeight + elementTop;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come to right of dropdown and there is no space below
	*/
	setTopForRightAbove:function( element, container, bcr, elembcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		elementHeight = elementBCR.height,
		containerBCR = elembcr,
		containerHeight = containerBCR.height,
		total = scrolledHeight + elementTop + elementHeight - containerHeight;

		return total
	},
	/**
		Remove wrong arrow and append proper arrow
		@param string correct - the correct class
	*/
	setCorrectClass: function( cls ) {
		var arrow = this.childComp.querySelector( '.lyteArrow' ),
		list = arrow.classList, i = 0;
		for( ; i < list.length; i++ ) {
			if( list[ i ] == 'lyteArrow' || list[ i ] == cls ) {
				continue;
			}
			else { 
				arrow.classList.remove( list[ i ] );
				i--;
			}
		}

		arrow.classList.add( cls );
		arrow.classList.add( 'lyteArrowIcon' );
	},

	/**
	 * This going to check if a class has been toggled
	 * @param {MutationRecord} rec - The mutation record
	 * @param {String} cls - The class that needs to be checked
	 *
	 */
	hasClassToggled: function( rec, cls ) {
		var old = rec.oldValue ? rec.oldValue.split( " " ) : [],
		node = rec.target,
		olen = old.length,
		nlen = node.classList.length;

		if( ( ( !!~old.indexOf( cls )
			&& !node.classList.contains( cls ) )
			|| ( !~old.indexOf( cls )
				&& node.classList.contains( cls ) 
			) )

			// Only 1 class changed
			&& Math.abs( olen - nlen ) === 1
		) {
			return true;
		}

		return false;
	},

	/**
	 * The adjust width is going to adjust the width of the dropdown's body that is going to open
	 * @param {Element} body - The lyte-drop-box
	 * @param {Number} pwidth - The width of the parent Element
	 * @param {Number} bwidth - The width of the body Element
	 *
	 */

	adjustWidth: function( body, pwidth, bwidth ) {
			
		this.setData( 'widthAdjusted', 1 );

		if( bwidth < pwidth ) {
			body.style.width = pwidth + 'px';
			return parseFloat( pwidth );
		}
		// Shouldn't be there for the equal case
		else if( bwidth > pwidth ) {
			this.setData( 'widthAdjusted', 2 )
		}

		return bwidth;
		
	},


	/**
	 * Set the CSS for your dropdown
	 * refer commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 and previous for the previous stable setCSS function.
	 * commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 also gives a better understanding about the hard coded values in this function.
	 */ 
	setCss: function( onlyScroll ) {
		var link = this.childComp;

		if( !link 
			|| link.classList.contains( 'lyteDropdownHidden' )
		) {
			return;
		}

		// Get properties
		var callout = this.getData( 'ltPropCallout' );


		// Get button
		var body = link,
		custom = this.$node.element,
		par = custom ? custom : this.$node.querySelector( 'lyte-drop-button' );

		// if( !onlyScroll ) {
		// 	// Empty function which might be added in the future
		// 	this.setProperWidth( parNode, bcr, width );
		// }

		// Get Geometric propotions
		var wwidth = window.innerWidth, 
		wheight = window.innerHeight,
		drop = body.getBoundingClientRect(), 
		x = window.pageXOffset || document.documentElement.scrollLeft,
		y = window.pageYOffset || document.documentElement.scrollTop,
		height = body.offsetHeight,
		width = body.offsetWidth, 
		arrow = link.querySelector( '.lyteArrow' ),
		position = this.getData( 'ltPropPosition' ),
		offsets = par.getBoundingClientRect();

		if( this.data.ltPropAnimate ) {
			var drophead = body.querySelector( 'lyte-drop-header' ), dropfoot = body.querySelector( 'lyte-drop-footer' );
			this._header = drophead ? drophead.offsetHeight : 0; this._footer = dropfoot ? dropfoot.offsetHeight : 0;
			this._hgt = drop.height;
			body.querySelector( 'lyte-drop-body' ).style.height = ( this._hgt - this._header - this._footer ) + 'px';
		}

		// Adjusting width of the body is a one time thing. Atleast that is what we think.
		// Till the smoke clears around this issue we are going to hang on to onlyScroll
		// onlyScroll will probably be deprecated
		if( !onlyScroll && !this.getData( 'widthAdjusted' ) ) {
			width = this.adjustWidth( body, offsets.width, width );
		}

		// Intialize flags
		var downPos, 
		rightPos, 
		topPos, 
		leftPos; 

		// temp stores
		var tempStore,
		tempTop, 
		tempLeft, 
		tempMarginLeft, 
		tempMarginTop,
		tempNum, 
		tempDenom, 
		tempPer, 
		aHeight, 
		aWidth;

		if( position === 'down' ) {
			downPos = true;
			tempTop = offsets.top + offsets.height; 
			if( tempTop + height > wheight 
				&& offsets.top > height 
			) {
				downPos = false;		
			}
			else {
				downPos = true;
			}

			rightPos = true;
			tempLeft = offsets.left;
			if( tempLeft + width > wwidth 
				&& tempLeft > tempLeft + offsets.width - width
			) {
				rightPos = false;
				
			}
			else if( offsets.left + width <= wwidth ) {
				rightPos = true;
			}

			if( offsets.width > width ) {      //Think this is for multiselect(CODE HELP)
				arrow.style.left = ( ( width / 2 - 0 ) / width ) * 100 + "%"; // Had arrow.offsetWidth/2 instead of 0
			}

			if( downPos ) {
				if( callout ) {
					this.setCorrectClass( 'lyteArrowTop' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aHeight = window.getComputedStyle( arrow, ':before' ).borderWidth;
					tempStore = this.setTopBelowForDown( par, offsets, y ) + parseFloat( aHeight ? aHeight : '0px' ) + 'px';
				}
				else { 
					body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px';
				}

				
				
			}
			else {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowBottom' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aHeight = window.getComputedStyle( arrow, ':before' ).borderWidth;
					tempStore = this.setTopAboveForDown( par, body, offsets, drop, y ) - parseFloat( aHeight ? aHeight : '0px' ) + 'px';					
				}
				else {
					body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y ) + 'px';
				}

				
			}

			if( rightPos ) {
				if( callout ) {
					aWidth = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempMarginLeft = window.getComputedStyle( arrow, ':before' ).marginLeft;
					tempMarginLeft = Math.abs( parseFloat( tempMarginLeft ? tempMarginLeft : '0px' ) );
					tempNum = offsets.width / 2 - aWidth + tempMarginLeft; // We removed arrow.offsetWidth because it was giving width as 0 px
					tempDenom = width / 100;
					tempPer = tempNum / tempDenom;
					arrow.style.left = tempPer + '%'; 	
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftNotExceedForDown( par, offsets, x ) + 'px';	
			}
			else {
				if( callout ) {
					aWidth = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempMarginLeft = window.getComputedStyle( arrow, ':before' ).marginLeft;
					tempMarginLeft = Math.abs( parseFloat( tempMarginLeft ? tempMarginLeft : '0px' ) );	
					tempDenom = width / 100;
					tempNum = width - ( offsets.width / 2 ) - aWidth + tempMarginLeft; // We removed arrow.offsetWidth because it was giving width as 0 px
					tempPer = tempNum / tempDenom;
					arrow.style.left = tempPer + '%'; 
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftExceedForDown( par, body, offsets, drop, x ) + 'px'
			}

			if( downPos ) {
				this.setData( 'pos', 'down' );
			}
			else {
				this.setData( 'pos', 'up' );
			}

			
		}
		else if( position === 'right' ) {
			rightPos = true;
			if( offsets.left + offsets.width + width > wwidth
				&& offsets.left - drop.width > 0 
			) {   
				rightPos = false;
				
			}
			else{
				rightPos = true;
			}

			downPos = true;
			if( offsets.top + drop.height > wheight ) {
				downPos = false
			}
			else {
				downPos = true
			}

			if( rightPos ) {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowLeft' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aWidth = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempStore = this.setLeftForRight( par, offsets, x ) + aWidth + 'px';
				}
				else {
					body.style.left= this.setLeftForRight( par, offsets, x ) + 'px'
				}
			}
			else {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowRight' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aWidth = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempStore = this.setRightForRight( par, body, offsets, drop, x ) - aWidth + 'px';
				}
				else {
					body.style.left = this.setRightForRight( par, body, offsets, drop, x ) + 'px';
				}
			}

			if( downPos ) {
				if( callout ) {
					aHeight = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempMarginTop = window.getComputedStyle( arrow, ':before' ).marginTop;
					tempMarginTop = Math.abs( parseFloat( tempMarginTop ? tempMarginTop : '0px' ) );
					tempNum = ( ( offsets.height / 2 ) - aHeight  + tempMarginTop ) * 100; // Had arrow.getBoundingClientRect()/2 removed cos its value is 0
					tempDenom = drop.height;
					tempPer = tempNum / tempDenom;
					arrow.style.top = tempPer + '%';
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRight( par, offsets, y ) + 'px' 
			}
			else {
				if( callout ) {
					aHeight = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempMarginTop = window.getComputedStyle( arrow, ':before' ).marginTop;
					tempMarginTop = Math.abs( parseFloat( tempMarginTop ? tempMarginTop : '0px' ) ); 
					tempNum = ( drop.height - offsets.height / 2 - aHeight + tempMarginTop ) * 100; // Had arrow.getBoundingClientRect()/2 
					tempDenom = drop.height
					tempPer = tempNum / tempDenom;
					arrow.style.top = tempPer + '%';
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px'
			}

			if( rightPos ) {
				this.setData( 'pos', 'right' );
			}
			else {
				this.setData( 'pos', 'left' );
			}
		}
		else if( position === 'up' ) {
			topPos = true
			if( offsets.top - drop.height < 0 
				&& offsets.top + offsets.height + height < wheight 
			) {
				topPos = false
			}
			else {
				topPos = true
			}

			rightPos = true
			if( offsets.left + width > wwidth 
				&& offsets.left > offsets.left + offsets.width - width
			) {
				rightPos = false
			}
			else if( offsets.left + width <= wwidth ) {
				rightPos = true
			}

			if( offsets.width > width ) {      //Think this is for multiselect(CODE HELP)
				arrow.style.left = ( ( width / 2 - 0 ) / width ) * 100 +'%'; // Had arrow.offsetWidth/2 removed cos its value is 0
			}

			if( topPos ) {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowBottom' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aHeight = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempStore = this.setTopAboveForDown( par, body, offsets, drop, y ) - aHeight + 'px';	
				}
				else {
					body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y ) + 'px';
				}
			}
			else {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowTop' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aHeight = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempStore = this.setTopBelowForDown( par, offsets, y ) + aHeight + 'px';
				}
				else {
					body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px'
				}
			}
			if( rightPos ) {
				if( callout ) {
					aWidth = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempMarginLeft = window.getComputedStyle( arrow, ':before' ).marginLeft;
					tempMarginLeft = Math.abs( parseFloat( tempMarginLeft ? tempMarginLeft : '0px' ) );
					tempNum = offsets.width / 2 + tempMarginLeft - aWidth; // We removed arrow.offsetWidth because it was giving width as 0 px
					tempDenom = width / 100;
					tempPer = tempNum / tempDenom;
					arrow.style.left = tempPer + '%' 
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftNotExceedForDown( par, offsets, x ) + 'px';
			}
			else {
				if( callout ) {
					aWidth = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempMarginLeft = window.getComputedStyle( arrow, ':before' ).marginLeft;
					tempMarginLeft = Math.abs( parseFloat( tempMarginLeft ? tempMarginLeft : '0px' ) );
					tempDenom = width / 100;
					tempNum = width - ( offsets.width / 2 ) + tempMarginLeft - aWidth; // We removed arrow.offsetWidth because it was giving width as 0 px
					tempPer = tempNum / tempDenom; 
					arrow.style.left = tempPer +'%'; 
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftExceedForDown( par, body, offsets, drop, x ) + 'px';
			}

			if( topPos ) {
				this.setData( 'pos', 'up' );
			}
			else {
				this.setData( 'pos', 'down' );
			}
		}
		else if( position === 'left' ) {
			leftPos = true;
			if( offsets.left - drop.width < 0 
				&& offsets.left + drop.width < wwidth 
			) {
				leftPos = false;
			}
			else {
				leftPos = true;
			}

			downPos = true;
			if( offsets.top + drop.height > wheight ) {
				downPos = false;
			}
			else {
				downPos = true;
			}

			if( leftPos ) {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowRight' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aWidth = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempStore = this.setRightForRight( par, body, offsets, drop, x ) - aWidth + 'px';
				}
				else {
					body.style.left = this.setRightForRight( par, body, offsets, drop, x ) + 'px';
				}	
			}
			else {
				
				if( callout ) {
					this.setCorrectClass( 'lyteArrowLeft' );

					// layout thrashing happens here
					// Removing layout thrashing causes a jitter
					aWidth = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aWidth = parseFloat( aWidth ? aWidth : '0px' );
					tempStore = this.setLeftForRight( par, offsets, x ) + aWidth + 'px';
				}
				else {
					body.style.left = this.setLeftForRight( par, offsets, x ) + 'px';
				}
			}
			if( downPos ) {
				if( callout ) {
					aHeight = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempMarginTop = window.getComputedStyle( arrow, ':before' ).marginTop;
					tempMarginTop = Math.abs( parseFloat( tempMarginTop ? tempMarginTop : '0px' ) );
					tempNum = ( ( offsets.height / 2 ) - aHeight + tempMarginTop ) * 100; // Had arrow.getBoundingClientRect()/2 
					tempDenom = drop.height;
					tempPer = tempNum / tempDenom;
					arrow.style.top = tempPer + '%';
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRight( par, offsets, y ) + 'px';
			}
			else{
				if( callout ) {
					aHeight = window.getComputedStyle( arrow, ':before' ).borderWidth;
					aHeight = parseFloat( aHeight ? aHeight : '0px' );
					tempMarginTop = window.getComputedStyle( arrow, ':before' ).marginTop;
					tempMarginTop = Math.abs( parseFloat( tempMarginTop ? tempMarginTop : '0px' ) );
					tempNum = ( drop.height - offsets.height / 2 - aHeight + tempMarginTop ) * 100; // Had arrow.getBoundingClientRect()/2 
					tempDenom = drop.height;
					tempPer = tempNum / tempDenom;
					arrow.style.top = tempPer + '%'; 
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px';
			}

			if( leftPos ) {
				this.setData( 'pos', 'left' );
			}
			else {
				this.setData( 'pos', 'right' );
			}
		}			
	},

	setAlignment: function() {
		$L.fastdom.measure( function() {
			var link = this.childComp;

			if( !link ) {
				return ;
			}

			var par = this.$node.querySelector( 'lyte-drop-button' ),
			offsets = par.getBoundingClientRect(),
			height = link.offsetHeight,
			top= link.getBoundingClientRect().top,
			arrowval = 0,
			callout = this.getData( 'ltPropCallout' );

			if( callout ) {
				// what?
				arrowval = 9;
			}
	
			if( top < offsets.top ) {
				link.style.top = offsets.top - height - arrowval + 'px';
			}

		}, this );
		
	},

	setFreezeLayer: function() {
		var node = document.getElementById( 'lytedropdownfreezelayer' ), body;
		node.style.display = 'block';
		node.style.height = window.innerHeight + 'px';
		node.style.width = window.innerWidth + 'px';
		node.style.top = '0px';
		node.style.left = '0px';
		node.style.position = 'fixed';
		node.classList.add( 'lyteDropdownZIndex' );
		node.style.overflow = 'hidden';
		body = document.body;
		body.style.overflow = 'hidden';
	},

	scrollIntoView: function( element, move ) {
		var parent = this.childComp.querySelector( 'lyte-drop-body' ),
		offsetTop = element.offsetTop,
		scrollT = parent.scrollTop,
		height = parent.getBoundingClientRect().height,
		elementHeight = element.getBoundingClientRect().height;

		if( move === 'down' 
			&& scrollT + height < offsetTop + elementHeight 
		) {
			parent.scrollTop = parent.scrollTop + offsetTop + elementHeight - ( height + scrollT );
		}
		else if( move === 'up' 
				&& offsetTop < scrollT 
			) {
			parent.scrollTop = offsetTop
		}
	},

	open: function() {
		var that = this, link,
		type = this.getData( 'ltPropType' ),
		head = this.getData( 'drophead' ),
		mul = this.getData( 'multiple' ),
		freeze = this.getData( 'ltPropFreeze' ),
		hover = this.getData( 'ltPropHover' );
		
		link = this.childComp = this.$node.querySelector('lyte-drop-box');
		this.hideNodes();
		if( 
			type === 'multisearch' 
			&& head !== 'yield' 
		) {
			$L( '.lyteDropdownTextField' ).search( {
				scope: link,
				search: 'lyte-drop-item',
				onSearch: function( res ) {
					var i = 0, div, lk = that.childComp;
					for( ; i < res.length; i++ ) {
						if( !res[ i ].classList.contains( 'lyteDropdownActive' ) ) {
							div = lk.querySelector( '.lyteDropdownNoResult' );
							if( div ) {
								div.style.display = 'none';
							}

							return ;
						}
					}

					if( lk.querySelector( '.lyteDropdownNoResult' ).style.display !== 'none' ) {
						return ;
					}

					lk.querySelector( '.lyteDropdownNoResult' ).style.display = 'block';
				}
			} );
		}

		LyteComponent.appendChild( document.body, link );
		link.origindd = this.$node;
		link.classList.remove( 'lyteDropdownHidden' );
		if( freeze && !mul && !hover ) {
			this.setFreezeLayer()
		}

	},

	hideNodes: function() {
		var link = this.childComp, selected, i = 0, item,
		mul = this.getData( 'multiple' ),
		sel = this.getData( 'ltPropSelected' );

		// Hide the filtered items in the dropdown list
		if( mul && sel.length > 2 ) {                    
			if( !link ) {
				return ;
			}

			try {
				selected = JSON.parse( this.getData( 'ltPropSelected' ) );
			}
			catch( err ) {
				console.error( 'Unable to parse ltPropSelected', err );
				return ;
			}

			// Hide new selected values
			for( ; i < selected.length; i++ ) {
				item = link.querySelector('[data-value="'+ selected[ i ] +'"]');
				if( item ) {
					item.classList.add( 'lyteDropdownActive' );
				}	
			}
		}
	},

	showNodes: function( change ) {
		var i = 0, j, olen, elm, res, 
		link = this.childComp,
		mul = this.getData( 'multiple' ),
		type = this.getData('ltPropType'),
		head = this.getData('drophead'),
		all = this.getData( 'allSelected' ),
		nv = change.newValue, 
		ov = change.oldValue;

		if( !mul ) {
			return ;
		}

		if( link ) {
			res = link.querySelector( '.lyteDropdownNoResult' );
		}

		try {
			// Convert to string for obvious reasons
			nv = JSON.parse( nv ).map( function( val ) {
				return '' + val;
			} );

			// Convert to string for obvious reasons
			ov = JSON.parse( ov ).map( function( val ) {
				return '' + val;
			} );
		}
		catch( err ) {
			console.error( 'Unable to parse ltPropSelected', err );
			return ;
		}

		olen = ov.length;
		for( ; i < olen; i++ ) {
			if( nv.indexOf( ov[ i ] ) === -1 ) {
				if( link ) {
					elm = link.querySelector( '[data-value="' + ov[ i ] + '"' );

					// show items in dropbox
					if( elm ) {
						elm.classList.remove( 'lyteDropdownActive' );
					}
				}
				

				// remove items from head
				if( head === 'noyield' ) {
					for( j = 0; j < all.length; j++ ) {
						if( all[ j ].value === ov[ i ] ) {
							Lyte.arrayUtils( all, 'removeAt', j, 1 );
							break;
						}
					}
				}

				if( res
					&& type !== 'multisearch'  
					&& head !== 'yield' 
				) {
					res.style.display = 'none';
				}
			}
		}
	},

	selObs: function( change ) {
		if( this.getData( 'prev' ) ) {
			return ;
		}

		this.hideNodes();
		this.showNodes( change );
	}.observes( 'ltPropSelected' ),

	first: function() {
		this.setData( 'ltPropShow', true );
		this.open();
	},

	subsequent: function( link, freeze, mul, hover ) {
		link.classList.remove( 'lyteDropdownHidden' );
		if( freeze && !mul && !hover ) {
			this.setFreezeLayer()
		}
	},

	beforeShow: function( event, fromTg, first ) {
		var res, that = this, link = this.childComp,
		freeze = this.getData( 'ltPropFreeze' ),
		mul = this.getData( 'multiple' ),
		hover = this.getData( 'ltPropHover' );

		res = this.executeMethod( 'onBeforeShow', event, this );
		if( res && res.then ) {
			Promise.resolve( res ).then( function( arg ) {
				that.setData( 'call', fromTg ? true : event );
				if( first ) {
					that.first();
				}
				else {
					that.subsequent( link, freeze, mul, hover );
				}
			}, function() {
					
			} );
		}
		else if( res !== false ) {
			that.setData( 'call', fromTg ? true : event );
			if( first ) {
				that.first();
			}
			else {
				that.subsequent( link, freeze, mul, hover );
			}
		}
	},

	/**
	 * Show the error div when one of the elements get removed
	 * @param link - the drop box
	 * @param head -  the dropdown's head
	 *
	 */

	closeError: function( link, head ) {
		var result = link && link.querySelector( '.lyteDropdownNoResult' );

		if( 
			link 
			&& result 
			&& head !== 'yield' 
		) {
			result.style.display='none'
		}
	},

	/**
	 * Remove selected values from an array of nodes
	 * @param sel - selected values
	 * @param nodes - nodes that are selected to be removed
	 * @param head - whether the content was yielded or not
	 *
	 */
	removeSelected: function( sel, nodes, head, link ) {
		var len = nodes.length, 
		i, j, all = this.getData( 'allSelected' ),
		body, node, removed = [], ind;

		try {
			sel = JSON.parse( sel );
		}
		catch( er ) {
			console.error( 'Unable to parse ltPropSelected', er );
		}

		// Unfortunately sortable and change the order of selected values 
		for( i = 0; i < len; i++ ) {
			ind = sel.indexOf( nodes[ i ].getAttribute( 'data-value' ) );
			removed = removed.concat( sel.splice( ind, 1 ) );
		}

		if( head == 'noyield' ) {
			for( i = 0; i < len; i++ ) {
				for( j = 0; j < all.length; j++ ) {
					if( all[ j ].value == nodes[ i ].getAttribute( 'data-value' ) ) {
						Lyte.arrayUtils( all, 'removeAt', j );
						break;
					}
				}
			}
		}

		// lyte-drop-body causes problem
		body = link ? link : this.$node.querySelector( 'lyte-drop-body' );

		for( i = 0; i < nodes.length; i++ ) {
			node = body.querySelector( '[data-value="'+ nodes[ i ].getAttribute( 'data-value' ) +'"]' );
			if( node ) {
				node.classList.remove( 'lyteDropdownActive' );
				node.classList.remove( 'lyteSearchHidden' );
				node.removeAttribute( 'selected' );
			}
		}

		this.setAlignment();
		this.setData( 'prev', true );
		this.setData( 'ltPropSelected', JSON.stringify( sel ) );
		this.setData( 'prev', false );

		return removed;

	},

	removeAll: function( event ) {
		var drop = this.$node,
		link = this.childComp,
		head = this.getData( 'drophead' ),
		button = drop.querySelector( 'lyte-drop-button' ),
		nodes = button.querySelectorAll( '.lyteDropMark' ),
		sel = this.getData( 'ltPropSelected' ),
		proper, removed;

		this.closeError( link, head );
		removed = this.removeSelected( sel, nodes, head, link );

		proper = this.getData( 'isKeyDown' ) ? 'keydown' : 'click';
		if( this.getMethods( 'onRemove' ) ) {
			this.executeMethod( 'onRemove', event, removed, this.getData( 'ltPropSelected' ), this, proper, nodes );
		}

		event.stopPropagation();
	},

	/**
	 * Returns true when current clicked node and previous selected node( only 1 ) are same or one of the previous selected nodes is behind. Else returns false
	 * 
	 * @param cur - currently selected node
	 */

	relativePosition: function( cur, prev ) {
		var iterator = cur;

		// When the current selected element and the previous selected element is the same
		if( prev.length === 1 && prev[ 0 ] === cur ) {
			return true;
		}

		// Loop through previous elements to check if it is present
		while( ( iterator = iterator.previousElementSibling ) ) {
			if( iterator.getAttribute( 'lyte-last' ) ) {
				return true;
			}
		}

		return false;
	},

	shade: function( node ) {
		var front, iterator, 
		// There can be dropdowns within dropdown - this guarantees the first button is selected
		present = this.$node
							.querySelector( 'lyte-drop-button' )
							.querySelectorAll( '.lyteDropMark' );

		// Don't process when a there are more than 1 selected items and the user clicks on one of the selected items
		if( present.length > 1 && node.classList.contains( 'lyteDropMark' ) ) {
			return ;
		}

		iterator = ( present.length === 0 || this.relativePosition( node, present ) ) ? 'previousElementSibling' : 
																			'nextElementSibling';

		do {
			node.classList.add( 'lyteDropMark' );
		} while( ( node = node[ iterator ] ) 
				&& !node.getAttribute( 'lyte-last' ) );
	},

	mark: function( node, shift, single ) {

		

		// When shift is pressed
		if( shift ) {
			_lyteDropdown.unmark( this );
			this.shade( node );
		}
		// When command or control is pressed
		else if( single ) {
			_lyteDropdown.unmark( this );
			node.classList.add( 'lyteDropMark' );
		}
		// When none of the modifier keys are pressed
		else {
			_lyteDropdown.unmark();
			node.classList.add( 'lyteDropMark' );
		}

		this.setLast( node );	
	},

	/** 
	 * Sets the current node as the last selected node 
	 * so that subsequent selections can proceed from this node ( Also removes the previous last)
	 * 
	 * @param node - the node which is going to be the last node that is getting set
	 */
	setLast: function( node ) {
		var prev = document.querySelector( '[lyte-last="true"]' );

		if( prev ) {
			prev.removeAttribute( 'lyte-last' );
		}

		node.setAttribute( 'lyte-last', true );
	},

	/**
	 * Function to set the first value as lt-prop-selected
	 *
	 */

	setInitialSelected: function() {
		var options = this.getData( 'ltPropOptions' ),
		firstElement = options[ 0 ],
		flag = false,
		value;

		if( firstElement.constructor == Object ) {
           	if( Object.keys( firstElement ).length == 1 ) {
	            value = firstElement[ Object.keys( firstElement )[ 0 ] ];
	            if( value.constructor == Array ) {
	                flag = true
	            }
	        }   
        }

        if( flag ) {
           	if ( Object.prototype.toString.call( value[ 0 ] ) === '[object Object]' ) {
           		this.setData( 'ltPropSelected', value[ 0 ][ this.getData( 'ltPropSystemValue' ) ] );
           	}
           	else{
           		this.setData( 'ltPropSelected', value[ 0 ] );
           	}
        }
        else{
           	if ( Object.prototype.toString.call( firstElement ) === '[object Object]' ) {
           		this.setData( 'ltPropSelected', firstElement[ this.getData( 'ltPropSystemValue' ) ] );
           	}
           	else {
           		this.setData( 'ltPropSelected', firstElement );
           	}
        }
	},

	/**
	 * Function to set an initial value to the dropdown when lt-prop-options is pushed later
	 * into the dropdown. When lt-prop-options is empty and new items are pushed in 
	 * @param change - Old value and new values
	 *
	 */
	contentChange: function( change ) {
		var oldValue = change.oldValue,
		newValue = change.newValue,
		sel = this.getData( 'ltPropSelected' ),
		ph = this.getData( 'ltPropPlaceholder' ),
		disp = this.getData( 'ltPropDisplayValue' ),
		body = this.getData( 'dropbody' ) === 'yield',

		// Old value of lt-prop-options should be empty and the new value should be filled
		initial = ( 
					( oldValue && oldValue.length === 0 ) 
					|| !oldValue 
				) && newValue && newValue.length > 0;

		if( initial && !sel && !ph && !disp && !body ) {
			this.setInitialSelected();	
		}
	}.observes( 'ltPropOptions' ),

	selChange: function() {
		var mul = this.getData( 'multiple' ),
		head = this.getData( 'drophead' ), 
		link = this.childComp,
		sel = this.getData( 'ltPropSelected' ),
		sels, parent = link ? link : this.$node.querySelector( 'lyte-drop-box' ), 
		node, selected, display, obj, flag, i = 0, j = 0, elm, prev;

		if( 
			mul 
			&& head !== 'yield' 
		) {
			if( !sel ) {
				return ;
			}

			try {
				selected = JSON.parse( sel );
			}
			catch( err ) {
				console.error( 'Could not parse ltPropSelected', err );
				return ;
			}

			display = this.getData( 'allSelected' );
			for( ; i < selected.length; i++ ) {
				flag = true;
				for( j = 0; j < display.length; j++ ) {
					if( selected[ i ] == display[ j ].value ) {
						flag = false;
						break;
					}
				}

				if( flag ) {
					obj = {};
					obj.value = selected[ i ];
					elm = parent.querySelector( '[data-value="' + selected[ i ] + '"]' );
					if( elm ) {
						obj.display = elm.textContent;
					}
					
					if( !obj.display ) {
						continue;
					}

					Lyte.arrayUtils( this.getData( 'allSelected' ), 'push', obj ); 
				}
			}	
		}
		else if( !mul ) {
			node = parent.querySelector( '[data-value="' + sel + '"]' );

			// Don't remove previous selected=true attribute when it is a multiselect should only remove it when the element is removed from the selected list.
			sels = parent.querySelectorAll( '[selected]' );

			for( ; i < sels.length; i++ ) {
				if( sels[ i ].getAttribute( 'data-value' ) != sel ) {
					sels[ i ].removeAttribute( 'selected' );
				}
			}

			if( head !== 'yield' ) {
				if( node ) {
					var innerText = node.textContent;
					this.setData( 'ltPropDisplayValue', innerText );
				}
			}	
		}

		// To set selected to true to the ltPropSelected node
		if( node ) {
			node.setAttribute( 'selected', 'true' );
			prev = parent.querySelector( '.lyteDropdownSelection' );
			prev ? prev.classList.remove( 'lyteDropdownSelection' ) : undefined;
			node.classList.add( 'lyteDropdownSelection' );
		}
	
	}.observes(
		'ltPropSelected',
		'changeItToInvoke'
	),

	tabIndexChange: function() {
		var disabled = this.getData( 'ltPropDisabled' ),
		tab = this.$node.querySelector( '[tabindex]' ),
		ind = this.getData( 'ltPropTabindex' );

		if( disabled ) {
			tab.classList.add( 'lyteDropdown-disabled' );
			tab.tabIndex = -1;
		}
		else{
			tab.classList.remove( 'lyteDropdown-disabled' );
			this.$node.querySelector( '[tabindex="-1"]' ).tabIndex = ind;
		}
	}.observes( 'ltPropDisabled' ),

	data: function() {
        return {
        	'changeItToInvoke':Lyte.attr("number",{"default":1}),
        	'dummy1':Lyte.attr("boolean",{"default":true}),
        	'dummy2':Lyte.attr("boolean",{"default":false}),

        	// Added to provide backward compatibility to multiselect.
        	// Multiselects usually remove only 1 value at a time but there was a case when you wanted to remove multiple values with
        	// the meta or the command keys
        	// onRemove improperly returned a string when one key was removed and an array when multiple keys were removed
        	// To better reflect the behaviour a new attribute was added.
        	'ltPropRemoveMultiple': Lyte.attr( 'boolean', { 'default': false } ),
        	'ltPropYield':Lyte.attr("boolean",{"default":false}),
        	'ltPropType':Lyte.attr("string",{"default":''}),
        	'ltPropTabindex':Lyte.attr("number",{"default":0}),
        	'ltPropShow':Lyte.attr("boolean",{"default":false}),
        	'ltPropFreeze':Lyte.attr("boolean",{"default": true}),
        	'ltPropOptions':Lyte.attr("array",{"default":[]}),
        	'ltPropUserValue':Lyte.attr("string",{"default":undefined}),
			'ltPropSystemValue':Lyte.attr("string",{"default":undefined}),
			'ltPropPosition':Lyte.attr("string",{"default":'down'}),
			'ltPropIconClass':Lyte.attr("string",{"default":'dropdown'}),
			'ltPropSelected':Lyte.attr("string",{"default":''}),
			'ltPropCallout':Lyte.attr("boolean",{"default": false}),
			'ltPropPlaceholder':Lyte.attr("string",{"default":''}),
			'ltPropDisabled':Lyte.attr("boolean",{"default": false}),
			'ltPropHover':Lyte.attr("boolean",{"default": false}),
			'ltPropNoResult':Lyte.attr("string",{"default":'No Results Found'}),
   			'ltPropInputClass':Lyte.attr("string",{"default":'lyteSearch'}),
   			'allSelected' : Lyte.attr("array", {"default" : []}),
   			'ltPropBoundary':Lyte.attr("object",{"default":{}}),
   			'pos':Lyte.attr("string",{"default":''}),
   			'firePos':Lyte.attr("number",{"default":1}),
   			'ltPropAjaxRequest':Lyte.attr("object",{"default":{}}),
   			'firstRequest':Lyte.attr("boolean",{"default":true}),
   			'ltPropDisplayValue': Lyte.attr("string",{"default":""}),
   			'ltPropDisabledList': Lyte.attr('array',{"default":[]}),
   			 ltPropAnimate : Lyte.attr( 'boolean', { default : false }),
   			'ltPropSetPos': Lyte.attr( 'boolean', { 'default': false })
			// 'ltPropContainerClass':Lyte.attr("string",{"default":''}),
			// 'ltPropSlide':Lyte.attr("boolean",{"default": false}),
		}
	},
	actions:{

		closeIt: function( event ) {
			var mx = event.clientX,my = event.clientY
			var dp = this.$node.querySelector('lyte-drop-button')
			var dpt = dp.getBoundingClientRect().top,dph = dp.getBoundingClientRect().height
			var dpl = dp.getBoundingClientRect().left,dpw = dp.getBoundingClientRect().width
			var dc = this.childComp
			var dct = dc.getBoundingClientRect().top,dch = dc.getBoundingClientRect().height
			var dcl = dc.getBoundingClientRect().left,dcw = dc.getBoundingClientRect().width
			if((mx >= dpl && mx <= dpl + dpw && my >= dpt && my <= dpt + dph)|| (mx >= dcl && mx <= dcl + dcw && my >= dct && my <= dct + dch)){
				return ;
			}
			this.$node.toggle(event,"leave")
		},

		processElements: function( event ) {
			var link = this.childComp,
			elm =  event.target,
			mul = this.getData( 'multiple' ),
			head = this.getData('drophead'),
			freeze = this.getData( 'ltPropFreeze' ),
			type = this.getData('ltPropType'),
			sel, res, elements, i = 0, j, src, visiblenodes, button;

			while( 
				elm.tagName !== 'HTML' 
				&& elm.tagName !== 'LYTE-DROP-ITEM' 
			) {
				elm = elm.parentElement
			}

			if( elm.tagName === 'HTML' ) {               //Clicking on header should not trigger an event(CODE HELP)
				return false;
			}

			if( !mul && head !== 'yield' ) {
				elm.setAttribute( 'selected', 'true' );
				if( this.getMethods( 'onOptionSelected' ) ) {
					this.executeMethod( 'onOptionSelected', event, this.getData( 'ltPropSelected' ), this, elm );
				}

				if( this.getMethods( 'onBeforeHide' ) ) {
					res = this.executeMethod( 'onBeforeHide', event, this );
					res = res == undefined ? true : false;
					if( !res ) {
						return ;
					}
				} 

				this.closeDrop( link, event, freeze);
			}
			else if( mul ) {

				if( head == 'noyield' 
					&& this.getData('search') 
				) {
					$L.fastdom.measure( function() { 
						this.$node.querySelector('input').focus();
					}, this );	
				}

				elements = link.querySelectorAll('lyte-drop-item');
				for( ; i < elements.length; i++ ) {
					if( elements[ i ].classList.contains( 'lyteDropdownSelection' ) ) {
						break;
					}
				}

				if( elements[ i ] ) {
					elements[ i ].classList.remove( 'lyteDropdownSelection' )
					j = i
					i++;
					j--;
					for( ; i < elements.length; i++ ) {
						if( !elements[i].classList.contains( 'lyteDropdownActive' ) ) {
							break
						}
					}

					if( i != elements.length ) {
						elements[ i ].classList.add( 'lyteDropdownSelection' );
					}
					else {
						for( ; j > -1; j-- ) {
							if( !elements[ j ].classList.contains( 'lyteDropdownActive' ) ) {
								break;
							}
						}

						if( j != -1 ) {
							elements[ j ].classList.add( 'lyteDropdownSelection' );
						}
					}
				}

				this.setData( 'prev', true );
				elm.setAttribute( 'selected', 'true' );
				this.setData( 'prev', false );

				src = elm.getAttribute( 'data-value' );

				link.querySelector( '[data-value="' + src + '"]').classList.add( 'lyteDropdownActive' );

				// check this things position in code now.
				if( this.getMethods('onAdd') ) {
					this.executeMethod( 'onAdd', event, src, this.getData('ltPropSelected'), this, elm );
				}

				// All of this should happen only when a non-custom dropdown is given.
				visiblenodes = link.querySelectorAll( 'lyte-drop-item:not(.lyteDropdownActive):not(.lyteSearchHidden)' );
				if( visiblenodes.length === 0 ) {
					if( 
						link.querySelector('.lyteDropdownNoResult') 
						&& type !== 'multisearch' && head !== 'yield' 
					) {
						link.querySelector( '.lyteDropdownNoResult' ).style.display = 'block';
					}

					if( type === 'multisearch' && head !== 'yield' ) {
						link.querySelector( '.lyteDropdownNoResult' ).style.display = 'block';
					}
				}

				this.setAlignment();

				// Might be opened up later
				// button = this.$node.querySelector( 'lyte-drop-button' )
				// this.setProperWidth( this, button, button.getBoundingClientRect(), button.offsetWidth );
			}
			else {	

				// Maybe need to set selected to true	
				// Have to remove and add lyteDropdownSelection over here cause we have a check over in selChange which prevents it from doing it there
				if( link.querySelector( 'lyte-drop-item.lyteDropdownSelection' ) ){
					link.querySelector('lyte-drop-item.lyteDropdownSelection').classList.remove( 'lyteDropdownSelection' );
				}

				elm.classList.add( 'lyteDropdownSelection' );
				this.setData( 'ltPropSelected',elm.getAttribute( 'data-value' ) );
				if( this.getMethods( 'onOptionSelected' ) ) {
					this.executeMethod( 'onOptionSelected', event, this.getData( 'ltPropSelected' ), this, elm );
				}

				if( this.getMethods( 'onBeforeHide' ) ) {
					res = this.executeMethod('onBeforeHide',event,this)
					res = res == undefined?true:false
					if( !res ) {
						return ;
					}
				}

				this.closeDrop( link, event, freeze);
			}
		},
		
		closeFun: function( event ) {
			var link = this.childComp,
			head = this.getData('drophead'), 
			rm = this.getData( 'ltPropRemoveMultiple' ),
			node = event.target, src, sel = this.getData( 'ltPropSelected' ), i = 0,
			res = [], body, end, proper, hide;

			// This is for inbuilt error display
			this.closeError( link, head );

			while( 
				!node.getAttribute( 'data-value' ) 
				&& node
			) {
				node = node.parentElement
			}

			if( !node ) {
				return ;
			}

			src = node.getAttribute( 'data-value' )	
			this.removeSelected( sel, [ node ], head, link );			
			proper = this.getData( 'isKeyDown' ) ? 'keydown' : 'click';
			if( this.getMethods( 'onRemove' ) ) {
				// Return an array of removed values in case of removeMultiple
				// else return a singular value
				this.executeMethod( 'onRemove', event, rm ? [ src ] : src  , this.getData('ltPropSelected'), this, proper, node );
			}

			event.stopPropagation();

		},

		searchAndCheck: function( event ) {
			this.$node.constructor._actions.checkKey.call( this, event );
		},

		searchAndOpen: function( event ) {
			this.$node.constructor._actions.showHide.call( this, event );
		},

		checkKey: function( event ) {
			var type = this.getData('ltPropType');
			if( event.keyCode == 9 ) {
				this.$node.toggle( this, event );
				if( type == 'multisearch' ) {
					this.$node.querySelector( '[type="text"]' ).focus()
				}
			}
		},

		showHide: function( event, eventtype, fromTg ) {
			var link = this.childComp,
			freeze = this.getData( 'ltPropFreeze' ),
			mul = this.getData( 'multiple' ),
			hover = this.getData( 'ltPropHover' ),
			rm = this.getData( 'ltPropRemoveMultiple' ),
			show = this.getData( 'ltPropShow' ), res, cur;

			// Exists to remove multiple selected values from a multiselect using either the meta key or the control key
			if( rm && event && mul ) {
				cur = event.target;
				while( cur && cur.tagName !== 'LYTE-DROPDOWN' && !cur.getAttribute( 'data-value' ) ) {
					cur = cur.parentNode;
				}

				// Node with data-value is clicked so you need to process it
				if( cur && cur.getAttribute( 'data-value' ) ) {
					this.mark( cur, event.shiftKey, event.ctrlKey || event.metaKey );
					return ;
				}
				// The node with data-value is not clicked so this is going to unmark everything
				else {
					_lyteDropdown.unmark();
				}
			}
			// When you click another dropdown whose rm is false
			else {
				_lyteDropdown.unmark();
			}

			// For some unknow reason the dropdown closes when you hover over the select box to prevent this we are doing this and same for the opposite
			if( eventtype == 'enter' ) {
				if( 
					link
					&& !link.classList.contains( 'lyteDropdownHidden' ) 
				) {
					return ;
				}

				this.$node.querySelector('[tabindex]').focus()
			}

			if( eventtype == 'leave' ) {
				if( 
					link 
					&& link.classList.contains( 'lyteDropdownHidden' ) 
				) {
					return ;
				}
			}

			if( !show ) {
				if( this.getMethods( 'onBeforeShow' ) ) {
					if( !link ) {
						this.childComp = this.$node.querySelector( 'lyte-drop-box' );
					}

					this.beforeShow( event, fromTg, true );
				}
				else {
					this.setData( 'call', fromTg ? true : event );
					this.first();
				}	
			}
			else if( link.classList.contains( 'lyteDropdownHidden' ) ) {
				if( this.getMethods( 'onBeforeShow' ) ) {

					this.beforeShow( event, fromTg, false );
					// res = this.executeMethod( 'onBeforeShow', event, this );
					// res = res == undefined ? true : false;
					// if( !res ) {
					// 	return ;
					// }
				}
				else {
					this.setData( 'call', fromTg ? true : event );
					this.subsequent( link, freeze, mul, hover );
				}
			}
			else if( fromTg || !mul ) {
				if( this.getMethods( 'onBeforeHide' ) ) {
					res = this.executeMethod( 'onBeforeHide', event, this );
					res = res == undefined ? true : false;
					if( !res ) {
						return ;
					}
				}

				this.closeDrop( link, event, freeze);
			}
			
		}
	}
});

window.addEventListener('scroll',function(event){	
	var elm = document.querySelector( 'lyte-drop-box:not(.lyteDropdownHidden)' ),
	tempele = elm,
	cur = event.target,
	drop, component, boundary, left, right, top, bottom, offsets, link;
	if( !elm ){
		return ;
	}

	while( elm.tagName != 'LYTE-DROP-BOX' ) {
		elm = elm.parentElement
	}

	if( cur.nodeName == "#document" ){     //This probably happens because scrollIntoView is used to focus the dropdown which is open at the start so the event.target is #document(CODE HELP)
		return ;
	}

	while( cur.tagName !== 'LYTE-DROP-BOX' && cur.tagName !== 'HTML' ) {
		cur = cur.parentElement;
	}

	if( cur.tagName === 'LYTE-DROP-BOX' ) {
		return ;
	}

	drop = elm.origindd
	if( !drop ) {
		return ;
	}

	component = drop.component;
	link = component.childComp;
	boundary = component.getData( 'ltPropBoundary' );
	left = boundary.left ? boundary.left : 0;
	right = boundary.right ? boundary.right : window.innerWidth;
	top = boundary.top ? boundary.top : 0;
	bottom = boundary.bottom ? boundary.bottom : window.innerHeight;
	offsets = drop.getBoundingClientRect();

	if( offsets.top < top || offsets.left < left || offsets.right > right || offsets.bottom > bottom ) {
		if( component.getMethods( 'onBeforeHide' ) ) {
			var result = component.executeMethod('onBeforeHide',event,component)
			result = result == undefined ? true : false;
			if( !result ) {
				return ;
			}
		}

		// elm.classList.add('lyteDropdownHidden')
		// if( component.getData( 'ltPropFreeze' ) ) {
		// 	document.body.style.overflow = openElem.origindd.component.bodyoverflow ? openElem.origindd.component.bodyoverflow : "";
		// }

		component.closeDrop.call( component, link, event, component.getData( 'ltPropFreeze' ));
	}
	
	drop.component.setCss(true)
},true);

document.addEventListener( 'click', function( event ) {
	var ele = event.target, cur, all, i = 0, j = 0,
	open, temp, component, res, freeze, link, drp, item;

	while( 
		ele.tagName !== 'LYTE-DROPDOWN' 
		&& ele.tagName !== 'HTML' 
		&& ele.tagName !== 'LYTE-DROP-BOX' 
		&& ele.tagName !== 'LYTE-DROP-REMOVE'
	) {
		ele = ele.parentElement;
		if( !ele ) {
			return ;
		}
	}

	if(ele.tagName == 'HTML') {
		_lyteDropdown.unmark();
		open = document.querySelectorAll('lyte-drop-box:not(.lyteDropdownHidden)');

		for( ; j < open.length; j++ ) {
			temp = open[ j ];
			if( temp ) {
				component = temp.origindd.component;
				if( component.getMethods( 'onBeforeHide' ) ) {
					res = component.executeMethod( 'onBeforeHide', event, component );
					res = res == undefined ? true : false;
					if( !res ) {
						continue ;
					}
				}

				// document.getElementById( 'lytedropdownfreezelayer' ).style.display = 'none';
				// temp.classList.add('lyteDropdownHidden');
				freeze = document.getElementById( 'lytedropdownfreezelayer' );
				component.closeDrop.call( component, temp, event, freeze);
			}
		}
	}
	else if( ele.tagName === 'LYTE-DROPDOWN' ) {
		cur = ele;
		all = document.querySelectorAll( 'lyte-drop-box:not(.lyteDropdownHidden)' )
		for( ; i < all.length; i++ ) {
			if( all[ i ].origindd == cur ) {
				continue;
			}
			else {
				drp = all[ i ].origindd;
				component = drp.component;
				_lyteDropdown.unmark();
				if( component.getMethods( 'onBeforeHide' ) ) {
					res = component.executeMethod( 'onBeforeHide', event, component );
					res = res == undefined ? true : false;
					if( !res ) {
						continue;
					}
				}

				// all[ i ].classList.add('lyteDropdownHidden');
				// freeze = cur.ltProp('freeze');
				// if( !freeze ) {
				// 	document.getElementById( 'lytedropdownfreezelayer' ).style.display = 'none';
				// }

				// if( component.getData('ltPropFreeze') ) {
				// 	document.body.style.overflow = component.bodyoverflow ? component.bodyoverflow : '';
				// }

				component.closeDrop.call( component, component.childComp, event, component.getData('ltPropFreeze'));
			}
		}
	}
	else if( ele.tagName === 'LYTE-DROP-REMOVE' ) {
		drp = ele;
		while( drp.tagName != 'LYTE-DROPDOWN' ) {
			if( drp.getAttribute( 'data-value' ) ) {
				item = drp;
			}
			drp = drp.parentElement;
		}

		if( item.classList.contains( 'lyteDropMark' ) ) {
			drp.component.removeAll( event );
		}
		else {
			_lyteDropdown.unmark();
			drp.component.actions.closeFun.call( drp.component, event );	
		}
	}
}, true );

document.addEventListener( 'keydown', function( event ) {  //This is to take care of the tabbing problems in a dropdown and traversing(CODE HELP)
	var kc = event.keyCode, 
	active, acomp, abutton, anodes,
	open = document.querySelector( 'lyte-drop-box:not(.lyteDropdownHidden)' ),
	type, res, drp, component, src, last, l = 0, cur, elem, elems, i = 0, j, all, k;

	if(
		( 
			kc == 38 
			|| kc == 40 
			|| kc == 13 
		) 
		&& open 
	) {
		if( kc == 38 
			|| kc == 40 
		) {
			event.preventDefault()
		}

		drp = open.origindd;
		component = drp.component;
		type = component.getData( 'ltPropType' );

		open = open.children;
		for( ; l < open.length; l++ ) {
			if( open[ l ].tagName === 'LYTE-DROP-BODY' ) {
				break;
			}
		}

		open = open[ l ];
		cur = open.querySelector('.lyteDropdownSelection')
		if( 
			!cur 
			|| ( cur 
				&& ( 
					cur.classList.contains('lyteSearchHidden') 
					|| cur.classList.contains('lyteDropdownActive') 
					)
				)
			) {
			elems = open.querySelectorAll('lyte-drop-item:not(.lyteSearchHidden):not(.lyteDropdownActive)') //wrong
			for( ; i < elems.length; i++ ) {
				if( elems[ i ].style.display != 'none' ) {
					elem = elems[ i ];
					break;
				}
			}

			if( cur ) {
				cur.classList.remove( 'lyteDropdownSelection' );
			}

			if( elem ) {
				elem.classList.add( 'lyteDropdownSelection' );
				return ;
			}
		}
			
		kc = event.keyCode;
		elems = open.querySelectorAll( 'lyte-drop-item' );
		for( i = 0; i < elems.length; i++ ) {
			if( elems[ i ].classList.contains( 'lyteDropdownSelection' ) ) {
				break;
			}
		}

		if( kc == 13 ) {
			if( component.getData( 'multiple' ) ) {
				if( !elems[ i ] ){ 
					return ;
				}
				elems[ i ].click();

				// You are just bad
				k = i;
				all = open.querySelectorAll( 'lyte-drop-item' );
				for( ; k < all.length; k++ ) {
					if( 
						!all[ k ].classList.contains( 'lyteSearchHidden' ) 
						&& !all[ k ].classList.contains( 'lyteDropdownActive' ) 
					) {
						break;
					}
				}

				if( k != all.length ) {
					all[ k ].classList.add( 'lyteDropdownSelection' );
				}
				else {
					k = i
					for( ; k > -1; k-- ) {
						if( 
							!all[ k ].classList.contains( 'lyteSearchHidden' ) 
							&& !all[ k ].classList.contains( 'lyteDropdownActive' )
						) {
							break;
						}
					}

					if( k != -1 ) {
						all[ k ].classList.add( 'lyteDropdownSelection' );
					}
				}
			}
			else {
				if( elems[ i ] ) {
					elems[ i ].click();
				}
			}
		}
		else if(
			kc == 38 
			&& i != 0 
		) {
			j = i;
			i = i - 1;
			for( ; i > -1; i-- ) {
				if( 
					!elems[ i ].classList.contains( 'lyteDropdownActive' )
					&& !elems[ i ].classList.contains( 'lyteSearchHidden' )
					&& elems[ i ].style.display !== 'none'
				) {
					break;
				}
			}

			if( i != -1 ) {
				component.scrollIntoView( elems[ i ], 'up' );
				elems[ j ].classList.remove( 'lyteDropdownSelection' );
				elems[ i ].classList.add( 'lyteDropdownSelection' );
			}							
		}
		else if(
			kc == 40
			&& i != elems.length -1
		) {
			j = i;
			i = i + 1;
			for( ; i < elems.length; i++ ) {
				if( 
					!elems[ i ].classList.contains('lyteDropdownActive') 
					&& !elems[ i ].classList.contains('lyteSearchHidden') 
					&& elems[ i ].style.display != 'none' 
				) {
					break;
				}
			}

			if( i < elems.length ) {  // Added this because it was breaking in CRM		
				component.scrollIntoView( elems[ i ],'down' );
				elems[ j ].classList.remove( 'lyteDropdownSelection' );
				elems[ i ].classList.add( 'lyteDropdownSelection' );
			}
		}
		
	}

	if( kc === 8 ) {
		active = _lyteDropdown.getActive();
		if( active ) {
			acomp = active.component;
			abutton = active.querySelector( 'lyte-drop-button' );
			anodes = abutton.querySelector( '.lyteDropMark' );
		}

		drp = open && open.origindd;
		component = drp && drp.component;
		type = component && component.getData( 'ltPropType' );
		
		if( anodes ) {
			acomp.setData( 'isKeyDown', true );
			acomp.removeAll( event );
			acomp.setData( 'isKeyDown', false );
		}
		else if( open && type === 'multisearch' && _lyteDropdown.isInput( event, open ) ) {
			last = drp.querySelectorAll( 'lyte-drop-remove' )
			if( last.length > 0 ) {
				drp.component.setData( 'isKeyDown', true );
				last[ last.length - 1 ].click();
				drp.component.setData( 'isKeyDown', false );
			}
		}
	}


	if( 
		kc != 9 
		&& kc != 27 
	) {
		return ;
	}

	if( open ) {
	 	while( open.tagName != 'LYTE-DROP-BOX' ) {
	 		open = open.parentNode;
	 	}

	 	component = open.origindd.component;
	 	if( component.getMethods( 'onBeforeHide' ) ) {
			res = component.executeMethod( 'onBeforeHide', event, component );
			res = res == undefined ? true : false;
			if( !res ) {
				return ;
			}
		}
		// open.classList.add('lyteDropdownHidden')
	 	component.closeDrop.call( component, component.childComp, event, component.getData('ltPropFreeze'));
	}

});

document.addEventListener( 'keypress', function( event ) { //It searches the dropdown items matching the pressed charactes when the dropdown is open
	var kc = event.which || event.keyCode, i = 0, children, pos,
	open = document.querySelectorAll( 'lyte-drop-box:not(.lyteDropdownHidden)' ), drp;

	if( 
		open.length > 0
		&& ( ( kc >= 65 && kc <= 90 ) 
			|| ( kc >= 97 && kc <= 122 ) )
	) {
		_lyteDropdown.pressedCharacter = _lyteDropdown.pressedCharacter ? _lyteDropdown.pressedCharacter += String.fromCharCode(kc) : String.fromCharCode(kc);
		if( _lyteDropdown.checkDDtimeoutId ) {
			clearTimeout( _lyteDropdown.checkDDtimeoutId );
		}

		_lyteDropdown.checkDDtimeoutId = setTimeout( function() {
			_lyteDropdown.pressedCharacter = null;
		}, 500 );

		drp = document.activeElement.parentElement;
		drp = drp.tagName == "LYTE-DROPDOWN" ? drp : null;
		if( open.length > 0 && drp ) {
			for(var i =0 ; i < open.length ; i++ ) {
				// breaking change
				if( open[ i ].origindd == drp ) {
					break;
				}
			}

			open = open[ i ];
			drp = open.origindd;
			children = open.querySelectorAll('lyte-drop-item');

			if( 
				_lyteDropdown.cachePreviousVal.char 
				&& _lyteDropdown.cachePreviousVal.char == _lyteDropdown.pressedCharacter 
				&& ( _lyteDropdown.cachePreviousVal.pos + 1 ) < children.length 
				&& children[ _lyteDropdown.cachePreviousVal.pos + 1 ].textContent.substring( 0, _lyteDropdown.pressedCharacter.length ).toLowerCase() === _lyteDropdown.pressedCharacter.toLowerCase() 
			) {
				pos = _lyteDropdown.cachePreviousVal.pos + 1;
			}
			else {
				for( i = 0; i < children.length; i++ ) {
					if(children[ i ].textContent.substring( 0, _lyteDropdown.pressedCharacter.length ).toLowerCase() === _lyteDropdown.pressedCharacter.toLowerCase() ) {
						pos = i;
						break;
					}
				}
			}
			
			if( pos != undefined ) {
				var selected = open.querySelectorAll( '.lyteDropdownSelection' );
				for(var j = 0; j< selected.length ; j++){
					selected[ j ].classList.remove( 'lyteDropdownSelection' );
				}
				children[ pos ].classList.add( 'lyteDropdownSelection' );
				var scrollDiv = open.querySelector( 'lyte-drop-body' );
				scrollDiv.scrollTop += parseInt( children[ pos ].getBoundingClientRect().top - scrollDiv.getBoundingClientRect().top );
			}

			_lyteDropdown.cachePreviousVal.char = _lyteDropdown.pressedCharacter;
			_lyteDropdown.cachePreviousVal.pos = pos;
		}

	}

});

window.addEventListener( 'resize', function( event ) {
	delete this._hgt;
	var open = document.querySelector( 'lyte-drop-box:not(.lyteDropdownHidden)' ), freeze,
	wwidth = window.innerWidth, wheight = window.innerHeight;

	if( open ) {
		open.origindd.component.setCss();
	}

	freeze = document.getElementById( 'lytedropdownfreezelayer' );
	if( !freeze ){
		return ;
	}

	freeze.style.width = wwidth + 'px'
	freeze.style.height = wheight + 'px'
});



Lyte.createCustomElement( 'lyte-drop-item', {
	static : {
		"observedAttributes" : {
			get : function() {
				return [ 'selected' ];
			}
		}
	},
	"attributeChangedCallback": function(attr, oldValue, newValue, namespace) {
		var cur = this, drp, component, type, sel, last, res,
		src = this.getAttribute( 'data-value' );
		if( attr == 'selected' ) {
        	if( this.hasAttribute( 'selected' ) ) {
          		while( 
          			cur.tagName != 'LYTE-DROP-BOX' 
          			&& cur.tagName != 'BODY' 
          		) {
            		cur = cur.parentElement;
          		}

          		if ( cur.tagName == 'HTML' ) {
            		return;
          		}

          		drp = cur.origindd;
          		if ( !drp ) {
            		while( 
            			cur.tagName != 'LYTE-DROPDOWN' 
            			&& cur.tagName != 'BODY' 
            		) {
              			cur = cur.parentElement;
            		}

            		drp = cur;
          		}

          		component = drp.component;
          		type = component.getData( 'ltPropType' );

          		if ( type == 'multiple' 
          			|| type == 'multisearch'
          		) {
            		sel = component.getData( 'ltPropSelected' );
            		if ( sel.length == 2 ) {
              			sel = '["' + src + '"]';
              			// not setting prev to true here
              			component.setData( 'ltPropSelected', sel );
            		} 
            		else {
              			last = sel.indexOf( ']' );
              			res = sel.substring( 0, last ) + ',"' + src + '"]';
              			// not setting prev to true here
              			component.setData( 'ltPropSelected', res );
            		}
          		} 
          		else {
            		component.setData('ltPropSelected', src);
          		}
        	}
      	}
	}
});

_lyteDropdown = {
	/** 
	 * Checks if the current target is an input within the dropdown and with no value
	 * @param event - the keydown event
	 *
	 */

	// Initialize variables
	pressedCharacter : null,

	checkDDtimeoutId : null,

	cachePreviousVal : {},

	isInput: function( event ) {
		// There maybe a case when a dropdown might be opened on pressing on an input with toggle. When backspace is pressed
		// on that input the global event handler for keydown might misbehave by trying to remove the last item
		// Fix is to check if the input is present inside the open dropdown
		var open = event.target;

		while( open && open.tagName !== 'LYTE-DROPDOWN' ) {
			open = open.parentElement;
		}

		if( open 
			&& event.target.tagName === 'INPUT' 
			&& event.target.type === 'text'
			&& !event.target.value 
		) {
			return true;
		}

		return false;
	},

	unmark: function( comp ) {
		var nodes = document.querySelectorAll( '.lyteDropMark' ), 
		i = 0, len = nodes.length, par;

		for( ; i < len; i++ ) {
			//nodes[ i ].classList.remove( 'lyteDropMark' );
			par = comp ? _lyteDropdown.findParent( nodes[ i ] ) : undefined;
			par && par == comp.$node ? undefined : nodes[ i ].classList.remove( 'lyteDropMark' );
		}
	},

	findParent: function( node ) {
		while( node && node.tagName !== 'LYTE-DROPDOWN' ) {
			node = node.parentElement;
		}

		return node;
	},

	getActive: function() {
		var node = document.querySelector( '.lyteDropMark' );
		while( node && node.tagName !== 'LYTE-DROPDOWN' ) {
			node = node.parentElement;
		}

		return node;
	}
}




Lyte.createCustomElement( "lyte-drop-group", {
	static : {
		"observedAttributes": {
			get : function() {
				return [ 'label' ];
			}
		}
	},
	"attributeChangedCallback": function( attr, oldValue, newValue, namespace ) {
		var node, value;

		if ( attr == 'label' ) {
            node = this.querySelector('lyte-drop-label');
            value = this.getAttribute('label');
            if ( node ) {
                node.textContent = value;
            } 
            else {
                node = document.createElement('lyte-drop-label');
                node.textContent = value;
                this.insertBefore( node, this.children[ 0 ] );
            }
        }
	}
});

Lyte.Component.register('lyte-gridstack', {
_template:"<template tag-name=\"lyte-gridstack\">\t\t<lyte-yield yield-name=\"lyteGridStack\">\t\t</lyte-yield></template>",
_dynamicNodes : [{"type":"insertYield","position":[1]}],
_observedAttributes :["ltPropScope","ltPropHandler","ltPropMarginLeft","ltPropMarginTop","ltPropUnitX","ltPropUnitY","ltPropResizeDirection","ltPropFloat","ltPropDirection","ltPropUndo","ltPropResize","ltPropBestfit","ltPropMinUnitX","ltPropMinMarginLeft","ltPropBestfitClass","ltPropFreezeMode","ltPropDefaultLength","ltPropDefaultHeight","ltPropDefaultMinLength","ltPropDefaultMinHeight","ltPropDefaultMaxHeight","ltPropDefaultMaxLength","ltPropColumnMode","ltPropColumn","ltPropPrevent","ltPropGridLength","ltPropBestfitType","ltPropForcedReposition","ltPropSquareGrid","ltPropGridSpaceColor","ltPropHitBottom","ltPropGridSelectionClass","ltPropVisibleBoundary","ltPropVisible","gridLength","ltPropGridHeight","ltPropMarginLeftCopy","ltPropUnitXCopy","lyteGridStack","elements","oriNode","xElements","yElements","iniData","lyteQuerySelector"],
    init : function(){
        this._childGrids = [];
        this.freeezeModeObs.call(this, this.getData('ltPropFreezeMode'));
        if(this.getMethods('beforeRender'))
            {
                this.executeMethod('beforeRender', this.$node);
            }
    }, 
    didDestroy : function(){
        document.removeEventListener('keydown', this.getData('lyteQuerySelector').keydown);
        window.removeEventListener('resize', this._resizeFunc, true);
        document.removeEventListener( 'click', this._click );
        this.$node.removeEventListener( 'scroll', this._scroll, true);
        if(this._parentGrid){
            Lyte.arrayUtils(this._parentGrid.component._childGrids, 'removeAt',  this._parentGridIndex)
        }

        if(this._parentComp){
            delete this._parentComp._childGrid;
        }
         
        if(document._lyteCurrentGrid == this){
            delete document._lyteCurrentGrid;
        }
    },

    windowResize : function(){
        clearTimeout(window._gridResize)
        window._gridResize = setTimeout(function(){
            var minX = this.getData('ltPropMinUnitX'), minLeft = this.getData('ltPropMinMarginLeft'), maxX = this.getData('ltPropUnitX'), maxLeft = this.getData('ltPropMarginLeft') 
            if(this._initialWindowWidth > window.innerWidth)
                {
                     var wid = this.scopeElement.getBoundingClientRect().width;
                     var ltPropUnitX = this.getData('ltPropUnitX');
                     var temp1 = parseInt((this._initialXRatio * wid).toFixed(1)), temp2 = parseInt((this._initialXRatio * wid * this._initialMarginRatio).toFixed(1));
                     this.setData('ltPropUnitXCopy', Math.min(Math.max(temp1 ,minX), maxX))
                     this.setData('ltPropMarginLeftCopy', Math.min(Math.max(temp2 ,minLeft), maxLeft));
                }
            else if(this._initialWindowWidth <= window.innerWidth)
                {
                    this._initialWindowWidth = window.innerWidth;
                    this.setData('ltPropUnitXCopy', this.getData('ltPropUnitX'));
                    this.setData('ltPropMarginLeftCopy', this.getData('ltPropMarginLeft'));
                }  
            // if(this._initialWindowWidth != window.innerWidth) {     
                this.MarginLeftAndXObs.call(this, true);
                this.observerFunc.call(this); 
            // }
            delete window._gridResize;
            if(this.getMethods('onWindowResize'))
                {
                    this.executeMethod('onWindowResize', event, this.$node);
                }
        }.bind(this), 250);    
    },

    MarginLeft : function(){
       this.MarginLeftAndXObs.apply(this, arguments);
    }.observes('ltPropMarginLeft', 'ltPropUnitX'),

    MarginLeftAndXObs : function(flag){
        if(flag.constructor == Object)
            {
                this.setData('ltPropUnitXCopy', this.getData('ltPropUnitX'));
                this.setData('ltPropMarginLeftCopy', this.getData('ltPropMarginLeft'));
            }
        var ltPropUnitXCopy = this.getData('ltPropUnitXCopy')
        var margin = this.getData('ltPropMarginLeftCopy')
        this.setData('gridLength', parseInt(((this.scopeElement.getBoundingClientRect().width - margin) / (ltPropUnitXCopy + margin)).toFixed(0)))
    },

    squareGridObs :  function() {
        if(arguments[0].newValue) {
            this._originalY = this.getData( 'ltPropUnitY' );
            this.setData( 'ltPropUnitY', this.getData( 'ltPropUnitX' ) );
        } else {
            if(this._originalY) {
                this.setData( 'ltPropUnitY', this._originalY );
                delete this._originalY;
            } else {
                this.setData( 'ltPropUnitY', 50 );
            }
        }
    }.observes( 'ltPropSquareGrid' ),

    obsfunc : function(){
        if(this.getData('ltPropSquareGrid')){
            if(arguments[0].item == "ltPropUnitX"){
                this.setData('ltPropUnitY', arguments[0].newValue)
            }else if(arguments[0].item == "ltPropUnitY"){
                this.setData('ltPropUnitX', arguments[0].newValue)
            }
       }
      if(!this._prevObs){
            this.observerFunc.apply(this, arguments);
        }
    }.observes('ltPropUnitX', 'ltPropUnitY', 'ltPropMarginLeft', 'ltPropMarginTop'),

    observerFunc : function(flag){
        var style = this._style;
        if(style){
            this.$node.removeChild(style);
            delete this._style;
            this.initialValSet.call(this, null, !flag);
        }
    },

    freezeobs : function(){
        this.freeezeModeObs.apply(this, arguments);
    }.observes('ltPropFreezeMode'),

    freeezeModeObs : function(arg){
        if(arg.constructor == Object || arg.constructor == Boolean){
            if(arg.oldValue == false || arg == true){
                this.$node.classList.add('gridFreezeMode');
            }
            else if(arg.oldValue == true || arg == false){
                this.$node.classList.remove('gridFreezeMode');
            }
        }
    },

    columnMode : function(arg){
        if(arg.newValue == false)
            {
                 var handQuer = this.getData('ltPropHandler');
                 var iniData = this.getData('iniData');
                 var elements = (/^#/g.test(handQuer) && !/\s/g.test(handQuer)) ? this.scopeElement.querySelectorAll(handQuer) : $L(handQuer, this.scopeElement).e;
                 for(var i = 0; i < elements.length; i++)
                    {
                        for(var yy in iniData[i])
                            {
                                // elements[i].removeAttribute('lyte-grid-' + yy);
                                if(iniData[i][yy])
                                    {
                                        elements[i].setAttribute('lyte-grid-' + yy, iniData[i][yy]);
                                    }
                            }
                    }
                if( this.data.ltPropUnitX == ( this._originalX || this.getData( 'ltPropUnitXCopy' ) )){
                    this.initialValSet( true )
                } else {
                    this.setData('ltPropUnitX', this._originalX || this.getData( 'ltPropUnitXCopy' ));
                }    
            } else {
                this._originalX = this.getData('ltPropUnitXCopy')
                if( arg.item != 'ltPropForcedReposition' ) {
                    this.columnModeLengthFind();
                    this.setData('gridLength', this.gridLength(null, this.getData('ltPropUnitXCopy')));
                }
                this.initialValSet.call(this);
            }
    }.observes('ltPropColumn', 'ltPropColumnMode', 'ltPropForcedReposition' ),

    bestFitObs : function(arg){
        var bestfit  = this._bestfit;
        if(bestfit){
                if(arg.newValue){
                        bestfit.classList.add(arg.newValue);
                    }
                if(arg.oldValue){
                        bestfit.classList.remove(arg.oldValue);
                    }
            }
    }.observes('ltPropBestfitClass'),

    bfObs : function() {
        var bf = this.getData( 'ltPropBestfit' ), bftype = this.getData( 'ltPropBestfitType' )
        if( bf && bftype == 'grid' ) {
                var color = this.getData( 'ltPropGridSpaceColor' ), MarginLeft = this.getData( 'ltPropMarginLeftCopy' ), marginTop = this.getData( 'ltPropMarginTop' ), unitX = this.getData( 'ltPropUnitXCopy' ), unitY = this.getData( 'ltPropUnitY' );
                this.scopeElement.style.backgroundImage = 'linear-gradient(to right,' + color +' ' + MarginLeft + 'px,transparent 0px),linear-gradient(to bottom,'+ color + ' ' + marginTop + 'px,transparent 0px)'; 
                this.scopeElement.style.backgroundSize = ( unitX + MarginLeft ) + 'px ' + ( unitY + marginTop ) + 'px';
                if( this._bestfit ) {
                    if( arguments[0].newValue == 'grid' ) {
                        this._bestfit.classList.add('lyteGrid')
                    }
                    this._bestfit.style.transform = "translate(-" + MarginLeft + "px,-" + marginTop +"px)"

                }
        } else if( !bf || bftype == 'default' ) {
            this.scopeElement.style.removeProperty( 'background-image' );
            this.scopeElement.style.removeProperty( 'background-size' )
            if( this._bestfit ) {
                this._bestfit.style.removeProperty( 'background-image' );
                this._bestfit.style.removeProperty( 'background-size' );
                this._bestfit.style.removeProperty( 'transform' );
                if( arguments[0].newValue == 'default' ) {
                    this._bestfit.classList.remove('lyteGrid')
                }
            }
        }
    }.observes( 'ltPropBestfit', 'ltPropBestfitType' ),

    lengthObs : function(){
        this.setData('gridLength', 0);
        this.$node.reRender();
    }.observes('ltPropGridLength'),

    gridColorObs :  function(arg) {
          if( this.getData( 'ltPropBestfitType' ) == 'grid' && this.getData( 'ltPropBestfit' )) {
                this.scopeElement.style.backgroundImage = 'linear-gradient(to right,' + arg.newValue +' ' + this.getData( 'ltPropMarginLeftCopy' ) + 'px,transparent 0px),linear-gradient(to bottom,'+ arg.newValue + ' ' + this.getData( 'ltPropMarginTop' ) + 'px,transparent 0px)'; 
            }
    }.observes('ltPropGridSpaceColor'), 

    dataSetting : function(elements1, i, columnMode, column,gridLength){
        var data1 = {x : undefined, y : undefined, length : 1, height : 1, nodeName : '', preX : [], preY : [], preLength : [], preHeight : [], component : undefined}
        if(!columnMode)
            {
                data1 = this.initialPosFind.call(this, elements1);
            }
        else
            {
                var tem = parseInt(gridLength / column);
                data1.x = undefined;
                data1.y = undefined;
                data1.length = tem;
                data1.height = parseInt(this.getData('ltPropDefaultHeight'));
                this._dopeHgt = data1.height;
            }    
        data1.nodeName = elements1;
        data1.nodeName.dataSet = {};
        data1.oldX = []; 
        data1.oldY = []; 
        data1.oldLength = []; 
        data1.oldHeight = []; 
        elements1.elemNum = i;
        data1.minLength = elements1.getAttribute('lyte-grid-min-length') ? this.returnWid(elements1.getAttribute('lyte-grid-min-length'), true) : this.returnWid(this.getData('ltPropDefaultMinLength'), true);
        data1.minHeight = elements1.getAttribute('lyte-grid-min-height') ? this.returnWid(elements1.getAttribute('lyte-grid-min-height')) : this.returnWid(this.getData('ltPropDefaultMinHeight'));
        data1.maxLength = elements1.getAttribute('lyte-grid-max-length') ? this.returnWid(elements1.getAttribute('lyte-grid-max-length'), true) : this.returnWid(this.getData('ltPropDefaultMaxLength'), true);
        data1.maxHeight = elements1.getAttribute('lyte-grid-max-height') ? this.returnWid(elements1.getAttribute('lyte-grid-max-height')) : this.returnWid(this.getData('ltPropDefaultMaxHeight'));
        data1.component = this;
        return data1;
    },

    append : function(element, classes, clsName, resizeDir){
        $L.fastdom.mutate(function(){
             var divElem = document.createElement('div');
             divElem.setAttribute('class', classes[clsName.indexOf(resizeDir)] + " lyteGridResize");
             element.appendChild(divElem);
        })
    },

    maxPosFind : function(elements, lyteQuerySelector, columnMode, data, flag){
        var  b = [], a = [], c = [], d = [];
        for(var i = 0; i < elements.length; i++ )
                {
                    if(!flag){
                        var retVal = this.emptySpaceFind.call(this, {length : data[i].length, height : data[i].height, x : data[i].x, y : data[i].y, nodeName : data[i].nodeName});
                        if(!elements[ i ]._addGrid || columnMode )
                            {
                                data[i].x = retVal[0].x;
                                data[i].y = retVal[0].y;
                            }  
                        if( elements[ i ]._addGrid ){
                            delete elements[ i ]._addGrid;
                          }  
                        }
                    a.push(data[i].length);             
                    b.push(data[i].height);
                    c.push(data[i].y + data[i].height) 
                    d.push(data[i].x + data[i].length) 
                }
         if(!flag){           
            this.previousPos.call(this, elements, true)
        }
        lyteQuerySelector.MaxLength = Math.max.apply(null, a.length ? a : [ 0 ]); 
        lyteQuerySelector.MaxHeight = Math.max.apply(null, b.length ? b : [ 0 ]); 
        lyteQuerySelector.MaxBottom = Math.max.apply(null, c.length ? c : [ 0 ]);
        lyteQuerySelector.MaxLeft = Math.max.apply(null, d.length ? d : [ this.getData('gridLength') ]);
    },

    // default css construction and getting data from grids
    initialValSet : function(styleFlag, resizeFlag){
    // collecting data and calculating max height and width of the scope
        var lyteQuerySelector = this.getData('lyteQuerySelector');
        var data = this.getData('lyteGridStack');
        var scope = $L(this.getData('ltPropScope'), this.$node).e[0];
        var ltPropUnitXCopy =  parseInt(this.getData('ltPropUnitXCopy')), ltPropUnitY =  parseInt(this.getData('ltPropUnitY')), ltPropUnitX =  parseInt(this.getData('ltPropUnitX'));
        var ltPropMarginTop = parseInt(this.getData('ltPropMarginTop')), ltPropMarginLeftCopy = parseInt(this.getData('ltPropMarginLeftCopy'))
        var gridLength  = parseInt(this.getData('gridLength')), columnMode = this.getData('ltPropColumnMode'), column = this.getData('ltPropColumn');
        var thisnodeClient = this.bcrrelem ? this.bcrrelem : this.scopeElement.getBoundingClientRect();
        var resizeDir = this.getData('ltPropResizeDirection');
        lyteQuerySelector.occupied = [];
        lyteQuerySelector.currentPos = 0;
        lyteQuerySelector.verticalMove = true;
        var elements = $L(this.getData('ltPropHandler'),scope).e;
        scope.dataSet = {};
        lyteQuerySelector.elementCount = [];
        if(!resizeFlag)
            {
                for(var i = 0; i < elements.length; i++ )
                    {
                        data[i] = this.dataSetting.call(this, elements[i], i, columnMode, column, gridLength);
                        lyteQuerySelector.elementCount.push(i);
                        if(this.getData('ltPropResize') == true)
                            {
                                var prevResize = $L('.lyteGridResize', data[i].nodeName).e;
                                if(prevResize.length == 0 && data[i].nodeName.getAttribute('lyte-grid-resize') != "disabled")
                                    {
                                        for(var j = 0;j < resizeDir.length;j++ )
                                            {
                                                var classes = ['lyteGridStackLeft', 'lyteGridStackRight', 'lyteGridStackBottom', 'lyteGridStackBottomLeft', 'lyteGridStackBottomRight', 'lyteGridStackTop', 'lyteGridStackTopLeft', 'lyteGridStackTopRight'];
                                                var clsName = ['left', 'right', 'bottom', 'bottomLeft', 'bottomRight', 'top', 'topLeft', 'topRight']
                                                if(clsName.indexOf(resizeDir[j]) != -1)
                                                    {
                                                        this.append(elements[i], classes, clsName, resizeDir[j])
                                                    }
                                            }
                                    }
                            }
                    }
                 this.maxPosFind(elements, lyteQuerySelector, columnMode, data)   
                 
        }
        if(this._initialWindowWidth == window.innerWidth){
            this._initialXRatio = ltPropUnitX / thisnodeClient.width;
            this._initialMarginRatio = this.getData('ltPropMarginLeft') / ltPropUnitX  
        }
        $L.fastdom.mutate(function(){
            scope.style.height = ((lyteQuerySelector.MaxBottom) * ltPropUnitY + ((lyteQuerySelector.MaxBottom + 1) * parseInt(this.getData('ltPropMarginTop')))) + 'px'  
            if(this.getData('ltPropBestfitType') == "grid" && this.getData( 'ltPropBestfit' )){
                var color = this.getData('ltPropGridSpaceColor');
                this.scopeElement.style.backgroundImage = 'linear-gradient(to right,' + color +' ' + ltPropMarginLeftCopy + 'px,transparent 0px),linear-gradient(to bottom,'+ color + ' ' + ltPropMarginTop + 'px,transparent 0px)'; 
                this.scopeElement.style.backgroundSize = ( ltPropUnitXCopy + ltPropMarginLeftCopy ) + 'px ' + ( ltPropUnitY + ltPropMarginTop ) + 'px';
            }
        }.bind(this))
        if(!styleFlag)    
                {
                    var style = this._style, elem
                    if(!style)     
                        {
                            style = document.createElement('style');
                            style.type = "text/css";
                            style.id = "lyteGridStack";
                            this._style = style;
                            $L.fastdom.mutate(function(){
                                this.$node.appendChild(style)
                            }.bind(this))
                        }
                     var hand = $L(this.getData('ltPropHandler'), this.$node).e;
                     if(hand && hand.length){
                        $L(this.getData('ltPropHandler'), this.$node).addClass('lyteGridstackHandler');
                     }   
                    // Constructing initial CSS     
                    var totalWid = thisnodeClient.width, elem;
                    this._initialXRatio = ltPropUnitXCopy / thisnodeClient.width;
                    this._initialMarginRatio = this.getData('ltPropMarginLeft') / ltPropUnitX 
                    for(var i = 1;i <= Math.max(gridLength , lyteQuerySelector.MaxBottom) + 1;i++ )
                        {
                            if(i <= gridLength)
                                {
                                    if( $L( '.' + this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridx" + (i-1), this.$node).e.length == 0 ) {
                                        elem = this.getData('ltPropScope') + " " + this.getData('ltPropHandler') + "[lyte-grid-x = \"" + (i-1) + "\"]{left:" +  (((i - 1) * ltPropUnitXCopy + (i * ltPropMarginLeftCopy )) *100/totalWid) + "%;}"
                                        this.styleFormation.call(this, elem, this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridx" + (i-1))
                                    }
                                    if( i <= gridLength && $L( '.' + this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridlength" + (i-1), this.$node).e.length == 0 )
                                        {
                                            elem = this.getData('ltPropScope') + " " +this.getData('ltPropHandler') + "[lyte-grid-length = \"" + i + "\"]{width:" +  ((i * ltPropUnitXCopy + ((i - 1) * ltPropMarginLeftCopy)) * 100 / totalWid) + "%;}"
                                            this.styleFormation.call(this, elem, this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridlength" + (i-1) )
                                        }
                                }
                            if(i <= lyteQuerySelector.MaxBottom + 1)
                                {
                                    if( $L( '.' + this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridy" + (i-1) , this.$node).e.length == 0 ) {
                                        elem =this.getData('ltPropScope') + " " + this.getData('ltPropHandler') + "[lyte-grid-y = \"" + (i-1) + "\"]{top:" + ((i - 1) * ltPropUnitY + (i * ltPropMarginTop)) + "px;}"
                                        this.styleFormation.call(this, elem, this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridy" + (i-1))
                                    }
                                    if(i <= lyteQuerySelector.MaxHeight && $L( '.' + this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridheight" + (i-1), this.$node).e.length == 0)
                                        {
                                            elem =this.getData('ltPropScope') + " " + this.getData('ltPropHandler') + "[lyte-grid-height = \"" + i + "\"]{height:" + (i * ltPropUnitY + (i - 1) * ltPropMarginTop) + "px;}"
                                            this.styleFormation.call(this, elem, this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridheight" + (i-1))
                                        }
                                }   
                        }
                    this.setData('ltPropGridHeight', lyteQuerySelector.MaxBottom)
            }
        this.displayGrid.call(this, null);  
        if(this.bcrrelem){
            delete this.bcrrelem;
        }
    }, 
    // function for finding maximum height of the scope 
    maxHeight : function(data){
            var elements = $L(this.getData('ltPropHandler'), $L(this.getData('ltPropScope'), this.$node).e[0]).e;
            var b = [], a = [], c = [];
            for(var i = 0;i < elements.length;i++ )
                {   
                    a.push(data[i].length);             
                    b.push(data[i].height);
                    c.push(data[i].y + data[i].height)
                }
            return [Math.max.apply(null,a), Math.max.apply(null,b), Math.max.apply(null,c)] 
    }, 
    // function for Constructing css dynamically while changing lyte-grid-y && lyte-grid-length && lyte-grid-height
    styleFormation : function(elem, id){
                 $L.fastdom.mutate(function(){
                    if( $L( '.' + id, this.$node).e.length == 0 ) {
                        var style = document.createElement('style');
                        style.type = "text/css";
                        style.setAttribute('class',id)
                        this._style.appendChild(style)
                        style.append(elem)
                    }
                }.bind(this))
    }, 
    // Checking and initiating css construction
    cssConstruct : function(target, attributeName, faldd){
        var data = this.getData('lyteGridStack'), scope = $L(this.getData('ltPropScope'), this.$node).e[0], lyteQuerySelector = this.getData('lyteQuerySelector'), elem;
        var lyteGridHeight  = this.returnWid(target.getAttribute('lyte-grid-height'), null, target), lyteGridLength  = this.returnWid(target.getAttribute('lyte-grid-length'), true, target), lyteGridX  = parseInt(target.getAttribute('lyte-grid-x')),lyteGridY = parseInt(target.getAttribute('lyte-grid-y'))
        var ltPropUnitXCopy = this.getData('ltPropUnitXCopy'), ltPropUnitY = this.getData('ltPropUnitY'), ltPropMarginTop = this.getData('ltPropMarginTop'), ltPropMarginLeftCopy = this.getData('ltPropMarginLeftCopy')
        // Checking for height
        if(attributeName == "lyte-grid-height")
            {   
                 if(lyteGridHeight > lyteQuerySelector.MaxHeight)
                    {   
                        for(var i = lyteQuerySelector.MaxHeight + 1;i <= (lyteGridHeight);i++ )
                            {
                                if( $L( '.' + this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridheight" + (i + 1), this.$node).e.length == 0  ) {
                                    elem =this.getData('ltPropScope') + " " + this.getData('ltPropHandler') + "[lyte-grid-height = \"" + ((i) + "\"]{height:" + (i * ltPropUnitY + ((i - 1) * ltPropMarginTop))) + "px;}"
                                    this.styleFormation.call(this, elem, this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridheight" + (i + 1))
                                }
                            }
                    }
            }
        // Checking for top position    
        else if(attributeName == "lyte-grid-y")
            {
                if((lyteGridY + (lyteGridHeight)) >= (lyteQuerySelector.MaxBottom))
                    {
                        for(var i = lyteQuerySelector.MaxBottom - lyteGridHeight; i <= (lyteGridY + lyteGridHeight); i++ )
                            {
                                if( $L( '.' + this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridy" + (i), this.$node).e.length == 0 ) {
                                    elem =this.getData('ltPropScope') + " " + this.getData('ltPropHandler') + "[lyte-grid-y = \"" + (i) + "\"]{top:" + ((i) * ltPropUnitY + (i + 1) * ltPropMarginTop) + "px;}"
                                    this.styleFormation.call(this, elem, this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridy" + (i))
                                }
                            }
                        lyteQuerySelector.previousNode = target   
                    }
            }
         if(["lyte-grid-height", "lyte-grid-y"].indexOf(attributeName) != -1){
               var ret = this.maxHeight(data);
               this.setData('ltPropGridHeight', ret[2])
               if(lyteQuerySelector.MaxBottom > ret[ 2 ])
                    {
                        for(var j = lyteQuerySelector.MaxBottom;j > ret[2];j--)
                            {
                                if($L('.'+this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridy" + (j), this.$node).e[0])
                                    {
                                        var temporary = this._style
                                        if(temporary)
                                            {
                                                var dummy = $L('.'+this.getData('ltPropHandler').replace(/[.|#]/gi,'') + "lytegridy" + (j), this.$node).e[0]
                                                if(dummy && dummy.parentElement == temporary)
                                                    {
                                                        // unused styles are removed here
                                                        temporary.removeChild(dummy)
                                                    }
                                            }
                                    }
                            }
                    } 
               lyteQuerySelector.MaxBottom = ret[2]   
           }   
            scope.style.height = ((lyteQuerySelector.MaxBottom) * ltPropUnitY + ((lyteQuerySelector.MaxBottom + 1) * ltPropMarginTop)) + 'px'        
        }, 
    // initiating css construction  
    setVal : function(target, attributeName, attributeValue){
        // $L.fastdom.mutate(function(){t 
            // can't use fastdom here because of delay causes issue caching previous data
            // if( target.getAttribute( attributeName ) != attributeValue ) {
                target.setAttribute(attributeName, attributeValue);
            // }
                if(attributeName == 'lyte-grid-y' || attributeName == 'lyte-grid-height' || attributeName == 'lyte-grid-length' || attributeName == 'lyte-grid-x')
                    {
                        this.cssConstruct.call(this, target, attributeName)
                    }
                target.dataSet[attributeName] = attributeValue; 
        // }.bind(this))
    }, 
    // initiating css construction  and finding grid positions
    displayGrid : function(x, flag){
                var elements = $L(this.getData('ltPropHandler'), this.scopeElement).e, lyteQuerySelector = this.getData('lyteQuerySelector');
                var data = this.getData('lyteGridStack');
                for(var k = 0;k < elements.length;k++ )
                    {
                        if((k != x) && !flag || (flag && k == x))
                            {
                                this.setVal(elements[k], 'lyte-grid-y', data[k].y)  
                                this.setVal(elements[k], 'lyte-grid-x', data[k].x)
                                if(data[k].length != data[k].nodeName.getAttribute('lyte-grid-length-old'))
                                    {   
                                        this.setVal(elements[k], 'lyte-grid-length', data[k].length, true)
                                    }
                                if(data[k].height != data[k].nodeName.getAttribute('lyte-grid-height-old'))
                                    {
                                        this.setVal(elements[k], 'lyte-grid-height', data[k].height)
                                    }
                            }
                    }
                this.scopeElement.dataSet['lt-prop-grid-height'] = lyteQuerySelector.MaxBottom
                this.scopeElement.dataSet['lt-prop-grid-length'] = parseInt(this.getData('gridLength'))   
                 $L.fastdom.mutate(function(){
                     this.positionFind.call(this, elements)
                 }.bind(this))
                        
        }, 
    // To find all grid positions   
    positionFind : function(elements){
                elements = elements || $L(this.getData('ltPropHandler'), this.scopeElement).e;
                var xCor = [], yCor = [], xCorEnd = [], yCorEnd = [], x = [], y = [], a = [], b = [], Max, data = this.getData('lyteGridStack');
                for(var k = 0;k < elements.length;k++ )
                    {
                        x.push(data[k].x);
                        y.push(data[k].y);
                        a.push(data[k].x + data[k].length);
                        b.push(data[k].y + data[k].height);
                    }
                Max = Math.max(Math.max.apply(null,x), Math.max.apply(null,y), Math.max.apply(null,a), Math.max.apply(null,b));
                for(var j = 0;j <= Max;j++ )
                    {
                        x = [], y = [], a = [], b = [];
                        for(var i = 0;i < data.length;i++ )
                            {   
                                if(data[i].x <= j && j <= data[i].x + data[i].length)
                                    {
                                        x.push(i);
                                    }   
                                if(data[i].y <= j && j <= data[i].y + data[i].height)
                                    {
                                        y.push(i);
                                    }               
                            }
                        xCor.push(x);
                        yCor.push(y);
                    }
                Lyte.arrayUtils(this.data.xElements, 'remove', 0, this.data.xElements.length)
                Lyte.arrayUtils(this.data.xElements, 'concat', xCor)    
                Lyte.arrayUtils(this.data.yElements, 'remove', 0, this.data.yElements.length)
                Lyte.arrayUtils(this.data.yElements, 'concat', yCor)      
       
    }, 
    // To remove same elements from Checking    
    multipleRemoval : function(elementsToCheck){
            elementsToCheck = elementsToCheck || [];
            for(var z = 0;z < elementsToCheck.length;z++ )
                {
                    for(var y = z + 1;y < elementsToCheck.length;y++ )
                    {
                        if(elementsToCheck[z] == elementsToCheck[y])
                        {
                            Lyte.arrayUtils(elementsToCheck, 'removeAt', y)
                            y--;
                        }
                    }
                }
             return elementsToCheck 
    }, 
    // To check elements in hori and vertical directions
    similarData : function(elementsToCheck1, elementsToCheck2){
            var temp = []
            if(!(elementsToCheck1 == undefined || elementsToCheck2 == undefined))
                {
                    for(var i = 0;i < elementsToCheck1.length;i++ )
                        {
                            for(var j = 0;j < elementsToCheck2.length;j++ )
                                {
                                    if(elementsToCheck1[i] == elementsToCheck2[j])
                                        {
                                            temp.push(elementsToCheck1[i]);
                                            break;
                                        }
                                }
                        }
                }
            else
                {
                    temp = elementsToCheck1 ? elementsToCheck1 : elementsToCheck2;
                }   
            return temp;    
    }, 
    // To find the other elements on selected element
    elementCheck : function(element, node, flag){
            var elementsToCheck = [], k, xElements = this.getData('xElements'), dum = 1;
             var data = this.getData('lyteGridStack');
            if(data[node.elemNum].length > 1)
                {
                    if(flag)
                        {
                            k = data[node.elemNum].x
                            dum = 0;
                        }
                    else
                        {
                             k = data[node.elemNum].x + 1;
                        } 
                   elementsToCheck = this.yElementsFind( k, data[node.elemNum].x + data[node.elemNum].length - dum, xElements)       
                }
            else
                {
                    elementsToCheck = this.similarData.call(this, xElements[data[node.elemNum].x], xElements[data[node.elemNum].x + 1])
                }
            if(elementsToCheck)                 
                {
                    return this.multipleRemoval.call(this, elementsToCheck);    
                }
            else
                {
                    return [];
                }   
    }, 
    // To find clicked Pos
    nodeName : function(event){
            var nodeName = event.target;
            if(nodeName)
            {
                var flag = false, val;
                var element = $L(this.getData('ltPropScope'), this.$node).e[0];
                if( event.type == 'mousedown') {
                    while(nodeName != element && nodeName.tagName != "BODY" && nodeName.tagName != "HTML")
                        {
                            if(nodeName.classList.contains('lyteGridStackLeft'))
                                {
                                    val = 'left'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackRight'))
                                {
                                    val = 'right'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackBottom'))
                                {
                                    val = 'bottom'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackBottomLeft'))
                                {
                                    val = 'BottomLeft'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackBottomRight'))
                                {
                                    val = 'BottomRight'
                                    flag = true
                                    break;
                                } 
                            else if(nodeName.classList.contains('lyteGridStackTop'))
                                {
                                    val = 'top'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackTopLeft'))
                                {
                                    val = 'topLeft'
                                    flag = true
                                    break;
                                }
                            else if(nodeName.classList.contains('lyteGridStackTopRight'))
                                {
                                    val = 'topRight'
                                    flag = true
                                    break;
                                }       
                            else if(nodeName.tagName == 'LYTE-GRID-CONTENT')
                                {
                                    val = 'content'
                                    flag = true
                                    break;
                                }           
                            else
                                {
                                    nodeName = nodeName.parentElement;
                                } 
                        }
                    if(nodeName != element && flag)
                        {
                            return [val, nodeName.parentElement, nodeName.parentElement.parentElement];
                        }
                } else if( event.type == 'click' ) {
                    while( nodeName != element && nodeName.tagName != "BODY" && nodeName.tagName != "HTML" ) {
                        if( nodeName.classList.contains( 'lyteGridstackHandler' )  && $L( '.lyteGridResize', nodeName ).e.length) {
                            flag = true;
                            break;
                        } else {
                            nodeName = nodeName.parentElement;
                        } 
                    }
                    if( flag ) {
                        return nodeName
                    }
                }
            }
         return null;
    },
    // updating value on every changes 
    valueUpdating : function(i, x, attributeName){
        var data = this.getData('lyteGridStack')
        if(data[i][x] != data[i].nodeName.dataSet[attributeName])
            {
                data[i].nodeName.dataSet[attributeName + '-old'] =  data[i].nodeName.dataSet[attributeName]
                data[i].nodeName.dataSet[attributeName] = parseInt(data[i][x])
            }
    }, 
    // Number of elements adjacent around selected elements
    bottomElementsCount : function(node, direction){
        var x, y, length, height, yElements1, xElements1, offsetLeft, initialLeft, lytegridlength, x, ltPropMarginLeftCopy ;
        if(direction == 'vertical')
            {
                x = 'y', y = 'x', length = 'height', height = 'length', yElements1 = 'xElements', xElements1 = 'yElements', offsetLeft = 'offsetTop', initialLeft = 'initialTop', lytegridlength = 'lyte-grid-height', ltPropMarginLeftCopy ='ltPropMarginTop', ltPropUnit = 'ltPropUnitY'
            }
        else
            {
                x = 'x', y = 'y', length = 'length', height = 'height', yElements1 = 'yElements', xElements1 = 'xElements', offsetLeft = 'offsetLeft', initialLeft = 'initialLeft', lytegridlength = 'lyte-grid-length', ltPropMarginLeftCopy ='ltPropMarginLeftCopy', ltPropUnit = 'ltPropUnitXCopy'
            }
        var data = this.getData('lyteGridStack'), yElements = this.getData(yElements1), xElements = this.getData(xElements1), elementsToCheck = [], elementsToCheck1 = [], elementsToCheck2 = [];
        if(data[node.elemNum][length] > 1)
            {
                elementsToCheck = this.yElementsFind(data[node.elemNum][x] + 1, data[node.elemNum][x] + data[node.elemNum][length] - 1, xElements)
            }
        else
            {
                elementsToCheck = this.similarData.call(this, xElements[data[node.elemNum][x]], xElements[data[node.elemNum][x] + data[node.elemNum][length]])
            }  
        elementsToCheck1 = this.multipleRemoval.call(this, elementsToCheck1.concat(yElements[data[node.elemNum][y] + data[node.elemNum][height]]))
        elementsToCheck2 = this.multipleRemoval.call(this,elementsToCheck2.concat(yElements[data[node.elemNum][y]]))
        elementsToCheck = this.multipleRemoval.call(this, elementsToCheck)  
        if(elementsToCheck1.length)
            {
                Lyte.arrayUtils(elementsToCheck1, 'removeAt', elementsToCheck1.indexOf(node.elemNum));
            }
        if(elementsToCheck2.length)
            {
                Lyte.arrayUtils(elementsToCheck2, 'removeAt', elementsToCheck2.indexOf(node.elemNum));
            }
        if(elementsToCheck.length)
            {    
                Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum));
            }
        var array = [];
        array[array.length] = this.similarData.call(this, elementsToCheck, elementsToCheck1).length
        array[array.length] = this.similarData.call(this, elementsToCheck, elementsToCheck2).length
        return array;
    },

    // where selected grid direction changes
    contraFlexure : function(node,direction){
            var movement, instantPrevious, offsetTop, initialTop
            if(direction == 'x')
                {   
                     instantPrevious = 'instantPreviousX', offsetTop = 'offLeft', initialTop = 'initialLeft'
                }
            else
                {
                     instantPrevious = 'instantPreviousY', offsetTop = 'offTop', initialTop = 'initialTop'
                } 
            if((node[instantPrevious] > node[offsetTop]))
                {
                    node[initialTop][0] = node[offsetTop] 
                }
            else if(( node[offsetTop] >= node[instantPrevious]))
                {
                    node[initialTop][0] = node[offsetTop]
                }
            node[instantPrevious] = node[offsetTop] 
        },

     returnY : function(node, flag){
        var offtop, margin, unit, ret;
        if(flag) {
            offtop = "offTop", margin = this.getData('ltPropMarginTop'), unit = this.getData('ltPropUnitY')
        } else {
            offtop = "offLeft", margin = this.getData('ltPropMarginLeftCopy'), unit = this.getData('ltPropUnitXCopy')
        }
        return  parseInt( ( ( node[ offtop ] - margin ) / ( unit + margin ) ).toFixed( 0 ) );
     }, 

     scrollCheckY : function( node , thisClientRect, unitY, nodeClientRect, innHgt, event, scrollWidth, flag, flag2) {
        if( this._scrollCheck && !flag2) {
            return
        }
        this._scrollCheck = true;
        var scrollTop = "scrollTop", topPos = "top", clientY = "clientY", bottom = "bottom", prevEvY = 'prevEvY', prevEvX = 'prevEvX', clientX = "clientX", width = "height", scrWid = "scrollHeight";
        if( flag ) {
            scrollTop = "scrollLeft", topPos = "left", clientY = "clientX", bottom = "right", prevEvY = 'prevEvX', prevEvX = 'prevEvY', clientX = "clientY", width = "width", scrWid = "scrollWidth";
        }
        $L.fastdom.mutate(function(){
            if( this.$node[scrollTop] != 0 && Math.max( thisClientRect[ topPos ], 0 ) > Math.min( nodeClientRect[ topPos ], event[ clientY ] ) && !( thisClientRect[ bottom ] < nodeClientRect[ bottom ] ) && ( event[ clientY ] < node[ prevEvY ] || node[ prevEvY ] == undefined)  && Math.abs( event[ clientY ] - node[ prevEvY ]) > Math.abs( event[ clientX ] - node[ prevEvX ] )) {
                this.$node[ scrollTop ] -= 1 * unitY;
            } else if( this.$node[ scrollTop ] + thisClientRect[ width ] < ( scrollWidth - 10 ) && Math.min( thisClientRect[ bottom ], innHgt ) < Math.max( nodeClientRect[ bottom ], event[ clientY ] ) && !( thisClientRect[ topPos ] > nodeClientRect[ topPos ] ) && ( event[ clientY ] > node[ prevEvY ] || node[ prevEvY ] == undefined) && Math.abs( event[ clientY ] - node[ prevEvY ]) > Math.abs( event[ clientX ] - node[ prevEvX ] ) ) {
                this.$node[ scrollTop ] += 1 * unitY;
            } else {
                window.cancelAnimationFrame( this._reqId );
                delete this._reqId;
                delete  this._scrollCheck;
                node.prevEvX = event.clientX, node.prevEvY = event.clientY;
                return;
            }
           this._reqId = window.requestAnimationFrame( function() {
                nodeClientRect = node.getBoundingClientRect();
                this.scrollCheckY.call(this, node , thisClientRect, unitY, nodeClientRect, innHgt, event, scrollWidth, flag, true )
           }.bind( this ) ) 
        }.bind( this ) )
     },

    // Initial function on mousemove    
    mousemoveFun : function(element, event){
    event.preventDefault()    
    if( this._scrollCheck ) {
        return
    }
    var lyteQuerySelector = this.elementSorting.call(this, this.getData( 'lyteQuerySelector' ) ), data = this.getData('lyteGridStack');
    if( !lyteQuerySelector.previousPosFind ) {
        lyteQuerySelector.previousPosFind = true;
        if( this.getMethods( 'onDragStart' ) ) {
            this.executeMethod( 'onDragStart', this.retNode( lyteQuerySelector.SelectedNodes, data ), this.$node )
        }
    }
    for(var z = 0;z < lyteQuerySelector.SelectedNodes.length; z++)
        {   
            var i, j, k, flag = true, stackElements = [], stackElements1 = [], flag1 = true, flag2 = true, elementsToCheck = [], elementsToCheck1 = [], btmEl, btmEl1;
            var node = data[lyteQuerySelector.SelectedNodes[z]].nodeName;
            var xIni = node.xPos;
            var yIni = node.yPos;
            var elements = $L(this.getData('ltPropHandler'), element).e;
            var xPos = event.clientX;
            var yPos = event.clientY;
            var gridLength = this.getData('gridLength'), gridHeight = this.getData('ltPropGridHeight');
            var xElements = this.getData('xElements');
            var yElements = this.getData('yElements');
            var unitX = this.getData('ltPropUnitXCopy'), unitY = this.getData('ltPropUnitY');
            var marginTop = this.getData('ltPropMarginTop');
            var MarginLeft = this.getData('ltPropMarginLeftCopy'), dumm, prevent = this.getData('ltPropPrevent');
            node.offLeft = node.offsetLeft, node.offTop = node.offsetTop;
            node.classList.add( 'lyteGridStackMove' );
            var thisClientRect = this.$node.getBoundingClientRect(), scrollWidth = this.$node.scrollWidth, scrollHeight = this.$node.scrollHeight, nodeClientRect = node.getBoundingClientRect(), innWid = window.innerWidth, innHgt = window.innerHeight;
            if(((node.initialLeft[1]- node.offLeft) < 0))
                {
                    node.initialLeft[1] += parseInt(((-node.initialLeft[1] + node.offLeft)/unitX).toFixed(0)) * unitX
                }
            else if(((node.initialLeft[1]- node.offLeft) > 0))
                {
                    node.initialLeft[1] -= parseInt(((node.initialLeft[1]- node.offLeft)/unitX).toFixed(0))* unitX
                }   
            if(((node.initialTop[1]- node.offTop) < 0))
                {
                    node.initialTop[1] += parseInt(((-node.initialTop[1] + node.offTop)/ unitY).toFixed(0))* unitY
                }
            else if(((node.initialTop[1]- node.offTop) > 0))
                {
                    node.initialTop[1] -= parseInt(((node.initialTop[1]- node.offTop)/unitY).toFixed(0))* unitY
                }
            i = node.elemNum;
            if(data[i].length != parseInt(node.getAttribute('lyte-grid-length')) || data[i].height != parseInt(node.getAttribute('lyte-grid-height')) || ((node.offLeft < node.initialLeft[0]) && (node.offTop < node.initialTop[0])))
                {
                    flag2 = true
                }
            else if((data[i].x) == parseInt(node.getAttribute('lyte-grid-x')))
                {
                    flag2 = false
                }
            else if(node.offTop > (node.initialTop[0] + unitY))
                {
                    flag2 = false
                }           
            if(node.flag)   
                {
                    left = xPos-xIni;
                    topPos = yPos-yIni; 
                    if(!prevent.horizontal){
                        node.style.left = (left) + 'px';
                        node.offLeft = left;
                    }
                    if(!prevent.vertical){
                        node.style.top = topPos + 'px'; 
                        node.offTop = topPos;
                    }
                    var temppp = this.returnY( node );
                    if(temppp != data[i].x){
                        dumm = true
                    }
                    data[i].x = temppp > 0 ? temppp : 0;
                    data[i].x = data[i].x > (gridLength - data[i].length) ? (gridLength - data[i].length) : data[i].x;
                    this.scrollCheckY.call( this, node , thisClientRect, unitY, nodeClientRect, innHgt, event, scrollHeight)
                    this.scrollCheckY.call( this, node , thisClientRect, unitX, nodeClientRect, innWid, event, scrollWidth, true )
                }
            else
                {
                    // resizing functions
                    var minWidth = (data[i].minLength * unitX + ((data[i].minLength-1) * MarginLeft))
                    var maxWidth = (data[i].maxLength * unitX + ((data[i].maxLength-1) * MarginLeft))
                    var minHgt = (data[i].minHeight * unitY + ((data[i].minHeight-1) * marginTop));
                    var maxHgt = (data[i].maxHeight * unitY + ((data[i].maxHeight-1) * marginTop));
                    if(!prevent.horizontal && ([ 'right', 'BottomRight', 'topRight' ].indexOf( node.value ) != -1 ) && (node.xOff + xPos- nodeClientRect.left) >= unitX)
                        {
                            var tempWid = node.xOff + xPos- nodeClientRect.left;
                            if(maxWidth >= minWidth)
                                {
                                     node.style.width = Math.min(Math.max(tempWid, minWidth), maxWidth) + 'px';
                                }
                            else
                                {
                                     node.style.width = Math.max(tempWid, minWidth) + 'px';
                                }    
                            data[i].x = this.returnY( node );
                            if((node.offLeft + parseInt(node.style.width)) > ((gridLength) * unitX + ((gridLength + 1) * MarginLeft)))
                                {
                                    data[i].x = gridLength - data[i].length
                                }
                            else 
                                { 
                                    data[node.elemNum].length = parseInt(((parseInt(node.style.width) + MarginLeft)/(MarginLeft + unitX)).toFixed(0))
                                }      
                        }
                    else if(!prevent.horizontal && ([ 'left', 'BottomLeft', 'topLeft' ].indexOf( node.value ) != -1 ) && (node.xOff + Math.abs(xPos - nodeClientRect.left - nodeClientRect.width)) >= unitX)
                        {
                            var twid = nodeClientRect.width - (-node.xOff + xPos - nodeClientRect.left);
                            if(twid > 0 && twid >= minWidth && (twid <= maxWidth || maxWidth < 0))
                                {
                                    node.style.width = twid + 'px'
                                    node.style.left = (-node.xOff + xPos - nodeClientRect.left + node.offLeft) + 'px';
                                    node.offLeft = parseInt(node.style.left);
                                }
                            var newLeft = this.returnY( node)
                            if((node.offLeft + ( node.style.width ? parseInt(node.style.width) : nodeClientRect.width ) ) > ((gridLength) * unitX + ((gridLength + 1) * MarginLeft)))
                                {
                                    newLeft = gridLength - data[i].length
                                }
                            else 
                                { 

                                    data[node.elemNum].length +=  data[ i ].x - newLeft;
                                }  
                            data[ i ].x = newLeft;    
                        }   
                    data[i].x = data[i].x > (gridLength - data[i].length) ? (gridLength - data[i].length) : data[i].x; 
                    if(!prevent.vertical && ([ 'BottomRight' , 'BottomLeft', 'bottom' ].indexOf(node.value) != -1) && (node.yOff + yPos - nodeClientRect.top) >= unitY)
                        {
                            var tempHgt = node.yOff + yPos - nodeClientRect.top;
                            if(maxHgt >= minHgt)
                                {
                                    node.style.height = Math.min(Math.max(tempHgt, minHgt), maxHgt) + 'px';
                                }
                            else
                                {
                                    node.style.height = Math.max(tempHgt, minHgt) + 'px';
                                }   
                            data[node.elemNum].height = parseInt(((( node.style.height ? parseInt( node.style.height ) : nodeClientRect.height ) + marginTop)/(marginTop + unitY)).toFixed(0))                              
                        } 
                   else if(!prevent.vertical && (['top', 'topRight', 'topLeft' ].indexOf(node.value) != -1) && ( node.yOff + Math.abs( yPos - nodeClientRect.top - nodeClientRect.height ) ) >= unitY ) {
                        var twid = nodeClientRect.height - (-node.yOff + yPos - nodeClientRect.top);
                        if( twid > 0 && twid >= minHgt && ( twid <= maxHgt || maxHgt < 0 ) )
                            {
                                node.style.height = twid + 'px'
                                node.style.top = (-node.yOff + yPos - nodeClientRect.top + node.offTop) + 'px';
                                node.offTop = parseInt(node.style.top);
                            }
                        var newLeft = this.returnY( node, true)
                        newLeft  = Math.max( newLeft, 0 );
                        data[node.elemNum].height +=  data[ i ].y - newLeft;
                        data[ i ].y = newLeft; 
                   }

                   if( this._parentGrid ) {
                        node._percentHeight = ( ( node.style.height ? parseInt( node.style.height )  : nodeClientRect.height + 2 * marginTop ) * 100 / thisClientRect.height ) + '%';
                        node._percentLength = ( ( node.style.width ? parseInt( node.style.width )  : nodeClientRect.width + 2 * MarginLeft) * 100 / thisClientRect.width ) + '%';
                   }        
                } 
            var btmEl = this.bottomElementsCount.call(this, node, 'horizontal'),btmEl1 = this.bottomElementsCount.call(this, node, 'vertical')
            if(node.initialTop[0] > node.offTop && !prevent.vertical)
                {
                    this.verticalMoveBottomToTop.call(this, element, node)
                }
            else if(node.initialTop[0] < node.offTop && !prevent. vertical)
                {
                    this.verticalMoveTopToBottom.call(this, element, node)
                }
            if(!prevent.horizontal){    
                if((btmEl1[0] != 0 && (node.offLeft > node.initialLeft[0])) || !node.flag || (btmEl1[1] != 0 && node.initialLeft[0] > node.offLeft && data[node.elemNum].height <= parseInt(node.getAttribute('lyte-grid-height'))) || ((data[i].length) > node.dataSet['lyte-grid-length-old']) && data[node.elemNum].height <= parseInt(node.getAttribute('lyte-grid-height')))       
                    {
                        this.topCheck.call(this, node, element);  
                        if(!this.getData('ltPropFloat'))
                            {
                                this.topMoveFunc.call(this, node, null, null, null, true);
                            }
                    }
            }   
              // offsets are continuously changing during mousemove and grid interchanges. so it is nescessary to calculate offsets 
            if(!prevent.vertical){
                if(flag2|| (btmEl[0] == 0 && node.initialTop[0] < node.offTop) || (btmEl[1] == 0 && node.initialTop[0] > node.offTop) || !this.getData('ltPropFloat'))
                    {
                        var temp = parseInt(((node.offTop - marginTop)/(unitY + marginTop)).toFixed(0))
                        if( [ 'top', 'topLeft', 'topRight' ].indexOf( node.value ) != -1 ) {
                             data[i].y = temp
                        } else {
                            if( ( btmEl[ 0 ] == 0 && node.initialTop[ 0 ] < node.offTop ) )
                                {
                                    if( data[ i ].y <= temp ) {
                                            data[i].y = temp
                                    }
                                }
                            else if( ( btmEl[ 1 ] == 0 && node.initialTop[ 0 ] > node.offTop ) )
                                {
                                    if( data[ i ].y >= temp ){
                                            data[i].y = temp
                                    }
                                }
                        }
                        data[ i ].y = data[ i ].y > 0 ? data[ i ].y : 0;
                    }
            }
            if(dumm || data[node.elemNum].x != parseInt(node.getAttribute('lyte-grid-x')) || data[node.elemNum].length != parseInt(node.getAttribute('lyte-grid-length')) || data[node.elemNum].height != parseInt(node.getAttribute('lyte-grid-height')))    
                {    
                    this.valueUpdating.call(this, i, 'x', 'lyte-grid-x')
                    this.valueUpdating.call(this, i, 'y', 'lyte-grid-y')
                    this.valueUpdating.call(this, i, 'length', 'lyte-grid-length')
                    this.valueUpdating.call(this, i, 'height', 'lyte-grid-height')        
                    this.positionFind.call(this, elements)        
                    var l, count = 0, stackElements = [];
                    var data = this.getData('lyteGridStack');
                    if((node.initialLeft[0] > node.offLeft || node.initialLeft[0] < node.offLeft) || (node.dataSet['lyte-grid-length-old'] > data[node.elemNum].length))
                        {
                            elementsToCheck =  xElements[data[node.elemNum].x].concat(xElements[data[node.elemNum].x + data[node.elemNum].length])
                        }   
                    elementsToCheck1 = this.yElementsFind.call(this, data[node.elemNum].y + data[node.elemNum].height, lyteQuerySelector.MaxBottom, yElements)    
                    elementsToCheck = this.multipleRemoval.call(this, this.similarData.call(this, elementsToCheck, elementsToCheck1))
                    if(elementsToCheck.indexOf(node.elemNum) != -1) 
                        {
                            Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                        }
                    for(l = 0;l < elementsToCheck.length;l++ )
                        {
                            if(data[node.elemNum].y + data[node.elemNum].height <= data[elementsToCheck[l]].y + 1)
                                {
                                    if((((node.initialLeft[0] > node.offLeft) && data[elementsToCheck[l]].x == data[node.elemNum].x + data[node.elemNum].length)) || ((node.initialLeft[0] < node.offLeft) && data[node.elemNum].x == data[elementsToCheck[l]].x + data[elementsToCheck[l]].length) || (node.dataSet['lyte-grid-length-old'] - data[node.elemNum].length == 1))
                                        {
                                            var valMove = this.heightGet.call(this, data[elementsToCheck[l]].nodeName)
                                            if(!!valMove)
                                                {
                                                    flag1 = false
                                                    count = data[elementsToCheck[l]].y;
                                                    data[elementsToCheck[l]].y = data[elementsToCheck[l]].y - ( this.getData('ltPropFloat')? (data[elementsToCheck[l]].y - valMove < data[node.elemNum].y) ? data[elementsToCheck[l]].y - data[node.elemNum].y :valMove : valMove )
                                                    this.valueUpdating.call(this, elementsToCheck[l], 'y', 'lyte-grid-y')
                                                    this.positionFind.call(this, elements );
                                                    this.topMoveFunc.call(this, data[elementsToCheck[l]].nodeName, count, false, node);
                                                    this.displayGrid.call(this, node.elemNum);
                                                    break;
                                                }
                                        }
                                }
                        }
                    // this.contraFlexure.call(this, node)
                    // this.contraFlexure.call(this, node, 'x')
                    if((data[node.elemNum].y < (parseInt(node.getAttribute('lyte-grid-y'))) || (node.initialTop[0] - node.offTop > parseInt(marginTop))) && !this.getData('ltPropFloat'))
                        {
                            this.topMoveFunc.call(this, node, parseInt(node.getAttribute('lyte-grid-y')), false, node);
                        }
                    if((data[node.elemNum].height > node.dataSet['lyte-grid-height-old'] && !node.flag))
                        {
                             lyteQuerySelector.verticalMove = false
                            node.setAttribute('lyte-grid-height', data[node.elemNum].height)
                            this.verticalCheck.call(this, data[node.elemNum], data[node.elemNum].y + data[node.elemNum].height, data[node.elemNum].y + data[node.elemNum].height, node, true)
                            this.displayGrid.call(this, node.elemNum);
                        }   
                    else if((data[node.elemNum].height < node.dataSet['lyte-grid-height-old'] && !node.flag))
                        {
                            lyteQuerySelector.verticalMove = false
                            node.setAttribute('lyte-grid-height', data[node.elemNum].height)
                            this.topMoveFunc.call(this, node, data[node.elemNum].y, true);
                            this.displayGrid.call(this, node.elemNum);
                        }       
                    event.preventDefault();
                    if(!this.getData('ltPropFloat'))   
                        {
                            this.topMoveAllGrid.call(this, node, data)
                        }
            }
        if(!this.getData('ltPropFloat'))   
            {
                valMove = this.heightGet.call(this, node)
            }
        else
            {
                valMove = 0
            }     
        if(this.getMethods('onDrag'))
            {
                this.executeMethod('onDrag', node, event, this.$node);
            }
    }
    var bestFit = this._bestfit;
    if(bestFit && node && this.getData('ltPropBestfit') && lyteQuerySelector.SelectedNodes.length == 1)
        {
                var offsetBestfit = this.getData('ltPropBestfitType');
                bestFit.style.left = (data[node.elemNum].x * unitX + ( ( data[node.elemNum].x + 1) * MarginLeft )) + 'px';
                bestFit.style.top = (( data[node.elemNum].y - valMove ) * unitY + ((data[node.elemNum].y + 1 - valMove) * marginTop)) + 'px';
                bestFit.style.width = (data[node.elemNum].length * unitX + (data[node.elemNum].length - 1) * MarginLeft + (offsetBestfit == "grid" ? MarginLeft : 0)) + 'px';
                bestFit.style.height = ((data[node.elemNum].height) * unitY + (data[node.elemNum].height-1) * marginTop + (offsetBestfit == "grid" ? marginTop : 0)) + 'px';
                bestFit.style.display = "block";
                if(offsetBestfit == 'grid'){
                     var color = this.getData('ltPropGridSpaceColor')
                     bestFit.style.backgroundImage = 'linear-gradient(to right,' + color +' ' + MarginLeft + 'px,transparent 0px),linear-gradient(to bottom,'+ color + ' ' + marginTop + 'px,transparent 0px)' 
                     bestFit.style.backgroundSize = ( MarginLeft + unitX ) + 'px ' + ( unitY + marginTop ) + 'px';
                     bestFit.style.transform = "translate(-" + MarginLeft + "px,-" + marginTop +"px)"
                 }
        
        }
    },

    topMoveAllGrid : function(node, data){
        // this.positionFind.call(this, elements)
        var yElements = this.getData('yElements');
        var max = node.constructor == Number ? node : data[ node.elemNum ].y + data[ node.elemNum .height * 2];
        var elementCount = this.similarData(this.elementSorting(this.yElementsFind( node.constructor == Number ? node : ( data[ node.elemNum ].y + data[ node.elemNum ].height ), Math.min(this.getData('lyteQuerySelector').MaxBottom, isNaN(max) ? this.getData('lyteQuerySelector').MaxBottom : max ), yElements)));
        for(var j = 0; j < elementCount.length; j++){
            if(elementCount[j] != node.elemNum){
                var htmve = this.heightGet.call(this, data[elementCount[j]].nodeName)
                if(htmve)
                    {
                        data[elementCount[j]].y = data[elementCount[j]].y - htmve/*( this.getData('ltPropFloat')? htmve >= data[node.elemNum].height ? data[elementCount[j]].y - data[node.elemNum].y :htmve : htmve )*/
                        this.valueUpdating.call(this, elementCount[j], 'y', 'lyte-grid-y')
                        this.topMoveFunc.call(this, data[elementCount[j]].nodeName, data[elementCount[j]].y);
                        this.displayGrid.call(this, elementCount[j], true);
                    }
            }

        }
    },
    // check for movement from bottom to top
    verticalMoveBottomToTop : function(element, node){
            $L.fastdom.measure(function(){
                var topElements = [], i, temp1 = 0, ht = 0, flag = true, elementsToCheck = [], elementsToCheck1 = [];
                var ltPropFloat = this.getData('ltPropFloat'), ltPropMarginTop = this.getData('ltPropMarginTop'),data = this.getData('lyteGridStack');   
                elementsToCheck = this.elementCheck.call(this, element, node)
                temp1 = data[node.elemNum].y                           
                elementsToCheck1 = this.getData('yElements')[temp1];
                // offsets are continuously changing during mousemove and grid interchanges. so it is nescessary to calculate offsets 
                var nodeOff = node.offTop;
                if(elementsToCheck1)
                    {
                        elementsToCheck = this.similarData.call(this, elementsToCheck, elementsToCheck1)
                    }
                if(elementsToCheck.indexOf(node.elemNum) != -1) 
                    {
                        Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                    }
                for(i = 0;i < elementsToCheck.length;i++ )
                    {
                        // height and other grids offset are required here
                        var topPos = data[elementsToCheck[i]].nodeName.offsetTop;
                        if((nodeOff < (topPos + data[elementsToCheck[i]].nodeName.offsetHeight - 0.5 * ltPropMarginTop)) && (nodeOff > (topPos + ltPropMarginTop)) &&(data[node.elemNum].y == data[elementsToCheck[i]].y + data[elementsToCheck[i]].height) && (node.initialTop[0] > nodeOff))
                            {
                                topElements[topElements.length] = elementsToCheck[i];
                            }
                    }
                if(topElements.length)
                    {
                        topElements = this.elementSorting.call(this, topElements || [ ])
                        this._occupied = topElements.slice();
                        for(var i = 0; i < topElements.length; i++)
                          { 
                            ht = this.heightGet.call(this, node, data[topElements[i]].nodeName)
                            if(ltPropFloat)
                                {
                                    ht = data[topElements[i]].height > ht ? ht : data[topElements[i]].height
                                }   
                            var iniHgt = data[topElements[i]].y + data[topElements[i]].height
                            if( [ 'top' , 'topLeft', 'topRight' ].indexOf(node.value) == -1 ) {
                                data[node.elemNum].y = iniHgt - ht;
                                this.valueUpdating.call(this, node.elemNum, 'y', 'lyte-grid-y')
                            }
                            var temp =(data[node.elemNum].y + data[node.elemNum].height) < (data[topElements[i]].y-this.heightGet.call(this, data[topElements[i]].nodeName))?(data[topElements[i]].y-this.heightGet.call(this, data[topElements[i]].nodeName)):(data[node.elemNum].y + data[node.elemNum].height);
                            this.verticalCheck.call(this, data[topElements[i]],iniHgt, temp + data[topElements[i]].height, node, true)
                            data[topElements[i]].y = temp
                            this.valueUpdating.call(this, topElements[i], 'y', 'lyte-grid-y')
                            if(!ltPropFloat || (i == topElements.length -1 && i != 0))
                                {
                                    this.topMoveFunc.call(this, node, data[node.elemNum].y + ht, false)
                                }
                            if(!ltPropFloat)
                                {
                                    this.topMoveFunc.call(this, data[topElements[i]].nodeName, data[topElements[i]].y, true)
                                }
                        }
                        delete this._occupied;
                        this.displayGrid.call(this)
                    }  
                 }.bind( this ) )        
    }, 
    // check for movement top to bottom
    verticalMoveTopToBottom : function(element, node){
            $L.fastdom.measure(function(){
                var topElements = [], bottomElements = [], i, j, temp1 = 0, flag = true, elementsToCheck = [], elementsToCheck1 = [], upHeight = 0;
                var data = this.getData('lyteGridStack');
                var ltPropUnitY = this.getData('ltPropUnitY');
                elementsToCheck = this.elementCheck.call(this, element, node)
                temp1 = data[node.elemNum].y                           
                elementsToCheck1 = this.getData('yElements')[temp1 + data[node.elemNum].height];
                if(elementsToCheck1)
                    {
                        elementsToCheck = this.similarData.call(this, elementsToCheck, elementsToCheck1)
                    }
                if(elementsToCheck.indexOf(node.elemNum) != -1)
                    {
                        Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                    }   
                for(i = 0;i < elementsToCheck.length;i++ )
                    {
                        // height and other grids offset are required here
                        var topPos = data[elementsToCheck[i]].nodeName.offsetTop, height = data[elementsToCheck[i]].nodeName.offsetHeight, left = data[elementsToCheck[i]].nodeName.offsetLeft, width = data[elementsToCheck[i]].nodeName.offsetWidth, nodeHgt = node.offsetHeight;
                        if((node.offTop  > (topPos + ( !this.getData( 'ltPropHitBottom' ) ? ( parseInt(this.getData('ltPropMarginTop') ) - nodeHgt ) : ( height - parseInt(this.getData('ltPropMarginTop') ) ))))  && (node.initialTop[0] <= node.offTop) && ((left + width > node.initialLeft[0]) && (node.initialLeft[0] + node.clientWidth > left) && (node.initialTop[0] + nodeHgt < topPos ||node.initialTop[0] > topPos + height))) 
                            {
                                topElements[topElements.length] = elementsToCheck[i];
                            }
                    }
                if(topElements.length)
                    { 
                        var arr = [], max;
                        for(i = 0;i < topElements.length;i++ )
                            {
                                arr.push(data[topElements[i]].height + data[topElements[i]].y);
                            }
                        ht = arr.reduce(function(a, b){return Math.max(a, b);});        
                        for(var j = 0;j < topElements.length;j++ )
                            {
                                if(!this.getData('ltPropFloat'))
                                    {
                                        upHeight = this.heightGet.call(this, data[topElements[j]].nodeName, node); 
                                        if(upHeight)
                                            {
                                                data[topElements[j]].y -= upHeight;
                                                this.valueUpdating.call(this, topElements[j], 'y', 'lyte-grid-y')
                                                if(j == 0)
                                                    {
                                                        ht = data[topElements[j]].height + data[topElements[j]].y
                                                    }
                                                else
                                                    {
                                                        ht = (data[topElements[j]].height + data[topElements[j]].y) > (data[topElements[j-1]].height + data[topElements[j-1]].y)?(data[topElements[j]].height + data[topElements[j]].y):(data[topElements[j-1]].height + data[topElements[j-1]].y);
                                                    }
                                            }
                                        data[node.elemNum].y = ht
                                        if(i == topElements.length -1 || i != 0)
                                            {
                                                this.topMoveFunc.call(this,data[topElements[j]].nodeName)
                                            }   
                                    }
                                else
                                    {
                                        data[node.elemNum].y = parseInt(((node.offsetTop - ltPropUnitY) / (ltPropUnitY + parseInt(this.getData('ltPropMarginTop')))).toFixed(0))
                                        this.verticalCheck.call(this, data[node.elemNum], parseInt(node.getAttribute('lyte-grid-y')) + data[node.elemNum].height, data[node.elemNum].y + data[node.elemNum].height, node, true)
                                    }
                                }
                        this.valueUpdating.call(this, node.elemNum, 'y', 'lyte-grid-y')
                        this.verticalCheck.call(this, data[node.elemNum], parseInt(node.getAttribute('lyte-grid-y')) + data[node.elemNum].height, data[node.elemNum].y + data[node.elemNum].height, data[node.elemNum].nodeName, true)      
                        this.displayGrid.call(this)
                    }  
                }.bind( this ) )                   
    }, 
    // to check any free space available above the particular grid
    heightGet : function(node, oldNode,flag){
        if(node.elemNum >= 0)
            {
                var topElements = [], i, j, temp = 0, elementsToCheck = [], elementsToCheck1 = [], data = this.getData('lyteGridStack');
                if(!oldNode)
                    {
                        oldNode = node
                    }
                var xElements = this.getData('xElements');
                var yElements = this.getData('yElements');
                if(data[node.elemNum].length > 1)
                    {
                        elementsToCheck = this.yElementsFind(data[node.elemNum].x + 1, data[node.elemNum].length + data[node.elemNum].x - 1, xElements)
                    }   
                else
                    {
                        elementsToCheck = this.similarData.call(this, xElements[data[node.elemNum].x], xElements[data[node.elemNum].x])
                    }   
                for(var k = data[node.elemNum].y + data[node.elemNum].height-1;k >= 0;k--)
                    {
                        elementsToCheck1 = this.yElementsFind(0, data[node.elemNum].y + data[node.elemNum].height-1, yElements)
                    }   
                elementsToCheck = this.multipleRemoval(this.elementSorting.call(this, this.similarData.call(this, elementsToCheck, elementsToCheck1)))
                if(elementsToCheck.indexOf(node.elemNum) != -1) 
                    {
                        Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                    }
                for(i = 0;i < elementsToCheck.length;i++ )
                    {
                        if(elementsToCheck[i] != oldNode.elemNum || flag)
                            {
                                if(data[node.elemNum].y >= data[elementsToCheck[i]].y)
                                    {
                                        if(((data[elementsToCheck[i]].x > data[node.elemNum].x) && (data[elementsToCheck[i]].x < (data[node.elemNum].x + data[node.elemNum].length))) || (((data[elementsToCheck[i]].x + data[elementsToCheck[i]].length) > (data[node.elemNum].x)) && (((data[elementsToCheck[i]].x + data[elementsToCheck[i]].length) < (data[node.elemNum].x + data[node.elemNum].length)))) || ((data[elementsToCheck[i]].x > data[node.elemNum].x) && ((data[elementsToCheck[i]].x + data[elementsToCheck[i]].length) < (data[node.elemNum].x + data[node.elemNum].length))) || ((data[elementsToCheck[i]].x < data[node.elemNum].x) && ((data[elementsToCheck[i]].x + data[elementsToCheck[i]].length) > (data[node.elemNum].x + data[node.elemNum].length))) || ((data[elementsToCheck[i]].x == data[node.elemNum].x) || (data[elementsToCheck[i]].x + data[elementsToCheck[i]].length == data[node.elemNum].length + data[node.elemNum].x)))
                                                {
                                                    topElements[topElements.length] = elementsToCheck[i];
                                                }
                                    }
                            }
                    }
                for(j = 0;j < topElements.length;j++ )
                    {
                        if(j == 0)
                            {
                                temp += -data[topElements[0]].y-data[topElements[0]].height + data[node.elemNum].y;
                            }
                        else if((-data[topElements[j]].y-data[topElements[j]].height + data[node.elemNum].y) < temp)
                            {
                                temp = -(data[topElements[j]].y + data[topElements[j]].height-data[node.elemNum].y);
                            }
                    }
                if(topElements.length == 0)
                    {
                        temp = data[node.elemNum].y;
                    }
                if(temp < 0)
                    {
                        temp = 0;
                    }   
                return temp;    
            }       

    },
    // vertical movement towards top 
    topMoveFunc : function(node, count, flagie, currentNode, finalfg){
            var i, elementsToCheck = [],lyteQuerySelector = this.getData('lyteQuerySelector'), occupied = lyteQuerySelector.occupied, element = lyteQuerySelector.element, data = this.getData('lyteGridStack');
            occupied.push(node.elemNum)
            currentNode = currentNode ? currentNode : node;
            elementsToCheck = this.elementSorting.call(this, this.elementCheck.call(this, element, node, finalfg))
            if(elementsToCheck.indexOf(node.elemNum) != -1) 
                {
                    Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                }
            occupied =occupied.concat(elementsToCheck)  
            for(i = 0; i < elementsToCheck.length; i++ )
                {
                    if(!data[elementsToCheck[i]].nodeName.classList.contains('gridSelected'))
                         {
                            if((data[node.elemNum].x >= data[elementsToCheck[i]].x && data[node.elemNum].x + data[node.elemNum].length <= data[elementsToCheck[i]].x) || (data[node.elemNum].x + data[node.elemNum].length >= data[elementsToCheck[i]].x && (data[node.elemNum].x + data[node.elemNum].length <= data[elementsToCheck[i]].x + data[elementsToCheck[i]].length)) || (data[node.elemNum].x > data[elementsToCheck[i]].x) || ((data[node.elemNum].x + data[node.elemNum].length) > (data[elementsToCheck[i]].x + data[elementsToCheck[i]].length)))
                                {
                                    if(data[node.elemNum].y + data[node.elemNum].height <= data[elementsToCheck[i]].y + data[elementsToCheck[i]].height ||flagie)
                                        {
                                            valMove = this.heightGet.call(this, data[elementsToCheck[i]].nodeName,null,!flagie)
                                            data[elementsToCheck[i]].y = data[elementsToCheck[i]].y-valMove;
                                            this.valueUpdating.call(this, elementsToCheck[i], 'y', 'lyte-grid-y')
                                            this.positionFind.call(this);
                                            if(valMove)
                                                {
                                                    this.topMoveFunc.call(this, data[elementsToCheck[i]].nodeName, data[elementsToCheck[i]].y + valMove, flagie, currentNode);
                                                    if(!flagie)
                                                        {
                                                            this.displayGrid.call(this, currentNode.elemNum)
                                                        }
                                                }
                                        }
                                }
                        }
                }
    }, 
    // to sort selected elements according to directions
    elementSorting : function(stackElements, flag){
            if(flag)
                {
                    y = 'x';
                }
            else
                {
                    y = 'y';
                }   
            var data = this.getData('lyteGridStack')
            for(var j = 0;j < stackElements.length;j++ )
                    {
                        for(var k = j + 1;k < stackElements.length;k++ )
                            {
                                if(data[stackElements[j]][y] > data[stackElements[k]][y])
                                    {
                                        var temp = stackElements[j];
                                        stackElements[j] = stackElements[k];
                                        stackElements[k] = temp;
                                    }
                            }
                    }
             return stackElements    
    }, 
    // horizontal movement check
    topCheck : function(node, element,timeoutFlag, fourth, allowHorizontal, width){
                var i, flag = false, stackElements = [], temp1, elementsToCheck = [], elementsToCheck1 = [], hgt, ht=0;
                    var data = this.getData('lyteGridStack'), currentTop;
                    var xElements = this.getData('xElements');
                    var yElements = this.getData('yElements');
                    temp1 = data[node.elemNum].y
                    if(data[node.elemNum].length > 1)   
                        {
                            elementsToCheck = this.elementSorting(this.multipleRemoval(this.yElementsFind.call(this, data[node.elemNum].x + 1, data[node.elemNum].x + data[node.elemNum].length-1, xElements)));
                        }
                    else
                        {
                            elementsToCheck = this.similarData.call(this, xElements[data[node.elemNum].x], xElements[data[node.elemNum].x + 1])
                        }
                    if(data[node.elemNum].height > 1)   
                        {
                            elementsToCheck1 = this.yElementsFind(temp1 + 1, data[node.elemNum].y + data[node.elemNum].height - 1, yElements)
                        }
                    else
                        {
                            elementsToCheck1 = this.similarData.call(this, yElements[data[node.elemNum].y], yElements[data[node.elemNum].y + 1])
                        }
                    if(elementsToCheck1)        
                        {
                            elementsToCheck = this.similarData.call(this, elementsToCheck, this.multipleRemoval.call(this, elementsToCheck1))
                        }
                    elementsToCheck = this.elementSorting.call(this, this.multipleRemoval.call(this, elementsToCheck))  
                    if(elementsToCheck.indexOf(node.elemNum) != -1) 
                        {
                            Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.elemNum))
                        }
                    for(i = elementsToCheck.length - 1; i > -1; i-- )
                        {
                            if(timeoutFlag)
                                {
                                    if(data[node.elemNum].x != node.getAttribute('lyte-grid-x') || data[node.elemNum].length != node.getAttribute('lyte-grid-length'))
                                        {   
                                            flag=true
                                        }
                                }
                            else
                                {
                                    if(((data[node.elemNum].x + data[node.elemNum].length > data[elementsToCheck[i]].x && data[node.elemNum].x < data[elementsToCheck[i]].x) || (data[node.elemNum].x < data[elementsToCheck[i]].x + data[elementsToCheck[i]].length && data[elementsToCheck[i]].x + data[elementsToCheck[i]].length <= data[node.elemNum].x + data[node.elemNum].length)) && (temp1 + data[node.elemNum].height > data[elementsToCheck[i]].y && temp1 < data[elementsToCheck[i]].y) || (temp1 < data[elementsToCheck[i]].y + data[elementsToCheck[i]].height && data[elementsToCheck[i]].y + data[elementsToCheck[i]].height < temp1 + data[node.elemNum].height) || (temp1 >= data[elementsToCheck[i]].y && data[elementsToCheck[i]].y + data[elementsToCheck[i]].height >= temp1 + data[node.elemNum].height) || (data[elementsToCheck[i]].y + data[elementsToCheck[i]].height < temp1 + data[node.elemNum].height && temp1 < data[elementsToCheck[i]].y ))
                                        {
                                            flag=true
                                        }
                                }   
                            if(flag && !data[elementsToCheck[i]].nodeName.classList.contains('gridSelected'))    
                                {
                                    if(((data[node.elemNum].x <= (data[elementsToCheck[i]].x + data[elementsToCheck[i]].length-1))) || ((data[elementsToCheck[i]].x + 1 >= (data[node.elemNum].x + data[node.elemNum].length))))   
                                            {
                                                stackElements[stackElements.length] = elementsToCheck[i]
                                                ht += data[elementsToCheck[i]].height
                                                if(this.getData('ltPropDirection') != 'horizontal' && !fourth)
                                                    {
                                                        break;
                                                    }
                                            }   
                                }
                            flag=false  
                        }
                    if(stackElements.length)
                        {
                            if(!timeoutFlag)
                                {
                                    this.valueUpdating.call(this, node.elemNum, 'x', 'lyte-grid-x')  
                                } 
                            stackElements = this.elementSorting.call(this, stackElements, true)
                            for(var z = 0 ; z < stackElements.length ; z++)
                                {
                                    var valMove = this.heightGet.call(this, data[stackElements[z]].nodeName), totalHeight = data[node.elemNum].height + data[node.elemNum].y -valMove, ret = true;
                                    hgt = totalHeight;
                                    if(this.getData('ltPropDirection') != 'horizontal' && !allowHorizontal) 
                                        {
                                            this.verticalCheck.call(this, data[stackElements[z]], data[stackElements[z]].y + data[stackElements[z]].height, totalHeight + valMove + data[stackElements[z]].height, node, data[node.elemNum].height < data[stackElements[z]].height);  
                                            data[stackElements[z]].y = (hgt > (data[node.elemNum].height + data[node.elemNum].y)?hgt:(data[node.elemNum].height + data[node.elemNum].y)) - (this.getData('ltPropFloat')? 0 : this.heightGet.call(this,data[node.elemNum].nodeName));
                                            this.valueUpdating.call(this, stackElements[z], 'y', 'lyte-grid-y')
                                        }
                                    else
                                        {
                                            if(z > 0 &&  ((parseInt(data[stackElements[z]].nodeName.getAttribute('lyte-grid-x')) + parseInt(data[stackElements[z]].nodeName.getAttribute('lyte-grid-length'))) == (this.getData('gridLength')) || parseInt(data[stackElements[z]].nodeName.getAttribute('lyte-grid-x')) == 0))
                                                {
                                                    break;
                                                }
                                            if((node.offsetLeft > data[stackElements[z]].nodeName.offsetLeft) && !allowHorizontal)
                                                {
                                                    this.horiMovement.call(this, node, stackElements[z], 'left', ht, stackElements.length == 1 || (stackElements.length > 2 && z != 1), width)                                                   
                                                }
                                            else if((node.offsetLeft < data[stackElements[z]].nodeName.offsetLeft) || allowHorizontal) 
                                                {
                                                    this.horiMovement.call(this, node, stackElements[z], 'right', ht, stackElements.length == 1 || (stackElements.length > 2 && z != 1), width)                                                  
                                                }   
                                        }
                                    if(!this.getData('ltPropFloat'))    
                                        {
                                            this.topMoveFunc.call(this, data[stackElements[z]].nodeName, z == 0 || (data[stackElements[z]].x != 0 && data[stackElements[z]].x + data[stackElements[z]].length != parseInt(this.getData('gridLength')))) 
                                        }
                                    this.displayGrid.call(this, node.elemNum);
                                }
                    }
},
// if given direction is horizontal
    horiMovement : function(node, stackElements, direction, ht, flag, wid){
            var data = this.getData('lyteGridStack'), lyteQuerySelector = this.getData('lyteQuerySelector');
            data[stackElements].x = direction == "left"?(data[stackElements].x - ( wid ? wid : 1 )):(data[stackElements].x + ( wid ? wid : 1 ));
            if(data[stackElements].x < 0 || (data[stackElements].x + data[stackElements].length) > parseInt(this.getData('gridLength')))
                {
                    if(data[stackElements].x < 0)
                        {
                            data[stackElements].x = 0;
                        }
                    else
                        {
                            data[stackElements].x = parseInt(this.getData('gridLength')) - data[stackElements].length;
                        }
                    this.valueUpdating.call(this, stackElements, 'x', 'lyte-grid-x')
                    var dumHgt = data[stackElements].y + data[stackElements].height
                    data[stackElements].y = data[node.elemNum].y + data[node.elemNum].height;   
                    var handQuer = this.getData('ltPropHandler');
                    this.positionFind.call(this, (/^#/g.test(handQuer) && !/\s/g.test(handQuer)) ? this.scopeElement.querySelectorAll(handQuer) : $L(handQuer, this.scopeElement).e);
                    this.verticalCheck.call(this, data[stackElements], dumHgt, data[node.elemNum].y + data[node.elemNum].height + data[stackElements].height /*ht*/, node);
                    this.valueUpdating.call(this, stackElements, 'y', 'lyte-grid-y')
                    this.displayGrid.call(this);    
                }
            else
                {
                    this.valueUpdating.call(this, stackElements, 'x', 'lyte-grid-x')
                    data[stackElements].nodeName.initialLeft = []
                    data[stackElements].nodeName.initialTop = []
                    for(var k = 0; k < 3; k++)
                        {
                            data[stackElements].nodeName.initialLeft[k] = data[stackElements].nodeName.offsetLeft;
                            data[stackElements].nodeName.initialTop[k] = data[stackElements].nodeName.offsetTop;
                        }
                    this.topCheck.call(this, data[stackElements].nodeName, lyteQuerySelector.element, true, null, wid ? true : false, wid)
                    if(flag)
                        {
                            var valMove = this.heightGet.call(this, data[stackElements].nodeName)
                            if(! this.getData('ltPropFloat'))
                                {
                                    data[stackElements].y -= valMove
                                    if(valMove)
                                        {
                                            this.topMoveFunc.call(this, data[stackElements].nodeName)
                                        }   
                                }
                        }
                    this.displayGrid.call(this)
                }
    },
    // vertical movement top to bottom  
    verticalCheck : function(node, currentHeight, totalHeight, currentNode, flagie, direction){
            var topElements = [], elementsToCheck = [], elementsToCheckDum = [], i, count, ht, flag = false, flag2 = false, elementsToCheck1 = [], maxElem = [], temp = [], data = this.getData('lyteGridStack'), fixFlag;
            currentNode = currentNode ? currentNode : node.nodeName;
            var xElements = this.getData('xElements'), yElements = this.getData('yElements'), element = this.scopeElement;
            if(direction == 'left')
                {   
                    elementsToCheck = elementsToCheck.concat(xElements[node.x] || [])
                }
            else if(direction == "right")
                {
                    elementsToCheck = elementsToCheck.concat(xElements[node.x + node.length] || [])
                }   
            else
                {   
                    if(node != data[currentNode.elemNum])
                        {
                            if(node.length > 1)
                                {
                                    elementsToCheck = this.yElementsFind(node.x + 1, node.x + node.length - 1, xElements)
                                }
                            else
                                {
                                    elementsToCheck = this.similarData.call(this, xElements[node.x] || [], xElements[node.x + 1] || [])
                                }   
                        }
                    else
                        {
                            elementsToCheck = this.elementCheck.call(this, element, node.nodeName)
                        }
                }
            elementsToCheck = this.multipleRemoval.call(this, elementsToCheck); 
            // elementsToCheckDum = elementsToCheckDum.concat(elementsToCheck); 
             for(var z = totalHeight - node.height; z <= totalHeight; z++)
                {
                    elementsToCheck1 = elementsToCheck1.concat(yElements[z] || [])
                }
            if(elementsToCheck1)
                {
                    elementsToCheck = this.similarData.call(this, elementsToCheck, this.multipleRemoval.call(this, elementsToCheck1))    
                }
            elementsToCheck = this.elementSorting.call(this, elementsToCheck);  
            if(elementsToCheck.indexOf(node.nodeName.elemNum) != -1)
                {
                    Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(node.nodeName.elemNum))
                }
            if(elementsToCheck.indexOf(currentNode.elemNum) != -1)  
                {
                    Lyte.arrayUtils(elementsToCheck, 'removeAt', elementsToCheck.indexOf(currentNode.elemNum))
                } 
            if(direction)
                {
                    if(!this.similarData.call(this, elementsToCheck, yElements[node.y + node.height].concat(yElements[node.y])).length)
                        {
                            elementsToCheck = []
                        }
                }       
            for(i = 0;i < elementsToCheck.length;i++ )
                {
                    if(elementsToCheck[i] != node.nodeName.elemNum && elementsToCheck[i] != currentNode.elemNum)
                        {
                            if(flagie)
                                {
                                    if((node.y) == data[elementsToCheck[i]].y)
                                        {
                                            flag2 = true;
                                        }
                                }
                            if((node.y) < (data[elementsToCheck[i]].y + data[elementsToCheck[i]].height) || flag2)
                                {   
                                    topElements[topElements.length] = elementsToCheck[i];
                                    flag = true
                                }
                            else if(flagie && ((data[elementsToCheck[i]].y + data[elementsToCheck[i]].height) >= (node.y + node.height)))
                                {
                                    topElements[topElements.length] = elementsToCheck[i];
                                    flag = true
                                }       
                        }
                    if(flag)
                        {
                            flag = false
                            maxElem.push(data[topElements[topElements.length-1]].height + data[topElements[topElements.length-1]].y)
                            if(topElements.length > 1)
                                {
                                    temp.push(data[topElements[topElements.length - 1]].y-(data[topElements[0]].y + data[topElements[0]].height))     
                                }
                        }   
                }
             if(topElements.length)
                {   
                    topElements = this.elementSorting.call(this, topElements)
                    ht = totalHeight;
                    var elem = [], elem1 = [];
                    totalHeight = Math.max.apply(null,maxElem) - data[topElements[0]].y + ht   
                        for(var j = 0;j < topElements.length;j++ )
                            {
                                var htmove = this.heightGet.call(this, data[topElements[j]].nodeName)
                                if(j == 0)
                                    {
                                        if((ht <= data[topElements[j]].y) && flagie)
                                            {
                                                break
                                            }
                                        else    
                                            {
                                                if(data[topElements[j]].y-ht < 1)
                                                    {
                                                        data[topElements[j]].y = ht
                                                        htmove = this.heightGet.call(this, data[topElements[j]].nodeName)
                                                        if((data[topElements[j]].y-htmove >= ht))
                                                            {
                                                                data[topElements[j]].y -= htmove
                                                            }
                                                    }   
                                            }
                                    }
                                else
                                    {
                                        data[topElements[j]].y = data[topElements[0]].y + data[topElements[0]].height + temp[j-1];
                                        htmove = this.heightGet.call(this, data[topElements[j]].nodeName)
                                        if((data[topElements[j]].y - htmove >= ht))
                                            {
                                                data[topElements[j]].y -= htmove
                                            }
                                    }   
                                this.valueUpdating.call(this, topElements[j], 'y', 'lyte-grid-y')      
                            }
                        elem = this.yElementsFind.call(this,Math.min(node.x, data[currentNode.elemNum].x), Math.max((node.x + node.length), data[currentNode.elemNum].x + data[currentNode.elemNum].length), xElements)
                        elem = this.elementSorting.call(this,this.multipleRemoval.call(this, this.similarData.call(this, elem, topElements)))
                        for(var i = elem.length - 1;i >= 0 ;i-- )
                            {
                                var elem1 = [], elem2 = [], elem3 = [];
                                for(var j = data[elem[i]].x + 1;j < (data[elem[i]].x + data[elem[i]].length);j++ )
                                    {
                                        elem1 = elem1.concat(xElements[j])
                                    }
                                 if(data[elem[i]].length == 1)
                                    {
                                         elem1 = this.similarData.call(this, xElements[data[elem[i]].x], xElements[data[elem[i]].x + 1])
                                    }
                                if(flagie)   
                                    {
                                        elem2 = this.elementSorting.call(this,this.multipleRemoval.call(this,this.similarData.call(this, elem1, this.yElementsFind.call(this, parseInt(data[elem[i]].nodeName.getAttribute('lyte-grid-y')) + 1 ,parseInt(data[elem[i]].nodeName.getAttribute('lyte-grid-y')) + data[elem[i]].height, yElements))));
                                    }
                                else
                                    {
                                        elem2 = this.elementSorting.call(this, this.multipleRemoval.call(this,this.similarData.call(this, elem1, this.yElementsFind.call(this, parseInt(data[elem[i]].nodeName.getAttribute('lyte-grid-y')) + 1 ,parseInt(data[elem[i]].nodeName.getAttribute('lyte-grid-y')) + data[elem[i]].height, yElements)).concat(this.similarData.call(this, elem1, this.yElementsFind.call(this, parseInt(data[elem[i]].y) + 1 ,parseInt(data[elem[i]].y) + data[elem[i]].height, yElements)))))                                   
                                    }   
                                for(var k = 0;k < elem2.length;k++ )
                                    {
                                        if(topElements.indexOf(elem2[k]) == -1 && node.nodeName.elemNum != elem2[k] && currentNode.elemNum != elem2[k])
                                            {
                                                if( this._occupied && this._occupied.indexOf( elem2[ k ] ) != -1 ) {
                                                    continue;
                                                }
                                                this.additionalCheck.call(this, elem2[k], data[elem[i]].y + data[elem[i]].height, topElements);
                                            }
                                    }   
                            }
                    }               
},
// to find elements on given height 
yElementsFind : function(start, end, yElements){
    var elements = [];
    for(var i = start;i <= end;i++ )
        {
            elements = elements.concat(yElements[i] || [])
        }
    return elements;    
}, 
// to propagate vertical check 
additionalCheck : function(element, height, topElements1){
        var xElements = this.getData('xElements'), yElements = this.getData('yElements'), data = this.getData('lyteGridStack'), elem1 = [], elem2 = [], hgt = height, elementNo = element;
        elem1 = elem1.concat(this.yElementsFind.call(this, parseInt(data[element].nodeName.getAttribute('lyte-grid-y')) + data[element].height, data[element].y + data[element].height, yElements))
        if(data[element].length>1)
            {
                elem2 = elem2.concat(xElements[data[element].x + 1])
                elem2 = elem2.concat(xElements[data[element].x + data[element].length - 1])
            }
        else
            {
                elem2 =elem2.concat(this.similarData.call(this, xElements[data[element].x], xElements[data[element].x + 1]))
            }   
        elem1 = this.similarData.call(this, elem1, elem2);
        if(elem1.indexOf(element) != -1)
            {
                Lyte.arrayUtils(elem1, 'removeAt', elem1.indexOf(element))
            }   
        for(var i = 0;i < elem1.length;i++ )
            {
                if(topElements1.indexOf(elem1[i]) == -1)
                    {
                        topElements1.push(elem1[i])
                        this.additionalCheck.call(this, elem1[i], height + data[element].height, topElements1)
                    }
            }
        if(data[elementNo].y > hgt)
            {
                 var htmove = this.heightGet.call(this, data[elementNo].nodeName);
                 if(data[elementNo].y - htmove <= hgt)
                    {
                        data[elementNo].y = hgt
                    }
                else
                    {
                        data[elementNo].y -= htmove
                    }
                    
            }
          else  
            {
               data[elementNo].y = hgt
            }
        topElements1.push(elementNo); 
        this.valueUpdating.call(this, elementNo, 'y', 'lyte-grid-y'); 
}, 
// finding previous position for undo
previousPos : function(elementCount, flag){
    if(!elementCount || !elementCount.length){
        return;
    }
    var data = this.getData('lyteGridStack'), lyteQuerySelector = this.getData('lyteQuerySelector');
    for(var i = 0;i < elementCount.length;i++ )
        {
            if(lyteQuerySelector.currentPos < data[i].oldX.length)
                {
                    Lyte.arrayUtils(data[i].oldX, 'remove', lyteQuerySelector.currentPos + 1, data[i].oldX.length)
                    Lyte.arrayUtils(data[i].oldY, 'remove', lyteQuerySelector.currentPos + 1, data[i].oldY.length)
                    Lyte.arrayUtils(data[i].oldLength, 'remove', lyteQuerySelector.currentPos + 1, data[i].oldLength.length)
                    Lyte.arrayUtils(data[i].oldHeight, 'remove', lyteQuerySelector.currentPos + 1, data[i].oldHeight.length)
                }
            data[i].oldX[data[i].oldX.length] = flag ? data[i].x : data[i].nodeName.getAttribute('lyte-grid-x');
            data[i].oldY[data[i].oldY.length] = flag ? data[i].y : data[i].nodeName.getAttribute('lyte-grid-y');
            data[i].oldLength[data[i].oldLength.length] = flag ? data[i].length : data[i].nodeName.getAttribute('lyte-grid-length');
            data[i].oldHeight[data[i].oldHeight.length] = flag ? data[i].height : data[i].nodeName.getAttribute('lyte-grid-height');
        }
    lyteQuerySelector.currentPos = data[0].oldX.length-1;
},  

mousedown : function (evt){
        if(!this.getData('ltPropFreezeMode'))
            {
                var lyteQuerySelector = this.getData('lyteQuerySelector'), currentElement = this, data = this.getData('lyteGridStack') 
                var ret = this.nodeName.call(this, evt);   
                if(ret)
                    {
                        this.mvefunc = this.mMove.bind(this), this.upfunc = this.mouseup.bind(this),
                        evt.stopPropagation();
                        var val = ret[0];
                        var nodeName = ret[1]
                        var element = $L(this.getData('ltPropScope'), this.$node).e[0]
                        if(!evt.shiftKey)   
                            {
                                lyteQuerySelector.BottomToTopFlag = true, lyteQuerySelector.allowMovement = true, this.mvefunc = this.mMove.bind(this)  
                                if(($L(this.getData('ltPropHandler') + '.gridSelected', element).e.length == 0))
                                    {   
                                        var method;
                                        if(this.getMethods('onBeforeSelect'))
                                            {
                                                method = this.executeMethod('onBeforeSelect', ret[1], evt, this.$node);
                                            }
                                        if(nodeName && method != false)
                                            {
                                                lyteQuerySelector.SelectedNodes = [];
                                                $L.fastdom.mutate(function(){
                                                    nodeName.classList.add('gridSelected')
                                                })
                                                $L.fastdom.measure(function(){
                                                    lyteQuerySelector.SelectedNodes.push(nodeName.elemNum);
                                                    lyteQuerySelector.element = element
                                                    nodeName.initialLeft = [], nodeName.initialTop = []
                                                    for(var k = 0; k < 3; k++)
                                                        {
                                                            nodeName.initialLeft[k] = nodeName.offsetLeft;
                                                            nodeName.initialTop[k] = nodeName.offsetTop;
                                                        }
                                                    nodeName.initialy = data[nodeName.elemNum].y
                                                    nodeName.initialx = data[nodeName.elemNum].x
                                                    nodeName.xPos = evt.clientX - nodeName.offsetLeft;
                                                    nodeName.yPos = evt.clientY - nodeName.offsetTop;
                                                    nodeName.instantPreviousX = nodeName.initialLeft[0];
                                                    nodeName.instantPreviousY = nodeName.initialTop[0];
                                                    if(val == "content")
                                                        {
                                                            nodeName.flag = true;
                                                        }
                                                    else
                                                        {
                                                            nodeName.value = val;
                                                            var bccr = nodeName.getBoundingClientRect();
                                                            if( [ 'BottomRight', 'right', 'topRight' ].indexOf(val) != -1 )      
                                                                {
                                                                    nodeName.xOff = bccr.left + bccr.width - evt.clientX;
                                                                }
                                                            else
                                                                {
                                                                    nodeName.xOff = - bccr.left + evt.clientX;
                                                                }   
                                                            if( [ 'BottomRight', 'bottom', 'BottomLeft' ].indexOf(val) != -1 )      
                                                                {
                                                                    nodeName.yOff = bccr.top + bccr.height - evt.clientY;
                                                                }
                                                            else
                                                                {
                                                                    nodeName.yOff = - bccr.top + evt.clientY;
                                                                }       
                                                            nodeName.flag = false;
                                                        }
                                                })
                                                
                                                if(this.getData('ltPropBestfit'))     
                                                    {
                                                        if(!this._bestfit)
                                                            {
                                                                var ltPropBestfitClass = this.getData('ltPropBestfitClass');
                                                                var bestFit = document.createElement('div');
                                                                bestFit.classList.add('lyteBestFit');
                                                                if(this.getData('ltPropBestfitType') == 'grid'){
                                                                    bestFit.classList.add('lyteGrid')
                                                                }
                                                                if(ltPropBestfitClass){
                                                                    bestFit.classList.add(ltPropBestfitClass);
                                                                }
                                                                bestFit.style.display = "none"
                                                                this._bestfit = bestFit;
                                                                $L.fastdom.mutate(function(){
                                                                    element.appendChild(bestFit);
                                                                })
                                                            }
                                                             
                                                        
                                                    }
                                                document.body.addEventListener('mousemove', this.mvefunc, true);
                                                if(this.getMethods('onSelect')){
                                                    this.executeMethod('onSelect',nodeName, evt, this.$node)
                                                }

                                            }
                                    }
                                else
                                    {   
                                        lyteQuerySelector.SelectedNodes = [];
                                        var nodeName = $L(this.getData('ltPropHandler') + '.gridSelected', this.$node).e, evt = event
                                        $L.fastdom.measure(function(){
                                            for(var i = 0;i < nodeName.length; i++ )
                                                {
                                                    lyteQuerySelector.SelectedNodes.push(element.querySelectorAll(currentElement.getData('ltPropHandler') + '.gridSelected')[i].elemNum);
                                                    nodeName[i].left = nodeName[i].offsetLeft;
                                                    nodeName[i].top = nodeName[i].offsetTop;
                                                    nodeName[i].flag = true;
                                                    nodeName[i].initialLeft[0] = nodeName[i].offsetLeft;
                                                    nodeName[i].initialTop[0] = nodeName[i].offsetTop;
                                                    nodeName[i].xPos = evt.clientX-nodeName[i].offsetLeft;
                                                    nodeName[i].yPos = evt.clientY-nodeName[i].offsetTop;
                                                }
                                            lyteQuerySelector.SelectedNodes = this.elementSorting.call(this, lyteQuerySelector.SelectedNodes);
                                        }.bind(this))
                                        document.body.addEventListener('mousemove', this.mvefunc, true);
                                        if(this.getMethods('onSelect')){
                                            this.executeMethod('onSelect',nodeName, evt, this.$node)
                                        } 
                                    }
                            }
                        else if(!lyteQuerySelector.allowMovement)
                            {
                                var method;
                                if(this.getMethods('onBeforeSelect'))
                                    {
                                        method = this.executeMethod('onBeforeSelect', ret[1], evt, this.$node);
                                    }
                                if(method != false)
                                    {
                                        nodeName = ret[1]
                                        nodeName.initialLeft = [], nodeName.initialTop = []
                                        if(nodeName.classList.contains('gridSelected'))
                                            {
                                                nodeName.classList.remove('gridSelected')
                                            }
                                        else    
                                            {
                                                nodeName.classList.add('gridSelected')
                                            }
                                    }
                            }   
                        lyteQuerySelector.previousPosFind = false
                    } 
              evt.preventDefault()      
            }
},
mMove : function(evt){
    this.mousemoveFun.call(this, this.scopeElement, evt);
    evt.stopPropagation();
    evt.preventDefault();
} ,
mouseup : function (evt){   
    var lyteQuerySelector = this.getData('lyteQuerySelector'), data = this.getData('lyteGridStack')
    var ret = this.nodeName.call(this, evt);   
    var element = $L(this.getData('ltPropScope'), this.$node).e[0]
    var elementCount = this.elementSorting.call(this, lyteQuerySelector.elementCount)
    if(!evt.shiftKey || lyteQuerySelector.allowMovement)   
        {
            var method, nodes, bestfit = this._bestfit;
            lyteQuerySelector.verticalMove = true, lyteQuerySelector.allowMovement = false;
            if(lyteQuerySelector.SelectedNodes.length)
                {
                    nodes =  $L(this.getData('ltPropHandler') + '.gridSelected', this.$node).e;
                    if(this.getMethods('onBeforeDrop')){
                        method = this.executeMethod('onBeforeDrop', nodes, event, this.$node);
                    }
                    for(i = lyteQuerySelector.SelectedNodes.length-1;i >= 0;i--)    
                        {
                            var nodeName = data[lyteQuerySelector.SelectedNodes[i]].nodeName
                            if(nodeName.classList.contains('gridSelected'))
                                {
                                    if(!this.getData('ltPropFloat') && method != false)
                                        {
                                            var valMove = this.heightGet.call(this, nodeName)
                                            data[nodeName.elemNum].y -= (valMove);
                                            this.topCheck.call(this, nodeName, this.scopeElement);
                                            this.topMoveFunc.call(this, nodeName, data[nodeName.elemNum].y + valMove, false)
                                        }
                                    this.displayGrid.call(this);    
                                    nodeName.classList.remove('gridSelected');
                                    nodeName.classList.remove( 'lyteGridStackMove' );
                                    nodeName.style.removeProperty('left')
                                    nodeName.style.removeProperty('top')
                                    nodeName.style.removeProperty('height')
                                    nodeName.style.removeProperty('width')
                                    Lyte.arrayUtils(lyteQuerySelector.occupied, 'remove', 0, lyteQuerySelector.occupied.length)
                                    if(method != false)
                                        {
                                            this.topCheck.call(this,nodeName,element);
                                        }
                                      if(nodeName.flag == false && nodeName._childGrid){
                                            setTimeout(nodeName._childGrid.reRender, 150, true)
                                       } 
                                    delete nodeName.initialy; delete nodeName.xPos; delete nodeName.yPos; delete nodeName.flag; delete nodeName.offLeft; delete nodeName.offTop;
                                    delete nodeName.initialx; delete nodeName.instantPreviousX;delete nodeName.instantPreviousY;delete nodeName.val; delete nodeName.xOff; delete nodeName.yOff; delete  nodeName.initialLeft[0]; delete  nodeName.initialLeft[1];
                                    delete  nodeName.initialLeft[2]; delete  nodeName.initialTop[0]; delete  nodeName.initialTop[1]; delete  nodeName.initialTop[2]; delete nodeName.flag; delete nodeName.value; delete nodeName.prevEvX; delete nodeName.prevEvY;

                                }
                            if(bestfit)    
                                {
                                    bestfit.style.display = 'none' 
                                }
                             this.findGrid();   
                        }  
                    evt.stopPropagation();
                    evt.preventDefault();    
                }
            if(method != false)       
                {
                    this.displayGrid.call(this);
                    // $L.fastdom.mutate(function(){
                        if(lyteQuerySelector.SelectedNodes.length && lyteQuerySelector.previousPosFind) 
                            {
                                // this._preventClick = true
                                var handQuer = this.getData('ltPropHandler')
                                this.previousPos.call(this, (/^#/g.test(handQuer) && !/\s/g.test(handQuer)) ? element.querySelectorAll(handQuer) : $L(handQuer, element).e);
                            }
                        if(this.getMethods('onDrop')){
                            this.executeMethod('onDrop', nodes, event, this.$node);
                        } 
                    // }.bind(this))
                }
            else
                {    
                    lyteQuerySelector.currentPos += 1;
                    this.undoPrevious.call(this);
                }

            document.body.removeEventListener('mousemove', this.mvefunc, true)
            lyteQuerySelector.SelectedNodes = []    
       }
       document.removeEventListener('mouseup', this.upfunc, true)     
    },
    keydown : function (event){

        if(document._lyteCurrentGrid == this && this.getData('ltPropUndo') && !this.getData('ltPropFreezeMode'))
            {
                if((event.ctrlKey || event.metaKey) && event.shiftKey && event.keyCode == 90)
                    {
                        this.undoNext.call(this);
                    }
                else if((event.ctrlKey || event.metaKey) && !event.shiftKey && event.keyCode == 90)
                    {
                        this.undoPrevious.call(this);
                    }  
            }  
  },

  returnWid : function(length, x, div){
    if(!length){
        return
    }
    if(length.constructor != String){
        return length;
    }
    var match = length.match(/[\w|.]+(?=%)/gi)
    if(match && match.length){
        var unitX, margin, width;
        if(x){
            // if(div){
            //     div._percentLength = length; 
            // }
            width = "width";
            unitX = this.getData('ltPropUnitXCopy');
        }else{
            // if(div){
            //     div._percentHeight = length; 
            // }
            width = "height";
            unitX = this.getData('ltPropUnitY');
            margin = "ltPropMarginTop"
        }
        // grid length will be based on actual width
        return this.gridLength((this.bcrrelem ? this.bcrrelem[width] : this.scopeElement.getBoundingClientRect()[width]) * parseFloat(match[0]) / 100, unitX, margin)
    }else{
        // if(div){
        //     if(x && div._percentLength){
        //         return this.returnWid(div._percentLength, x, div);
        //     }else if(div._percentHeight){
        //         return this.returnWid(div._percentHeight, x, div);
        //     }
        // }
        return parseInt(length);
    }
  },

   initialPosFind : function(elementtt){
            var iniData1 = {}, repose = this.getData('ltPropForcedReposition')
            iniData1.x = (elementtt.getAttribute('lyte-grid-x') && !repose ) ? parseInt(elementtt.getAttribute('lyte-grid-x')) : undefined;
            iniData1.y = (elementtt.getAttribute('lyte-grid-y') && !repose ) ? parseInt(elementtt.getAttribute('lyte-grid-y')) : undefined;
            iniData1.length = elementtt.getAttribute('lyte-grid-length') ? this.returnWid(elementtt.getAttribute('lyte-grid-length'), true, elementtt) : this.returnWid(this.getData('ltPropDefaultLength'), true);
            iniData1.height = elementtt.getAttribute('lyte-grid-height') ? this.returnWid(elementtt.getAttribute('lyte-grid-height'), null, elementtt) : this.returnWid(this.getData('ltPropDefaultHeight'));
            return iniData1;
  },

  checkPreviousGrid : function(){
     var nodeName  = this.$node.parentElement;
     while(nodeName && nodeName.tagName != "BODY"){
        if(nodeName.tagName == "LYTE-GRIDSTACK"){
            this._parentGrid = nodeName;
            this._parentGridIndex = nodeName.component._childGrids.length;
            nodeName.component._childGrids.push(this.$node);
            break;
        }
        if(nodeName.tagName == "LYTE-GRID-CONTENT"){
            nodeName.parentElement._childGrid = this.$node
            this._parentComp = nodeName.parentElement;
        }
        nodeName = nodeName.parentElement;
     } 
     if(nodeName && nodeName.tagName == "LYTE-GRIDSTACK"){
        return true
     }
     return false;  
  },

  retNode : function(sim, data) {
    var arr = [];
    for( var i = 0; i < sim.length; i++ ) {
        arr.push( data[ sim[ i ] ].nodeName );
     }
    return arr; 
  },

  findGrid : function() {
     var bccr = this.$node.getBoundingClientRect(), sim, data = this.getData( 'lyteGridStack' ), arr;
     var x = this.$node.scrollLeft, y = this.$node.scrollTop, length = x + bccr.width, height = y + bccr.height;
     var vis = { left : this.returnY( { offLeft : x } ), top : this.returnY( { offTop : y } , true), right : this.returnY( { offLeft : length } ), bottom : this.returnY( { offTop : height }, true ) };
     this.setData('ltPropVisibleBoundary', vis)
     sim = this.similarData( this.multipleRemoval( this.yElementsFind( vis.top + 1, vis.bottom - 1, this.getData( 'yElements' ) ) ), this.multipleRemoval( this.yElementsFind( vis.left + 1, vis.right - 1, this.getData( 'xElements' ) ) ) );
     arr = this.retNode( sim, data );
     this.setData( 'ltPropVisible', arr );
  },

  scroll :  function( event ) {
    this.findGrid();
    if( this.getMethods( 'onScroll' ) ) {
        this.executeMethod( 'onScroll', this.getData( 'ltPropVisible' ), this.getData( 'ltPropVisibleBoundary' ), this.$node)
    }
  },

  click : function( event ) {
    var className =  this.getData( 'ltPropGridSelectionClass' );
    if( className ) {
        var nodeName = this.nodeName( event ), temp = $L( '.' + className , this.$node);
        if( temp.e.length ) {
            temp.removeClass( className );
        }
        // if( this._preventClick ) {
        //     delete this._preventClick;
        //     return;
        // }
        if( nodeName ) {
            nodeName.classList.add( className )
        }
    }
  },

// after rendering properties
    didConnect : function(){    
            var scopeDiv = this.getData('ltPropScope').trim(), ltPropUnitX = this.getData('ltPropUnitX'), ltPropMarginLeft = this.getData('ltPropMarginLeft');
            this.setData('ltPropUnitXCopy', ltPropUnitX);
            this.setData('ltPropMarginLeftCopy', ltPropMarginLeft);
            this._scroll = this.scroll.bind(this);
            this._click = this.click.bind(this);
            this.$node.addEventListener( 'scroll', this._scroll, true);
            document.addEventListener( 'click', this._click );
            var element = (/^#/g.test(scopeDiv) && !/\s/g.test(scopeDiv)) ? $L(scopeDiv).e : $L(scopeDiv).e[0];
            var lyteQuerySelector = this.getData('lyteQuerySelector');
            this.scopeElement = element;   
            $L(this.scopeElement).addClass('lyteGridstackScope');
            if(element.tabIndex == -1){
                 element.tabIndex = 0
            }     
            element.lyteData = {};
            element.component = this;
            element.addEventListener('mousedown',function(event){
                if(event.target != this && event.button != 2)
                    {
                        this.component.mousedown.call(this.component, event);
                        if(!event.shiftKey){
                            document.addEventListener('mouseup', this.component.upfunc, true)
                        }
                        event.stopPropagation();
                    }
                document._lyteCurrentGrid = this.component;                  
            })
            this.setData('lyteQuerySelector.keydown', this.keydown.bind(this));
            document.addEventListener('keydown',this.getData('lyteQuerySelector').keydown)
            this.$node.addGrid = function(div, obj) {
                $L.fastdom.mutate(function(){
                    div._addGrid  = true;
                    var ltPropColumnMode = this.getData('ltPropColumnMode');
                    obj = obj != undefined ? obj : {};
                    if(obj.length){
                        obj.length = this.returnWid(obj.length, true, div)
                    }
                    if(obj.height){
                        obj.height = this.returnWid(obj.height, null, div)
                    }
                    for(var i in obj){
                        if(obj[i])
                            {
                                if(i != 'resize')
                                    {
                                        obj[i] = parseInt(obj[i]);
                                    }
                            }
                    }
                    obj.nodeName = div;
                    div.classList.add('lyteGridstackHandler');
                    if(!ltPropColumnMode)
                        {
                            var newVal = this.emptySpaceFind.call(this, obj);
                            if(newVal[1])    
                                {
                                    div.setAttribute('lyte-grid-x', newVal[0].x);
                                    div.setAttribute('lyte-grid-y', newVal[0].y);
                                }
                            else
                                {
                                    div.setAttribute('lyte-grid-x', ( obj.x != undefined  && obj.x.constructor == Number) ? obj.x : newVal[0].x);
                                    div.setAttribute('lyte-grid-y', ( obj.y != undefined  && obj.y.constructor == Number) ? obj.y : newVal[0].y);
                                }    
                            div.setAttribute('lyte-grid-length', obj.length ? obj.length : this.returnWid(this.getData('ltPropDefaultLength'), true));
                            div.setAttribute('lyte-grid-height', obj.height ? obj.height : this.returnWid(this.getData('ltPropDefaultHeight')));
                            div.setAttribute('lyte-grid-min-length', obj.minLength ? obj.minLength : this.returnWid(this.getData('ltPropDefaultMinLength'), true));
                            div.setAttribute('lyte-grid-min-height', obj.minHeight ? obj.minHeight : this.returnWid(this.getData('ltPropDefaultMinHeight')));
                            div.setAttribute('lyte-grid-max-length', obj.maxLength ? obj.maxLength : this.returnWid(this.getData('ltPropDefaultMaxLength'), true));
                            div.setAttribute('lyte-grid-max-height', obj.maxHeight ? obj.maxHeight : this.returnWid(this.getData('ltPropDefaultMaxHeight')));
                        }
                    if(obj.resize == 'disabled')
                        {
                            div.setAttribute('lt-prop-resize', obj.resize)
                        }
                    // new grid is appended to the dom here  
                    if( !this.scopeElement.contains( div ) ) {  
                        this.scopeElement.appendChild(div);   
                    }
                    this.initialValSet.call(this, true);
                    this.cssConstruct.call(this, div, 'lyte-grid-y');
                    this.getData('iniData').push(this.initialPosFind.call(this, div));
                    var data = this.getData('lyteGridStack');
                    this.previousPos.call(this, data.length);
                    $L.fastdom.mutate(function(){
                        if(newVal && newVal[1] == false && !ltPropColumnMode)
                            {
                                this.topCheck.call(this, div, this.scopeElement);
                                if(!this.getData('ltPropFloat'))
                                    {
                                         var hgtMove = this.heightGet.call(this, div);
                                        if(hgtMove)
                                            {   
                                                data[div.elemNum].y -= hgtMove; 
                                                this.valueUpdating.call(this, div.elemNum, 'lyte-grid-y', data[div.elemNum].y);
                                                this.setVal.call(this, div, 'lyte-grid-y', data[div.elemNum].y);
                                                this.previousPos.call(this, data.length);
                                            }
                                        this.topMoveFunc.call(this, div, null, null, null, true);
                                    }
                                 this.findGrid();   
                            }
                        if(div._childGrid){
                           div._childGrid.reRender(null, true)
                       } 
                    }.bind(this))
                }.bind(this))                    
             }.bind(this); 
             this.$node.removeGrid = function(div){
                if(this.scopeElement.contains(div))
                    {
                        var handQuer = this.getData('ltPropHandler'), data = this.getData( 'lyteGridStack' ), hgt = data[ div.elemNum ].y + data[ div.elemNum ].height;
                        Lyte.arrayUtils(this.getData('iniData'), 'removeAt', div.elemNum);
                        // grid removed
                        div.parentElement.removeChild(div);
                        Lyte.arrayUtils( this.getData( 'lyteGridStack' ), 'remove', 0, data.length);
                        // called for removal of unused styles
                        this.initialValSet.call(this);
                        this.positionFind.call(this, (/^#/g.test(handQuer) && !/\s/g.test(handQuer)) ? this.scopeElement.querySelectorAll(handQuer) : $L(handQuer, this.scopeElement).e);
                        this.findGrid();
                        this.topMoveAllGrid( hgt , data)
                    }
             }.bind(this);
             this.$node.reRender = function(flag){
                // previous styles are removed and new will be constructed
                    if(this._style){
                        this.$node.removeChild(this._style);
                        delete this._style;
                    }
                    var data = this.getData('lyteGridStack');
                    Lyte.arrayUtils(data, 'remove', 0 , data.length);
                    this.didConnectWrk.call(this, true, flag);
             }.bind(this),
             this.$node.setProperty = function(targetDiv, propertyName, propValue){
                if(propertyName == "height" || propertyName == "length"){ 
                        propValue = this.returnWid(propValue, propertyName == "length" ? true : false, targetDiv)
                }else{
                    propValue = parseInt(propValue)
                }
                var data = this.getData('lyteGridStack');
                var comProp = ['x', 'y', 'length', 'height'];
                var dataVal = {};
                if(comProp.indexOf(propertyName) != -1){
                    for(var yy in data[targetDiv.elemNum]){
                        if(comProp.indexOf(yy) != -1)
                            {
                                dataVal[yy] = data[targetDiv.elemNum][yy];
                            }
                    }
                    
                    dataVal[propertyName] = propValue;
                    dataVal.nodeName = targetDiv;
                    var newVal = this.emptySpaceFind.call(this, dataVal);
                    if(newVal[1]){
                        for(var zz in newVal[0]){
                            this.setVal.call(this, targetDiv, 'lyte-grid-' + zz, newVal[0][zz]);
                        } 
                    }
                }
                this.setVal.call(this, targetDiv, 'lyte-grid-' + propertyName, propValue);
                var pp = propertyName.replace(/(-\w)/g, function (m) {
                        return m[1].toUpperCase();
                    });
                data[targetDiv.elemNum][pp] = propValue
                if(comProp.indexOf(propertyName) != -1)
                    {
                        this.valueUpdating.call(this, targetDiv.elemNum, 'lyte-grid-' + propertyName, propValue);
                        this.previousPos.call(this, data.length);
                        if(newVal[1] == false){
                            this.topCheck.call(this, targetDiv, this.scopeElement, null, true);
                        }
                        if(!this.getData('ltPropFloat')){
                            var hgtMove = this.heightGet.call(this, targetDiv);
                            if(hgtMove)
                                {   
                                    data[targetDiv.elemNum].y -= hgtMove; 
                                    this.valueUpdating.call(this, targetDiv.elemNum, 'lyte-grid-y', data[targetDiv.elemNum].y);
                                    this.setVal.call(this, targetDiv, 'lyte-grid-y', data[targetDiv.elemNum].y);
                                    this.previousPos.call(this, data.length);
                                }
                            this.topMoveFunc.call(this, targetDiv, null, null, null, true);
                        }
                        this.previousPos.call(this, $L(this.getData('ltPropHandler'), this.scopeElement).e);
                    }
                if(targetDiv._childGrid){
                        if((propertyName == "height" || propertyName == "length")){
                            targetDiv._childGrid.reRender(true)
                        }
                   }
                this.findGrid();       
             }.bind(this);
            this._resizeFunc = this.windowResize.bind(this);   
            this._initialWindowWidth = window.innerWidth
            window.addEventListener('resize', this._resizeFunc, true); 
            if(this.checkPreviousGrid()){
                return
            }
            this.didConnectWrk.call(this, true)
    },

    gridLength : function(width, ltPropUnitX1, ltPropMarginLeftCopy){
       ltPropMarginLeftCopy = ltPropMarginLeftCopy ? ltPropMarginLeftCopy : 'ltPropMarginLeftCopy';
       var margin = parseInt(this.getData(ltPropMarginLeftCopy));
       var ltPropUnitX = ltPropUnitX1 ? ltPropUnitX1 : this.getData('ltPropUnitX'), len = parseInt((((width ? width : (this.bcrrelem ? this.bcrrelem.width : this.scopeElement.getBoundingClientRect().width)) - (margin)) / (ltPropUnitX + margin)).toFixed(0));
       return len;
    },

    columnModeLengthFind : function(){
        this._prevObs = true;
        var length = this.getData('ltPropGridLength') || this.getData('ltPropColumn');
        var margin = this.getData('ltPropMarginLeftCopy');
        margin = margin ? margin : this.getData('ltPropMarginLeft');
        this.setData('ltPropUnitX', (( this.bcrrelem ? this.bcrrelem.width : this.scopeElement.getBoundingClientRect().width) - ( length + 1 ) * margin) / ( length ) )
        delete this._prevObs;
    },

    didConnectWrk : function(flag, flag2){
        $L.fastdom.measure(function(){
                if(!this.$node.offsetParent){
                    return
                }
                var bcrrelem = this.scopeElement.getBoundingClientRect(), element = this.scopeElement, lyteQuerySelector = this.getData('lyteQuerySelector');
                this.bcrrelem = bcrrelem;  
                var ltPropColumnMode = this.getData('ltPropColumnMode') 
                var handQuer = this.getData('ltPropHandler');
                var iniData = this.getData('iniData');
                var data = this.getData('lyteGridStack');
                Lyte.arrayUtils(iniData, 'remove', 0, iniData.length);
                var elements = (/^#/g.test(handQuer) && !/\s/g.test(handQuer)) ? element.querySelectorAll(handQuer) : $L(handQuer, element).e;
                if( this._parentGrid && !this.getData('ltPropGridLength')) {
                    var grL = this.gridLength();
                    this.setData( 'ltPropGridLength', grL);
                    this.setData('gridLength', grL);
                }
                if(ltPropColumnMode || this.getData('ltPropGridLength')){
                    this.columnModeLengthFind();
                }
                if(!this.getData('gridLength') || flag2 || ltPropColumnMode){
                    this.setData('gridLength', this.gridLength())
                }
                if(!this.$node.ltProp('gridHeight') && !flag2 || ltPropColumnMode){
                        this.$node.ltProp('gridHeight', this.getData('gridLength'));
                }else if(flag2){
                    this.$node.ltProp('gridHeight', this.getData('gridLength'));
                } 
             for(var i = 0; i < elements.length; i++)
                {
                    iniData.push(this.initialPosFind.call(this, elements[i]));
                }
                $L.fastdom.mutate(this.initialValSet.bind(this))    
                var elements = $L(this.getData('ltPropHandler'), element).e, ltPropUnitX = this.getData('ltPropUnitX');
                element.lyteData.gridLength = this.getData('gridLength')
                element.lyteData.gridHeight = lyteQuerySelector.maxHeight;
                
                this._initialXRatio = ltPropUnitX / bcrrelem.width;
                this._initialMarginRatio = this.getData('ltPropMarginLeft') / ltPropUnitX;
                $L.fastdom.mutate(function(){
                        if(this._childGrids.length){
                        for(var i = 0; i < this._childGrids.length; i++){
                               this._childGrids[i].reRender()
                            }
                        }
                        if(flag){
                            if(this.getMethods('afterRender')){
                                    this.executeMethod('afterRender', this.$node);
                                }
                        }
                    this.findGrid();
                }.bind(this))
            }.bind(this)) 
    },
    // data 
    data : function(){
        return {
            // user data
            ltPropScope : Lyte.attr("string",{"default": ''}), 
            ltPropHandler : Lyte.attr("string",{"default":''}), 
            ltPropMarginLeft : Lyte.attr("number",{"default":10}), 
            ltPropMarginTop : Lyte.attr("number",{"default":10}), 
            ltPropUnitX : Lyte.attr("number",{"default":50}), 
            ltPropUnitY : Lyte.attr("number",{"default":50}), 
            ltPropResizeDirection : Lyte.attr("array",{"default":['left', 'right', 'bottom', 'bottomRight', 'bottomLeft', 'top', 'topLeft', 'topRight']}), 
            ltPropFloat : Lyte.attr("boolean",{"default": false}), 
            ltPropDirection : Lyte.attr("string",{"default":"vertical"}), 
            ltPropUndo : Lyte.attr("boolean",{"default": true}), 
            ltPropResize : Lyte.attr("boolean",{"default": true}), 
            ltPropBestfit : Lyte.attr("boolean",{"default": true}), 
            ltPropMinUnitX : Lyte.attr('number',{default : 0}),
            ltPropMinMarginLeft : Lyte.attr('number',{default : 0}),
            ltPropBestfitClass : Lyte.attr('string', {default : ''}),
            ltPropFreezeMode : Lyte.attr('boolean', {default : false}),
            ltPropDefaultLength : Lyte.attr('string',{default : '2'}),
            ltPropDefaultHeight : Lyte.attr('string',{default : '2'}),
            ltPropDefaultMinLength : Lyte.attr('string',{default : '1'}),
            ltPropDefaultMinHeight : Lyte.attr('string',{default : '1'}),
            ltPropDefaultMaxHeight : Lyte.attr('string',{default : '0'}),
            ltPropDefaultMaxLength : Lyte.attr('string',{default : '0'}),
            ltPropColumnMode : Lyte.attr('boolean', {default : false}),
            ltPropColumn : Lyte.attr('number', {default : 3}),
            ltPropPrevent : Lyte.attr('object', { default : { horizontal : false, vertical : false }}),
            ltPropGridLength : Lyte.attr('number', {default : undefined}),
            ltPropBestfitType : Lyte.attr('string', { default : 'default'}),
            ltPropForcedReposition : Lyte.attr('boolean', { default : false}),
            ltPropSquareGrid : Lyte.attr('boolean', { default : false}),
            ltPropGridSpaceColor : Lyte.attr('string', { default : '#f8f8f8' }),
            ltPropHitBottom : Lyte.attr('boolean', { default : false}),
            ltPropGridSelectionClass: Lyte.attr( 'string', { default : '' } ),
            ltPropVisibleBoundary : Lyte.attr( 'object', { default : {} } ),
            ltPropVisible : Lyte.attr( 'array', { default : [] } ),

            // system data
            gridLength : Lyte.attr("number",{"default":undefined}), 
            ltPropGridHeight : Lyte.attr("number",{"default":undefined}),
            ltPropMarginLeftCopy : Lyte.attr("number",{"default":10}), 
            ltPropUnitXCopy : Lyte.attr("number",{"default":50}),  
            lyteGridStack : Lyte.attr("array",{"default":[]}), 
            // ltPropFlag : Lyte.attr("boolean",{"default": true}), 
            elements : Lyte.attr("object",{"default":undefined}), 
            oriNode : Lyte.attr("object",{"default":undefined}), 
            xElements : Lyte.attr("array",{"default":[]}), 
            yElements : Lyte.attr("array",{"default":[]}),
            iniData : Lyte.attr('array', {'default' : []}),
            lyteQuerySelector : Lyte.attr('object',{'default' : {}})
        }
    }, 
    // undo
    undoPrevious : function(){
            var data = this.getData('lyteGridStack'), lyteQuerySelector = this.getData('lyteQuerySelector') ;
            var elements = $L(this.getData('ltPropHandler'), this.scopeElement).e;
            if((lyteQuerySelector.currentPos) <= data[data.length - 1].oldHeight.length && lyteQuerySelector.currentPos >= 1)
                {
                    for(var i = 0;i < elements.length;i++ )
                        {
                            data[i].x = parseInt(data[i].oldX[lyteQuerySelector.currentPos-1])
                            data[i].nodeName.dataSet['lyte-grid-x-old'] = data[i].x
                            data[i].y = parseInt(data[i].oldY[lyteQuerySelector.currentPos-1])
                            data[i].nodeName.dataSet['lyte-grid-y-old'] = data[i].y
                            data[i].length = parseInt(data[i].oldLength[lyteQuerySelector.currentPos-1])
                            data[i].nodeName.dataSet['lyte-grid-length-old'] = data[i].length
                            data[i].height = parseInt(data[i].oldHeight[lyteQuerySelector.currentPos-1])
                            data[i].nodeName.dataSet['lyte-grid-height-old'] = data[i].height
                        }
                    this.displayGrid.call(this);
                    lyteQuerySelector.currentPos = (lyteQuerySelector.currentPos - 1) >= 0 ? (lyteQuerySelector.currentPos - 1) : 0;  
                }
        },
        // redo 
    undoNext : function(){
            var data = this.getData('lyteGridStack'), lyteQuerySelector = this.getData('lyteQuerySelector') ;
            var elements = $L(this.getData('ltPropHandler'), this.scopeElement).e;
            if((lyteQuerySelector.currentPos) <= (data[data.length - 1].oldHeight.length-1))
                {
                    var dumm = lyteQuerySelector.currentPos < (data[data.length - 1].oldHeight.length - 1) ? (lyteQuerySelector.currentPos + 1) : (data[data.length - 1].oldHeight.length - 1);
                    for(var i = 0; i < elements.length; i++)
                        {
                            data[i].x = parseInt(data[i].oldX[dumm]);
                            data[i].nodeName.dataSet['lyte-grid-x-old'] = data[i].x;
                            data[i].y = parseInt(data[i].oldY[dumm]);
                            data[i].nodeName.dataSet['lyte-grid-y-old'] = data[i].y;
                            data[i].length = parseInt(data[i].oldLength[dumm]);
                            data[i].nodeName.dataSet['lyte-grid-length-old'] = data[i].length;
                            data[i].height = parseInt(data[i].oldHeight[dumm]);
                            data[i].nodeName.dataSet['lyte-grid-height-old'] = data[i].height;
                        }
                    this.displayGrid.call(this);
                    lyteQuerySelector.currentPos = dumm;
                }
    },

     emptySpaceFind : function(objj, flagg, mappArray1, flag2){
        var data = this.getData('lyteGridStack');
        var mappArray = [], i ,j ,gridLength = this.getData('gridLength'), gridHeight = this.getData('ltPropGridHeight');
        if(!flagg)       
            {
                for(i = 0; i < gridLength; i++)
                    {
                        mappArray.push([]);
                        for(var z = 0; z < gridHeight; z++)
                            {
                                mappArray[i].push(false)
                            }
                    }
                for(i = 0; i < data.length; i++)
                    {   
                        if(data[i].x != undefined && data[i].y != undefined)
                            {
                                for(var k = data[i].x; k < (data[i].x + data[i].length); k++)
                                    {
                                        for(var m = data[i].y; m < (data[i].y + data[i].height); m++)
                                            {
                                                if(data[i].nodeName != objj.nodeName && mappArray[k] != undefined && mappArray[k][m] != 'res')
                                                    {
                                                        mappArray[k][m] = true;
                                                    }
                                                 else if(mappArray[k] && mappArray[k][m] == false)
                                                    {
                                                        mappArray[k][m] = 'res';
                                                    }   
                                            }
                                    }
                            }
                    } 
            }
          else
            {
                mappArray = mappArray.concat(mappArray1.slice());
            }  
        objj.length = objj.length != undefined ? objj.length : this.returnWid(this.getData('ltPropDefaultLength'), true);  
        objj.height = objj.height != undefined ? objj.height : this.returnWid(this.getData('ltPropDefaultHeight'));
        var xStar = objj.x ? objj.x : 0;    
        var yStar = objj.y ? objj.y : 0; 
        var xLim = objj.x != undefined && !isNaN(objj.x) ? (objj.x + 1) : (gridLength + 1 - objj.length);
        var yLim = objj.y != undefined && !isNaN(objj.x) ? (objj.y) : (gridHeight - 1);
        for(var i = yStar; i <= yLim; i++)
            {
                for(var j = xStar; j < xLim; j++)
                    {
                        var flag = true;
                        for(var k = j; k < (j + objj.length); k++)
                            {
                                for(var l = i; l < (i + objj.height); l++)
                                    {
                                        if(mappArray[k] && mappArray[k][l] == true)
                                            {
                                                flag = false;
                                                hgtShort = l - i;
                                                break;
                                            }
                                    }
                                 if(!flag)
                                    {
                                        break;
                                    }   
                            }
                        if(flag && j < (gridLength + 1 - objj.length))
                            {
                                return [{x : j, y : i}, !flagg];
                            }    
                    }   
            }
        var temp;
        if(!flagg){
                temp = this.emptySpaceFind.call(this, {length : objj.length, height : objj.height, nodeName : objj.nodeName}, true, mappArray);
            }
       if(!flag2){
                this.setData('ltPropGridHeight', gridHeight + objj.height);
                temp = this.emptySpaceFind.call(this, {length : objj.length, height : objj.height, nodeName : objj.nodeName}, true, mappArray, true);

            }  
          return (temp.constructor == Array ? temp : [temp, false]);   
    }

}); 

Lyte.Component.register("lyte-input",{
_template:"<template tag-name=\"lyte-input\">     <template is=\"switch\" value=\"{{ltPropType}}\">       <template case=\"password\">              <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\">                    <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label>               </template></template>             <div class=\"lyteField\" style=\"{{ltPropWrapperStyle}}\">                 <input pattern=\"{{ltPropPattern}}\" tabindex=\"{{ltPropTabIndex}}\" type=\"{{ltPropType}}\" value=\"{{lbind(ltPropValue)}}\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" maxlength=\"{{ltPropMaxlength}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autocomplete=\"{{ltPropAutocomplete}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" style=\"{{ltPropStyle}}\" readonly=\"{{ltPropReadonly}}\" onfocus=\"{{action('focusClass')}}\" onblur=\"{{action('blurThrow', event)}}\" onkeyup=\"{{action('keyup', event)}}\" title=\"{{ltPropInputTitle}}\">               </div>         </template>        <template case=\"number\">            <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\">                  <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label>              </template></template>              <div class=\"lyteField\" style=\"{{ltPropWrapperStyle}}\">                 <input pattern=\"{{ltPropPattern}}\" tabindex=\"{{ltPropTabIndex}}\" type=\"number\" value=\"{{lbind(ltPropValue)}}\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" maxlength=\"{{ltPropMaxlength}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autocomplete=\"{{ltPropAutocomplete}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" style=\"{{ltPropStyle}}\" onfocus=\"{{action('focusClass')}}\" onblur=\"{{action('blurThrow', event)}}\" onkeyup=\"{{action('keyup', event)}}\" step=\"{{ltPropStep}}\" max=\"{{ltPropMax}}\" min=\"{{ltPropMin}}\" title=\"{{ltPropInputTitle}}\">               </div>         </template>                                                                                     <template case=\"textarea\">                <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\">                     <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label>                </template></template>                <div class=\"lyteField\" style=\"{{ltPropWrapperStyle}}\">                  <textarea autocomplete=\"{{ltPropAutocomplete}}\" pattern=\"{{ltPropPattern}}\" tabindex=\"{{ltPropTabIndex}}\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" value=\"{{lbind(ltPropValue)}}\" rows=\"{{ltPropRows}}\" cols=\"{{ltPropCols}}\" maxlength=\"{{ltPropMaxlength}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" style=\"{{ltPropStyle}}\" onfocus=\"{{action('focusClass')}}\" onblur=\"{{action('blurThrow', event)}}\" onkeyup=\"{{action('keyup', event)}}\" title=\"{{ltPropInputTitle}}\"></textarea>                   <template is=\"if\" value=\"{{resize}}\"><template case=\"true\">                    <span class=\"lyteTextareaResize\"></span>                      </template></template>              </div>             </template>          <template case=\"date\">              <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\">                  <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label>              </template></template>                <div class=\"lyteField\" style=\"{{ltPropWrapperStyle}}\">                 <input pattern=\"{{ltPropPattern}}\" tabindex=\"{{ltPropTabIndex}}\" type=\"text\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autocomplete=\"{{ltPropAutocomplete}}\" value=\"{{lbind(ltPropCurrentDate)}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" onkeyup=\"{{action('keyup', event)}}\" onkeydown=\"{{action('calendarKeydown', event, this)}}\" onclick=\"{{action('calendarClick', event, this)}}\" onfocus=\"{{action('showcalendar', event, this)}}\" onblur=\"{{action('blurThrow', event)}}\" onfocusout=\"{{action('calFocusout')}}\" style=\"{{ltPropStyle}}\" title=\"{{ltPropInputTitle}}\">              </div>            <lyte-wormhole>                  <template is=\"registerYield\" yield-name=\"lyte-content\">                      <div id=\"lyteCalendar\" class=\"lyteCalendarHidden {{ltPropCalendarClass}}\" style=\"position: absolute;z-index: 1000;\">                          <lyte-calendar lt-prop-fill-rows=\"{{ltPropFillRows}}\" lt-prop-number-of-rows=\"{{ltPropNumberOfRows}}\" lt-prop-yield=\"{{ltPropYield}}\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-end-date=\"{{lbind(ltPropEndDate)}}\" lt-prop-start-date=\"{{lbind(ltPropStartDate)}}\" lt-prop-current-date=\"{{lbind(ltPropCurrentDate)}}\" lt-prop-year=\"{{lbind(ltPropYear)}}\" lt-prop-month-header=\"{{lbind(ltPropMonthHeader)}}\" on-date-selected=\"{{method('on-dateselected')}}\" lt-prop-min-date=\"{{lbind(ltPropMinDate)}}\" lt-prop-max-date=\"{{lbind(ltPropMaxDate)}}\" lt-prop-start-week-day=\"{{lbind(ltPropStartWeekDay)}}\">                             <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\">                                 <template is=\"registerYield\" yield-name=\"footer\">                                    <lyte-yield yield-name=\"footer\"></lyte-yield>                                </template>                             </template></template>                             </lyte-calendar>                       </div>                   </template>          </lyte-wormhole>          </template>         <template case=\"datetime\">              <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\">                  <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label>              </template></template>                <div class=\"lyteField\" style=\"{{ltPropWrapperStyle}}\">                 <input tabindex=\"{{ltPropTabIndex}}\" type=\"text\" id=\"date\" placeholder=\"{{ltPropPlaceholder}}\" value=\"{{lbind(ltPropCurrentDate)}}\" onkeyup=\"{{action('keyup', event)}}\" onkeydown=\"{{action('calendarKeydown', event, this)}}\" onclick=\"{{action('calendarClick', event, this)}}\" onfocus=\"{{action('showcalendar', event, this)}}\" onblur=\"{{action('blurThrow', event)}}\" onfocusout=\"{{action('calFocusout')}}\">                 <input tabindex=\"{{ltPropTabIndex}}\" type=\"text\" value=\"{{ltPropDefaultTime}}\" id=\"time\" onblur=\"{{action('timeBlur', event, this)}}\" onfocus=\"{{action('timeFocus', event, this)}}\" onkeydown=\"{{action('timeKeydown', event, this)}}\" onclick=\"{{action('timeClick', event, this)}}\" style=\"{{ltPropStyle}}\">              </div>              <lyte-wormhole>                    <template is=\"registerYield\" yield-name=\"lyte-content\">                        <div id=\"lyteCalendar\" class=\"lyteCalendarHidden {{ltPropCalendarClass}}\" style=\"position: absolute;z-index: 1000;\">                            <lyte-calendar lt-prop-fill-rows=\"{{ltPropFillRows}}\" lt-prop-number-of-rows=\"{{ltPropNumberOfRows}}\" lt-prop-yield=\"{{ltPropYield}}\" lt-prop-format=\"{{ltPropFormat}}\" lt-prop-end-date=\"{{lbind(ltPropEndDate)}}\" lt-prop-start-date=\"{{lbind(ltPropStartDate)}}\" lt-prop-current-date=\"{{lbind(ltPropCurrentDate)}}\" lt-prop-year=\"{{lbind(ltPropYear)}}\" lt-prop-month-header=\"{{lbind(ltPropMonthHeader)}}\" on-date-selected=\"{{method('on-dateselected')}}\" lt-prop-min-date=\"{{lbind(ltPropMinDate)}}\" lt-prop-max-date=\"{{lbind(ltPropMaxDate)}}\" lt-prop-start-week-day=\"{{lbind(ltPropStartWeekDay)}}\" lt-prop-header-type=\"{{ltPropHeaderType}}\">                               <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\">                                   <template is=\"registerYield\" yield-name=\"footer\">                                      <lyte-yield yield-name=\"footer\"></lyte-yield>                                  </template>                               </template></template>                               </lyte-calendar>                         </div>                     </template>            </lyte-wormhole>             <lyte-dropdown style=\"display: none;\" lt-prop-position=\"{{ltPropPosition}}\" lt-prop-yield=\"true\" lt-prop-disabled=\"{{ltPropDropdownDisabled}}\" lt-prop-show=\"{{ltPropDropdownShow}}\" lt-prop-callout=\"{{ltPropDropdownShow}}\" lt-prop-boundary=\"{{ltPropBoundary}}\" lt-prop-freeze=\"{{ltPropDropdownFreeze}}\" on-hide=\"{{method('hide')}}\" on-show=\"{{method('show')}}\" on-before-hide=\"{{method('beforeHide')}}\" on-before-show=\"{{method('beforeShow')}}\" on-option-selected=\"{{method('optionSelected')}}\" on-position-changed=\"{{method('positionChange')}}\" on-scroll=\"{{method('scroll')}}\">               <template is=\"registerYield\" yield-name=\"yield\">                  <lyte-drop-button style=\"display: none;\"></lyte-drop-button>                  <lyte-drop-box id=\"{{ltPropDropdownId}}\" class=\"{{ltPropDropdownClass}}\">                    <lyte-drop-body>                      <template is=\"for\" items=\"{{dropdownData}}\" item=\"item\" index=\"index\">                          <lyte-drop-item data-value=\"{{item.time}}\">                            <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\">                                 <lyte-yield yield-name=\"yield\" item-value=\"{{item}}\"></lyte-yield>                            </template><template case=\"false\">                                <span>{{item.time}}</span>                                <template is=\"if\" value=\"{{ltPropShowInterval}}\"><template case=\"true\">                                   <span style=\"opacity: 0.5;float: right;margin-left: 5px; \">{{item.interval}}</span>                                 </template></template></template></template>                          </lyte-drop-item>                      </template>                    </lyte-drop-body>                  </lyte-drop-box>               </template>             </lyte-dropdown>          </template>         <template case=\"time\">            <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\">                  <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label>              </template></template>              <div class=\"lyteField\" style=\"{{ltPropWrapperStyle}}\">                 <input tabindex=\"{{ltPropTabIndex}}\" type=\"text\" value=\"{{ltPropDefaultTime}}\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" maxlength=\"{{ltPropMaxlength}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autocomplete=\"{{ltPropAutocomplete}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" onblur=\"{{action('timeBlur', event, this)}}\" onfocus=\"{{action('timeFocus', event, this)}}\" onkeydown=\"{{action('timeKeydown', event, this)}}\" onclick=\"{{action('timeClick', event, this)}}\" style=\"{{ltPropStyle}}\" title=\"{{ltPropInputTitle}}\">              </div>              <template is=\"if\" value=\"{{ltPropDropdown}}\"><template case=\"true\">                   <lyte-dropdown style=\"display: none;\" lt-prop-position=\"{{ltPropPosition}}\" lt-prop-yield=\"true\" lt-prop-disabled=\"{{ltPropDropdownDisabled}}\" lt-prop-show=\"{{ltPropDropdownShow}}\" lt-prop-callout=\"{{ltPropDropdownShow}}\" lt-prop-boundary=\"{{ltPropBoundary}}\" lt-prop-freeze=\"{{ltPropDropdownFreeze}}\" on-hide=\"{{method('hide')}}\" on-show=\"{{method('show')}}\" on-before-hide=\"{{method('beforeHide')}}\" on-before-show=\"{{method('beforeShow')}}\" on-option-selected=\"{{method('optionSelected')}}\" on-position-changed=\"{{method('positionChange')}}\" on-scroll=\"{{method('scroll')}}\">                     <template is=\"registerYield\" yield-name=\"yield\">                        <lyte-drop-button style=\"display: none;\"></lyte-drop-button>                        <lyte-drop-box id=\"{{ltPropDropdownId}}\" class=\"{{ltPropDropdownClass}}\">                          <lyte-drop-body>                            <template is=\"for\" items=\"{{dropdownData}}\" item=\"item\" index=\"index\">                                <lyte-drop-item data-value=\"{{item.time}}\">                                  <template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\">                                       <lyte-yield yield-name=\"yield\" item-value=\"{{item}}\"></lyte-yield>                                  </template><template case=\"false\">                                      <span>{{item.time}}</span>                                      <template is=\"if\" value=\"{{ltPropShowInterval}}\"><template case=\"true\">                                         <span style=\"opacity: 0.5;float: right;margin-left: 5px; \">{{item.interval}}</span>                                       </template></template></template></template>                                </lyte-drop-item>                            </template>                          </lyte-drop-body>                        </lyte-drop-box>                     </template>                   </lyte-dropdown>                </template></template>                </template>         <template default=\"\">              <template is=\"if\" value=\"{{ltPropLabel}}\"><template case=\"true\">                  <label for=\"{{ltPropId}}\" class=\"lyteLabel\">{{ltPropLabel}}</label>              </template></template>                <div class=\"{{if(ifEquals(ltPropAppearance == 'box'), if(ifEquals(ltPropType, 'search'), 'lyteInputBoxSearch lyteField','lyteField'), 'lyteField')}}\" style=\"{{ltPropWrapperStyle}}\">                 <input tabindex=\"{{ltPropTabIndex}}\" type=\"text\" value=\"{{lbind(ltPropValue)}}\" id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" maxlength=\"{{ltPropMaxlength}}\" name=\"{{ltPropName}}\" placeholder=\"{{ltPropPlaceholder}}\" autocomplete=\"{{ltPropAutocomplete}}\" autofocus=\"{{ltPropAutofocus}}\" disabled=\"{{ltPropDisabled}}\" readonly=\"{{ltPropReadonly}}\" onfocus=\"{{action('focusClass')}}\" onblur=\"{{action('blurThrow', event)}}\" onkeyup=\"{{action('keyup', event)}}\" style=\"{{ltPropStyle}}\" title=\"{{ltPropInputTitle}}\" pattern=\"{{ltPropPattern}}\">                 <template is=\"if\" value=\"{{expHandlers(ltPropType,'==','search')}}\"><template case=\"true\">                    <span class=\"searchIcon\"></span>                </template></template>              </div>          <template is=\"break\"></template></template>           </template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"switch","position":[1],"cases":{"password":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}}]},"number":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}}]},"textarea":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}},{"type":"attr","position":[3,3]},{"type":"if","position":[3,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]},"date":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}},{"type":"registerYield","position":[5,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1],"dynamicNodes":[{"type":"insertYield","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[1,1]}]},{"type":"componentDynamic","position":[5]}]},"datetime":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1]},{"type":"attr","position":[3,3],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}},{"type":"registerYield","position":[5,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[1],"dynamicNodes":[{"type":"insertYield","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[1,1]}]},{"type":"componentDynamic","position":[5]},{"type":"attr","position":[7]},{"type":"registerYield","position":[7,1],"dynamicNodes":[{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1,1]},{"type":"for","position":[3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3]}]},{"type":"componentDynamic","position":[7]}]},"time":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}},{"type":"attr","position":[5]},{"type":"if","position":[5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"attr","position":[3,1,1]},{"type":"for","position":[3,1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"text","position":[1,0]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3]}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]}},"default":{}},{"type":"attr","position":[3],"attr":{"style":{"name":"style","dynamicValue":"ltPropWrapperStyle"}}},{"type":"attr","position":[3,1],"attr":{"style":{"name":"style","dynamicValue":"ltPropStyle"}}},{"type":"attr","position":[3,3]},{"type":"if","position":[3,3],"cases":{"true":{"dynamicNodes":[]}},"default":{}}]}}],
_observedAttributes :["ltPropDisabled","ltPropAutofocus","ltPropAutocomplete","ltPropMaxlength","ltPropName","ltPropPlaceholder","ltPropReadonly","ltPropValue","ltPropWidth","ltPropTabIndex","ltPropType","ltPropAppearance","ltPropDirection","ltPropLabel","ltPropId","ltPropClass","ltPropText","ltPropStyle","ltPropText","ltPropWrapperStyle","ltPropHeight","ltPropPattern","ltPropInputTitle","ltPropAccept","ltPropMultiple","ltPropRows","ltPropCols","ltPropTextAreaResize","ltPropMax","ltPropMin","ltPropStep","ltPropTimeFormat","ltPropHourInterval","ltPropDefaultTime","ltPropMinuteInterval","ltPropDropdown","ltPropShowInterval","ltPropStartTime","ltPropEndTime","ltPropFillRows","ltPropNumberOfRows","ltPropMinDate","ltPropMaxDate","ltPropStartWeekDay","ltPropMonthHeaderFormat","daysOfWeek","ltPropYear","ltPropFormat","viewDate","ltPropStartDate","ltPropEndDate","ltPropCurrentDate","ltPropMonthHeader","ltPropCalendarClass","ltPropHeaderType","ltPropDropdownDisabled","ltPropDropdownShow","ltPropDropdownCallout","ltPropDropdownFreeze","ltPropPosition","ltPropBoundary","ltPropWheel","ltPropYield","ltPropAutoUpdate","eventListeners","selectedField","endMinute","startMinute","dropdownData","originalData","dateRange","meridian","hour","min","selectedDateField","preventObs","resize","pos"],
	init:function(){ 
		var type = this.getData('ltPropType');
		  // if(type =='file'){
		  // 		if(!this.getData('ltPropId')){
		  // 				this.setData('ltPropId','lyteFile');
		  // 			}	
		  // 	}
		  if( type == 'time' || type == "datetime" ){
		  	this._prevent = true
		  	this.timeInValChange.call(this);
		  	this.startEndTimeObs.call(this);
		  	delete this._prevent;
		  	if(this.getData('ltPropDropdown')){
		  		this.dropdownConstruct();
		  	}
		  }	
		  if( type == 'date' || type == "datetime" ){
		  	this.dateRegexFind();
		  }
		  this.$node.classList.add('lyteInput');
		  this.$node.classList.add('horizontal');
		  if(this.getMethods('beforeRender'))
            {
                this.executeMethod('beforeRender', this.$node);
            }
          this.$node.focus = function(){
          	  var type = this.getData( 'ltPropType' ) == "textarea" ? "textarea" : 'input';
          	  this.$node.querySelector( type ).focus();
          }.bind( this )  
	},

	didConnect:function(){
		   var type = this.getData('ltPropType'), divIdInput= this.$node, lyteLabelDiv= $L('.lyteLabel', this.$node).e[0],lyteFieldDiv= $L('.lyteField', this.$node).e[0]; 
		   if( type == 'date' || type == "datetime" )
		    	{ 
		    		var func = this.calenderClickHide.bind(this)
		    		document.addEventListener('click', func, true);
		    		this.setData('eventListeners.calendar', func);
		    		var func1 = this.scrollFunc.bind(this);
		    		this.setData('eventListeners.scroll', func1);
		    		window.addEventListener('scroll', func1, true);
		    		window.addEventListener('resize', func1, true);
				}
			// if(type=='file'){
			//   	if(this.getData('ltPropMultiple')==false){
			//  			$L('input',this.$node).e[0].removeAtribute('multiple');
		 // 			}
		 // 		$L('input',this.$node).e[0].style.display="none";	
		 // 	}
		 	if(type == 'time' || type == "datetime" ){
	 			if(this.getData('ltPropDropdown')){
	 				this.dropdown = $L('lyte-dropdown', this.$node).e[0];
	 				this.dropbox =  this.dropdown.component.childComp ? this.dropdown.component.childComp : $L('lyte-drop-box', this.dropdown).e[0];
	 				this.dropdown.element = $L('input' + ( type == 'datetime' ? ":last-of-type" : '' ), this.$node).e[0];
	 			}
	 		}
		 	if(type == 'time' || type == 'date' || type == "datetime"){
		 		var func = this.handleWheel.bind(this);
		 		this.setData('eventListeners.timeWheel', func);
		 		if(this.getData('ltPropWheel')){
		 			this.$node.addEventListener('wheel', func);
				}
		 	}		
		   	if(this.getMethods('afterRender'))
	            {
	                this.executeMethod('afterRender', this.$node);
	            }	
	},

	didDestroy : function(){
		if(this.$node.calendarComp){
			this.$node.calendarComp.remove()
		}
		var evt = this.getData('eventListeners'), type = this.getData('ltPropType');
		if(type == 'date' || type == "datetime" ){
			document.removeEventListener('click', evt.calendar, true);
			window.removeEventListener('scroll', evt.scroll, true);
			window.removeEventListener('resize', evt.scroll, true);
			this.$node.removeEventListener('wheel', evt.timeWheel);
		}
		if(type == 'time' || type == "datetime" ){
			this.$node.removeEventListener('wheel', evt.timeWheel);
		}
		if(evt.hasOwnProperty('mouseup')){
			document.removeEventListener('mouseup', evt.mouseup);
		}	
	},

	calenderClickHide : function(event){
			var calendarComp = this.$node.calendarDiv;
			if(event.target != $L('input', this.$node).e[0] && !calendarComp.contains(event.target))
		    	{
	 				calendarComp.classList.add('lyteCalendarHidden');
	 			}
	},

	scrollFunc : function(event){
		var thisCalendar = this.$node.calendarDiv;
		 $L.fastdom.mutate(function(){
		 	this.setCss();
	 	     $L.fastdom.measure(function(){
	 	     	if(thisCalendar && event && event.type == 'scroll' && !thisCalendar.classList.contains('lyteCalendarHidden')){
					var boundary = this.getData('ltPropBoundary');
					if((boundary.hasOwnProperty('left') ? (input.left < boundary.left) : false) || (boundary.hasOwnProperty('right') ? (input.right > boundary.right) : false)  || (boundary.hasOwnProperty('top') ? (input.top < boundary.top) : false)  || (boundary.hasOwnProperty('bottom') ? (input.bottom > boundary.bottom) : false))		
						{	
							thisCalendar.classList.add('lyteCalendarHidden')
						}
		 	     }
	 	     }.bind(this))	
		 }.bind(this))
	},

	textareaFuncObs : function(){
		if(this.getData('ltPropType') == 'textarea'){
			var resize = this.getData('ltPropTextAreaResize');
			if(!(resize.horizontal || resize.vertical)){
				this.setData('resize', false);
			}else{
				this.setData('resize', true);
				if(!this._resizeBinded){
					this.textareaFunc();
					this._resizeBinded = true;
				}
			}
		}
	}.observes('ltPropTextAreaResize').on('didConnect'),

	textareaFunc : function () {
		var resizeFunc = this.textareaResize.bind(this), mouseup = this.mouseup.bind(this);
		this.setData('eventListeners.resizeFunc', resizeFunc);
		this.setData('eventListeners.mouseup', mouseup);
		if(this.getData('ltPropTextAreaResize')){
			var resizeSpan = $L('.lyteTextareaResize', this.$node).e[0];
			resizeSpan.addEventListener('mousedown', function(evt){
				var textarea=$L('textarea', this.$node).e[0]
				var resize = this.getData('ltPropTextAreaResize') || {};
				evt.preventDefault();
				evt.stopPropagation();
				evt.stopImmediatePropagation();
				document.addEventListener('mousemove', resizeFunc, true);
				document.addEventListener('mouseup', mouseup, true);
				var label = $L('label', this.$node).e[0],parHeight, parWidth, parPaddLeft, minWidth, maxWidth, minHeight, maxHeight, labelRect, thisRect, parentClient, clientRect, compStyle,  direction = this.getData('ltPropDirection');
				$L.fastdom.measure(function(){
					// for textarea manual resizing label width is fixed if it is present
					if(label){
						labelRect = label.getBoundingClientRect();	
					}
					compStyle = window.getComputedStyle(textarea);
					clientRect = textarea.getBoundingClientRect();
					parentClient = window.getComputedStyle(textarea.parentElement);
					thisRect = this.$node.getBoundingClientRect();
					this._resizeDirection = compStyle.resize;
					minWidth = compStyle.minWidth; maxWidth = compStyle.maxWidth;
					minHeight = compStyle.minHeight; maxHeight = compStyle.maxHeight;
					parHeight = parentClient.height; parWidth = parentClient.width;
					parPaddLeft = parentClient.paddingLeft;
				}.bind(this))
				$L.fastdom.mutate(function(){
					if(resize.horizontal){
						// for proper resizing width are calculated in pixels and set to corresponding elements
						this.$node.style.width = thisRect.width + 'px';
						if(label){
							label.style.width = labelRect.width + 'px';
						}
						textarea.style.width = clientRect.width + 'px';
						textarea.parentElement.style.width = 'auto';
						this._iniLeft = clientRect.left;
						this._offLeft = clientRect.right - evt.clientX;
						this._minWidth = (minWidth.indexOf('%') != -1 ? (parseInt(parWidth) * parseInt(minWidth) / 100) : parseFloat(minWidth)) + parseInt(parPaddLeft);
						this._maxWidth = maxWidth.indexOf('%') != -1 ? (parseInt(parWidth) * parseInt(maxWidth) / 100) : parseFloat(maxWidth);
					} 
					if(resize.vertical){
						this.$node.style.height = thisRect.height / (direction == 'vertical' && label ? 2 : 1) + 'px';
						if(label){
							label.style.height = labelRect.height + 'px';
						}
						textarea.style.height = clientRect.height + 'px';
						textarea.parentElement.style.height = "auto";
						this._iniTop = clientRect.top;
						this._offTop = clientRect.bottom - evt.clientY;
						this._minHeight = (minHeight.indexOf('%') != -1 ? (parseInt(parHeight) * parseInt(minHeight) / 100) : parseFloat(minHeight));
						this._maxHeight = maxHeight.indexOf('%') != -1 ? (parseInt(parHeight) * parseInt(maxHeight) / 100) : parseFloat(maxHeight);
					}
				}.bind(this))
			}.bind(this), true);
		}
  	},

  	mouseup : function(event){
		var events = this.getData('eventListeners');
		document.removeEventListener('mousemove', events.resizeFunc, true);
		document.removeEventListener('mouseup',events.mouseup, true);
		delete this._iniLeft; delete this._iniTop; delete this._offLeft; delete this._offTop; 
		delete this._minHeight; delete this._maxHeight; delete this._minWidth; delete this._maxWidth;
	},

	textareaResize:function(event){
		var textarea = $L('textarea', this.$node).e[0];
		$L.fastdom.measure(function(){
			var prevWidth = textarea.getBoundingClientRect();
			if(this._iniLeft){
				var newWid = ((event.clientX > this._iniLeft) ? event.clientX : this._iniLeft) - this._iniLeft + this._offLeft;
				var newOut = parseFloat(this.$node.style.width) + newWid - prevWidth.width;
				if(newWid >= this._minWidth && (isNaN(this._maxWidth) || (!isNaN(this._maxWidth) && newWid <= this._maxWidth))){
					// new calculated width is set to text area and lyte-input
					textarea.style.width = newWid + 'px'; 
					this.$node.style.width = newOut + 'px';
				}
			}
			if(this._iniTop){
				var newHgt = ((event.clientY > this._iniTop) ? event.clientY : this._iniTop) - this._iniTop + this._offTop;
				var newOut = parseFloat(this.$node.style.height) + newHgt - prevWidth.height;
				if(newHgt >= this._minHeight && (isNaN(this._maxHeight) || (!isNaN(this._maxHeight) && newHgt <= this._maxHeight))){
					// new calculated height is set to text area and lyte-input
					textarea.style.height = newHgt + 'px'; 
					this.$node.style.height = newOut + 'px';
				}
			}
		}.bind(this))
	},

  	heightFuncObs : function(){
  		this.heightFunc.call(this, arguments[0]);
  	}.observes('ltPropHeight').on('didConnect'),

  	heightFunc : function (arg){
  		var height = this.getData('ltPropHeight');
  		if(height)
  			{
  				// given height set to input tag
  				$L.fastdom.mutate(function(){
  					var ltPropType = this.getData('ltPropType')
					if(ltPropType != 'textarea')
				  		 {
				  		 	 var input = $L('input', this.$node).e[0];
					  		 var lyteFieldDiv= $L('.lyteField', this.$node).e[0]
						     input.style.height = height;
				   		}
				   	else
				   		{
				   			$L('textarea', this.$node).e[0].style.height = height;
				   		}
  				}.bind(this))
		   	}
	 },

	widthfunObs : function(){
		this.widthfun.call(this);
	}.observes('ltPropWidth').on('didConnect'),

  	widthfun : function (){
  		var width = this.getData('ltPropWidth');
  		if(width){
  			$L.fastdom.mutate(function(){
  				// given width set to input
  				this.$node.style.width = width;
  			}.bind(this))
  		}
  	},

  	appearanceFunObs : function(){
  		this.appearanceFun.call(this);
  	}.observes('ltPropAppearance').on('didConnect'),

  	appearanceFun : function () {
  		var type = this.getData('ltPropType'), lyteField = $L('.lyteField', this.$node).e[0]
  		if(this.getData('ltPropAppearance')=='box')
   			{
   				if(type =='search')
	   				{
	   					lyteField.classList.add('lyteInputBoxSearch');
	   				}
	   			var lyteInput = this.$node
	   			if(lyteInput)	
   					{
   						lyteInput.classList.add('lyteInputBox');
   						lyteInput.classList.remove('lyteInput');
   					}
   			}
   		else
   			{
   				if(type =='search')
	   				{
	   					lyteField.classList.remove('lyteInputBoxSearch');
	   				}
	   			var lyteInputBox = this.$node;	
	   			if(lyteInputBox)
	   				{
	   					lyteInputBox.classList.add('lyteInput');
	   					lyteInputBox.classList.remove('lyteInputBox');
	   				}
   			}		
  	},

  	directionfunObs : function(){
  		this.directionfun.call(this);
  	}.observes('ltPropDirection').on('didConnect'),

  	directionfun : function (){
  		var horizontal = this.$node;
  		if(horizontal)
		  	{
		  		// depending upon the direction classes are added
		  		if(this.getData('ltPropDirection')=='vertical')
		   			{
		   				horizontal.classList.add('vertical');
		   				horizontal.classList.remove('horizontal');
		   			}
		   		else 	
			   		{
			   			horizontal.classList.add('horizontal');
			   			horizontal.classList.remove('vertical');
			   		}
			 }	
	},
	data : function(){
		return {
		    ltPropDisabled :  Lyte.attr("boolean",{"default" : false}),
		    ltPropAutofocus : Lyte.attr("boolean",{"default" : false}),
		    ltPropAutocomplete : Lyte.attr("string",{"default" : 'off'}),
		    ltPropMaxlength : Lyte.attr("number",{"default" : undefined}),
		    ltPropName : Lyte.attr("string",{"default" : ''}),
		    ltPropPlaceholder : Lyte.attr("string",{"default" : ''}),
		    ltPropReadonly : Lyte.attr("boolean",{"default" : false}),
		    ltPropValue : Lyte.attr("string",{"default" : ''}),
		    ltPropWidth : Lyte.attr("string",{"default" : ''}),
		    ltPropTabIndex : Lyte.attr('string',{default : '0'}),
		    ltPropType : Lyte.attr("string",{"default" : ''}),
		    ltPropAppearance : Lyte.attr("string",{"default" : ''}),
		    ltPropDirection : Lyte.attr("string",{"default" : 'vertical'}),
		    ltPropLabel : Lyte.attr("string",{"default" : ''}),
		    ltPropId : Lyte.attr("string",{"default" : ''}),
		    ltPropClass : Lyte.attr("string",{"default" : ''}),
		    ltPropText : Lyte.attr("string",{"default" : ''}),
		    ltPropStyle : Lyte.attr("string",{"default" : ''}),
		    ltPropText : Lyte.attr("string",{"default" : 'upload'}),
		    ltPropWrapperStyle : Lyte.attr('string', {'default' : ''}),
		    ltPropHeight : Lyte.attr("string",{"default" : ''}),
		    ltPropPattern : Lyte.attr('string', { default : '.+'}),
		    ltPropInputTitle : Lyte.attr('string', { default : '' }),
		   	
		    // data for file
		     ltPropAccept : Lyte.attr("string",{"default" : ''}),
		     ltPropMultiple : Lyte.attr("boolean",{"default" : true}),

		    // data for textarea
		    ltPropRows : Lyte.attr("number",{"default" : undefined}),
     	    ltPropCols : Lyte.attr("number",{"default" : undefined}),
     	    ltPropTextAreaResize : Lyte.attr("object",{"default" : {vertical : true, horizontal : true}}),

		    // data for number
		    ltPropMax : Lyte.attr("number",{"default" : undefined}),
		    ltPropMin : Lyte.attr("number",{"default" : undefined}),
		    ltPropStep : Lyte.attr("number",{"default" : 1}),

			// data for time
			ltPropTimeFormat : Lyte.attr("number",{"default" : 12}),
		    ltPropHourInterval : Lyte.attr("number",{"default" : 1}),
		    ltPropDefaultTime : Lyte.attr("string",{"default" : ''}),
		    ltPropMinuteInterval : Lyte.attr("number",{"default" : 30}),
		    ltPropDropdown : Lyte.attr("boolean",{"default" : false}),
		    ltPropShowInterval : Lyte.attr("boolean",{"default" : false}),
		    ltPropStartTime : Lyte.attr("string",{"default" : ''}),
		    ltPropEndTime : Lyte.attr("string",{"default" : ''}),

		    // data for calendar
		    ltPropFillRows : Lyte.attr('boolean', {default : true}),
			ltPropNumberOfRows : Lyte.attr('number', {default : 6}),
			ltPropMinDate : Lyte.attr('string', { default : ""}),
			ltPropMaxDate : Lyte.attr('string', { default : ""}),
			ltPropStartWeekDay : Lyte.attr('number', { default : 1}),
			ltPropMonthHeaderFormat : Lyte.attr("string",{"default":'MMMM YYYY'}),
			daysOfWeek : Lyte.attr("array",{"default":['Sun','Mon','Tue','Wed','Thu','Fri','Sat']}),
			ltPropYear : Lyte.attr("boolean",{"default":true}),
			ltPropFormat : Lyte.attr("string",{"default":"MM/DD/YYYY"}),
			viewDate : Lyte.attr("object",{"default":{}}),
			ltPropStartDate : Lyte.attr("string",{"default" : ''}),
		    ltPropEndDate : Lyte.attr("string",{"default" : ''}),
		    ltPropCurrentDate : Lyte.attr("string",{"default" : ''}),
		    ltPropMonthHeader : Lyte.attr("string",{"default" : ''}),
		    ltPropCalendarClass : Lyte.attr( 'string', { default : "" } ),
		    ltPropHeaderType : Lyte.attr("string",{"default" : "default"}),

			// data for dropdown
			ltPropDropdownDisabled : Lyte.attr('boolean', { default : false}),
			ltPropDropdownShow : Lyte.attr('boolean', { default : false}),
			ltPropDropdownCallout : Lyte.attr('boolean', { default : false}),
			ltPropDropdownFreeze : Lyte.attr('boolean', { default : false}),

			// for dropdown and calendar
			ltPropPosition : Lyte.attr('string', { default : 'down'}),
			ltPropBoundary : Lyte.attr('object', { default : {}}),

			// for date and time
		    ltPropWheel : Lyte.attr('boolean', {default : false}),
			ltPropYield : Lyte.attr('boolean', { default : false}),

			ltPropAutoUpdate : Lyte.attr('boolean', { default : true}),

		    // system data
		    // fileNo : Lyte.attr("number",{"default" : undefined}),
		    eventListeners : Lyte.attr('object', {default : {}}),
		    selectedField : Lyte.attr('object', { default : {}}),
		    endMinute : Lyte.attr('number', { default : ''}),
		    startMinute : Lyte.attr('number', { default : ''}),
		    dropdownData : Lyte.attr('array', { default : []}),
		    originalData : Lyte.attr('array', { default : []}),
		    // ltPropFilelist : Lyte.attr("array",{default : []}),
		    dateRange : Lyte.attr('object', { default : { day : [], month : [], year : []}}),
		    meridian : Lyte.attr('object', { default : {AM : (_lyteUiUtils ? _lyteUiUtils.i18n('AM') : 'AM'), PM : (_lyteUiUtils ? _lyteUiUtils.i18n('PM') : 'PM')}}),
		    hour : Lyte.attr('string', { default : _lyteUiUtils.i18n('hour')}),
		    min : Lyte.attr('string', { default : _lyteUiUtils.i18n('min')}),
		    selectedDateField : Lyte.attr('string', { default : ""}),
		    preventObs : Lyte.attr('boolean', { default : true}),
		    resize : Lyte.attr('boolean', { default : true}),
		    pos : Lyte.attr('string', { default : ""})
		}
	},

	getDateFromFormat:function(tdate,format){
		return this._assCalendar.component.getDateFromFormat(tdate, format);
	},

	dateValidation : function(date){
        var timeObj = new Date(date);
         if(timeObj.toString() == 'Invalid Date'){
        	return false
         }
         return timeObj;
         },

	dateRegexFind : function(arg){
		var format, dateRange = this.getData('dateRange');
		if(!arg){
			format = this.getData('ltPropFormat');
		}else{
			format = arg.newValue;
		}
		var dayReg = /D+/ig.exec(format), monthReg = /M+/ig.exec(format), yearReg = /Y+/ig.exec(format);
		dateRange.day[0] = dayReg.index; dateRange.day[1] = dayReg.index + dayReg[0].length;
		dateRange.month[0] = monthReg.index; dateRange.month[1] = monthReg.index + monthReg[0].length;
		dateRange.year[0] = yearReg.index; dateRange.year[1] = yearReg.index + yearReg[0].length;

	},

	dateRegexObs : function(arg){
		this.dateRegexFind(arg);
	}.observes('ltPropFormat'),

	constructingArr : function(i, startTime, format){
		if(i < startTime){
			i += 1440;
		}
		var interval = (i - startTime) / 60;
		temp = {};
		temp.time = this.convertToRailway(i, true, format);
		temp.interval = interval < 1 ? ((i - startTime) + ' '+ this.getData('min')) : ((interval % 1 == 0 ? interval : interval.toFixed(1)) + ' ' + this.getData('hour'));
		return temp;
	},

	dropdownConstruct : function(){
		if( this._prevent ) {
			return
		}
		var startTime = this.getData('startMinute'), i, temp = [], endTime = this.getData('endMinute'), hrInter = this.getData('ltPropHourInterval'), minInt = this.getData('ltPropMinuteInterval'), format = this.getData('ltPropTimeFormat');
		if(startTime >= endTime){
			endTime += 1440;
		}
		for(i = startTime; i <= endTime; i += minInt){
			 temp.push(this.constructingArr(i, startTime, format))
		}
		this.setData('originalData', temp);
	},

	constructNewDrop : function(input, format){
		var temp = [], startTime = this.getData('startMinute');
		if(format == 12){
			var min = this.convertToRailway(input.value.trim());
			var ret = this.maxValCheck(min);
			if(ret != false){
				temp.push(this.constructingArr(min, startTime, 12));
			}
			min += 720;
			ret = this.maxValCheck(min % 1440);
			if(ret != false){
				temp.push(this.constructingArr(min, startTime, 12));
			}
		}else{
			var min = this.convertToRailway(input.value.trim());
			var ret = this.maxValCheck(min);
			if(ret != false){
				temp.push(this.constructingArr(min, startTime, 24));
			}
		}
		this.setData('dropdownData', temp);
	},

	getCorrectTime : function(timeFormat){
		var time = new Date(), hr = time.getHours(), min = time.getMinutes().toString(), meridian = this.getData('meridian'), mer = hr > 11 ? meridian.PM : meridian.AM;
		if(min.length == 1){
			min = '0' + min;
		}
		if(timeFormat == 12){
			if( hr != 12 ) {
				hr = (hr%12).toString();
				if(hr.length == 1){
					hr = '0' + hr;
				}
			}
			return hr + ':' + min + " " + mer;
		}else{
			if(hr < 10){
				hr = '0' + hr;
			}
			return hr + ":" + min;
		}

	},

	timeFormatChange : function(){
		this.timeInValChange();
	}.observes('ltPropTimeFormat'),

	handleWheel : function(evt){
		var input = event.target, type = this.getData('ltPropType');
		if( input.tagName != 'INPUT' ) {
			return
		}
		if(type == 'time' || ( type == "datetime" && input.id == "time" ) ){
			$L.fastdom.mutate(function(){
				selectedField = this.getData('selectedField');
				if(!selectedField.prop || input.selectionStart > 3){
					// settting initial selection if input is not focused
					input.selectionStart = 0;
		            input.selectionEnd = 2;
					this.setData('selectedField', {prop : 'hour', val : 0});
					selectedField = {prop : 'hour', val : 0};
				}
				if(evt.deltaY < -10){
					this.timeDecrease.call(this, input, {}, selectedField.prop, input.selectionStart, input.selectionEnd)
				}else if(evt.deltaY > 10){
					this.timeIncrease.call(this, input, {}, selectedField.prop, input.selectionStart, input.selectionEnd)
				}
			}.bind(this))
		}else if( type == 'date' || ( type == "datetime" && input.id == "date" ) ){
			if(evt.deltaY < -10){
				evt.keyCode = 40;
				this.calendarKeydown.call(this, evt, input);
			}else if(evt.deltaY > 10){
				evt.keyCode = 38;
				this.calendarKeydown.call(this, evt, input);
			}
		}
		evt.preventDefault();	
	},                                            

	wheelObs : function(arg){
		if(arg.newValue){
		 	this.$node.addEventListener('wheel', this.getData('eventListeners.timeWheel'));
		}else{
			this.$node.removeEventListener('wheel', this.getData('eventListeners.timeWheel'));
		}
	}.observes('ltPropWheel'),

	convertToRailway : function(val, flag, format){
		var meridian = this.getData('meridian');
		if(!flag){
			var hr = parseInt(val.slice(0, 2));
			var min = parseInt(val.slice(3, 5));
			if(val.length != 5){
				var mer = val.slice(6, val.length);
				return (mer == meridian.PM ? ((hr % 12) + 12) : hr) * 60 + min;
			}else{
				return (hr * 60 + min);
			}
		}else{
			var hr = parseInt(val / 60) % 24;

			var min = val % 60;
			if(min < 10){
				min = '0' + min;
			}
			var mer = ''
			if(format == 12){
				if(parseInt(hr / 12) == 1){
					if(hr > 12){
						hr = hr % 12;
					}
					mer = meridian.PM;
				}else{
					mer = meridian.AM;
				}
			}
			if(hr < 10){
				hr = '0' + hr;
			}
			return (hr + ":" + min + " " + mer);
		}
	},

	maxValCheck : function(val){
		var endTime = this.getData('endMinute');
		var startTime = this.getData('startMinute');
		var toChangeTime;
		if(typeof val == 'string'){
			toChangeTime = 	this.convertToRailway(val);
		}else{
			toChangeTime = val
		}
		if(startTime < endTime){
			if(toChangeTime <= endTime && toChangeTime >= startTime){
				return true
			}
		}else{
			if((toChangeTime < 1440 && toChangeTime >= startTime) || (toChangeTime > 0 && toChangeTime <= endTime)){
				return true;
			}
		}
		return false
	},

	timeInValChange : function(arg){
		var timeFormat = this.getData('ltPropTimeFormat'), value;
		if(arg){
			value = arg.newValue;
		}else{
			value = this.getData('ltPropDefaultTime')
		}
		if(!value){
			var startTime =  this.getData('ltPropStartTime');
			if(startTime){
				value = startTime;
			}else{
				value = this.getCorrectTime(timeFormat);
			}
		}
		this.setData('ltPropDefaultTime', value.slice(0, timeFormat != 12 ? 5 : value.length));
	},

	startEndTimeObs : function(arg){
		if(!arg || arg.item == 'ltPropStartTime')
			{
				var defaultVal = this.getData('ltPropDefaultTime');
				var startTime = this.getData('ltPropStartTime')
				if(!startTime){
					this.setData('ltPropStartTime', defaultVal)
					startTime = defaultVal
				}
				this.setData('startMinute', this.convertToRailway(startTime));
			}
		if(!arg || arg.item == 'ltPropEndTime')	
			{
				var  endTime = this.getData('ltPropEndTime')
				if(!endTime){
					var min = Math.max(0, parseInt(startTime.slice(3, 5)) - 1).toString();
					if(min.length == 1){
						min = '0' + min;
					}
					endTime = startTime.slice(0, 3) + min + " " + startTime.slice(6, startTime.length);
					this.setData('ltPropEndTime', endTime)
				}
				this.setData('endMinute',  this.convertToRailway(endTime));
			}
		this.dropdownConstruct()	
	},

	timeBoundObs : function(arg){
		if(arg &&  arg.newValue == "" && arg.oldValue == undefined) {
			return
		}
		if(!arg || (arg && arg.item != 'ltPropDefaultTime')){
			this.startEndTimeObs(arg);
		}else{
			if(this.setData('preventObs')){
				this.setData('ltPropValue', arg.newValue);
			}
			if(this.getMethods('onTimeChange')){
				this.executeMethod('onTimeChange', arg, this.$node);
			}
		}
	}.observes('ltPropStartTime', 'ltPropEndTime', 'ltPropDefaultTime'),

	dateChangeCallback : function(){
		setTimeout(this.dateCallback.bind(this), 0 , arguments[0]);
	}.observes('ltPropCurrentDate'),

	dateCallback : function(arg){
		if( arg.newValue == "" && arg.oldValue == undefined) {
			return
		}
		if(this.getMethods('onDateChange')){
			this.executeMethod('onDateChange', arg, this.$node);
		}
	},

	timeCallback : function(arg){
		if( arg.newValue == "" && arg.oldValue == undefined) {
			return
		}
		if(this.getMethods('onValueChange')){
			this.executeMethod('onValueChange', arg, this.$node)
		}
	},

	valChangeObs : function(arg){
		setTimeout(this.timeCallback.bind(this), 0 , arg);
	}.observes('ltPropValue'),

	firePosCallBack: function() {
		if( this.getMethods( 'onPositionChanged' )) {
			this.executeMethod( 'onPositionChanged', this.getData('pos'), this.$node.calendarDiv);
		}
	}.observes('pos'),

	/*
		Calculate left of dropdown container when it has to come below/above the select element when it exceeds window.innerWidth and there is space to the right
	*/
	setLeftExceedForDown: function( element, container, bcr, containerbcr, xscroll ) {
		var scrolledLeft = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		elementWidth = elementBCR.width,
		containerBCR = containerbcr,
		containerWidth = containerBCR.width,
		total = scrolledLeft + elementLeft + elementWidth - containerWidth;

		return total
	},
	/*
		Calculate left of dropdown container when it has to come below/above the select element when it doesn't exceed window.innerWidth
	*/
	setLeftNotExceedForDown: function( element, bcr, xscroll ) {
		var scrolledLeft = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		total = scrolledLeft + elementLeft;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come above the select element
	*/
	setTopAboveForDown: function( element, container, bcr, containerbcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		containerBCR = containerbcr,
		containerHeight = containerBCR.height,
		total = scrolledHeight + elementTop  - containerHeight;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come below the select element
	*/
	setTopBelowForDown: function( element, bcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		elementHeight = elementBCR.height,
		total = scrolledHeight + elementTop + elementHeight;

		return total
	},
	/*
		Calculate left of dropdown container when it has to come to right of the select element
	*/
	setLeftForRight:function( element, bcr, xscroll ) {
		var scrolledWidth = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		elementWidth = elementBCR.width,
		total = scrolledWidth + elementLeft + elementWidth;

		return total
	},
	/*
		Calculate right of dropdown container when it has to come to left of the select element of right dropdown
	*/
	setRightForRight: function( element, container, bcr, elembcr, xscroll ) {
		var scrolledWidth = xscroll,
		elementBCR = bcr,
		containerBCR = elembcr,
		elementLeft = elementBCR.left,
		containerWidth = containerBCR.width,
		total = scrolledWidth + elementLeft - containerWidth;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come to right of dropdown and there is space below
	*/
	setTopForRight:function( element, bcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		total = scrolledHeight + elementTop;

		return total
	},
	/*
		Calculate top of dropdown container when it has to come to right of dropdown and there is no space below
	*/
	setTopForRightAbove:function( element, container, bcr, elembcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		elementHeight = elementBCR.height,
		containerBCR = elembcr,
		containerHeight = containerBCR.height,
		total = scrolledHeight + elementTop + elementHeight - containerHeight;

		return total
	},
	/**
	 * Set the CSS for your calendar
	 * refer commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 and previous for the previous stable setCSS function.
	 * commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 also gives a better understanding about the hard coded values in this function.
	 */ 
	setCss : function(  ) {
		var link = this.$node.calendarDiv;

		if( !link 
			|| link.classList.contains( 'lyteCalendarHidden' ) 
		) {
			return;
		}

		// Get properties

		// Get button
		var body = link,
		par = $L( 'input', this.$node ).e[ 0 ].parentElement;

		// Get Geometric propotions
		var wwidth, wheight, flag, 
		wwidth = window.innerWidth,
		wheight= window.innerHeight,
		drop = body.getBoundingClientRect(), 
		x = window.pageXOffset || document.documentElement.scrollLeft,
		y = window.pageYOffset || document.documentElement.scrollTop,
		height = body.offsetHeight,
		width = body.offsetWidth, 
		position = this.getData( 'ltPropPosition' ),
		offsets = par.getBoundingClientRect();

		// Intialize flags
		var downPos, 
		rightPos, 
		topPos, 
		leftPos; 

		// temp stores
		var tempStore,
		tempTop, 
		tempLeft, 
		tempMarginLeft, 
		tempMarginTop,
		tempNum, 
		tempDenom, 
		tempPer, 
		aHeight, 
		aWidth;

		if( position === 'down' ) {
			downPos = true;
			tempTop = offsets.top + offsets.height; 
			if( tempTop + height > wheight 
				&& offsets.top > height 
			) {
				downPos = false;		
			}
			else {
				downPos = true;
			}

			rightPos = true;
			tempLeft = offsets.left;
			if( tempLeft + width > wwidth 
				&& tempLeft > tempLeft + offsets.width - body.offsetWidth 
			) {
				rightPos = false;
				
			}
			else if( offsets.left + width <= wwidth ) {
				rightPos = true;
			}

			if( downPos ) {
				this.setData( 'pos', 'down' );
				body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px';
				
			}
			else {
				this.setData( 'pos', 'up' );
				body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y ) + 'px';
			}

			if( rightPos ) {
				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftNotExceedForDown( par, offsets, x ) + 'px';	
			}
			else {
				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftExceedForDown( par, body, offsets, drop, x ) + 'px'
			}

			
		}
		else if( position === 'right' ) {
			rightPos = true;
			if( offsets.left + offsets.width + width > window.innerWidth 
				&& offsets.left - drop.width > 0 
			) {   
				rightPos = false;
				
			}
			else{
				rightPos = true;
			}

			downPos = true;
			if( offsets.top + drop.height > window.innerHeight ) {
				downPos = false
			}
			else {
				downPos = true
			}

			if( rightPos ) {
				this.setData( 'pos', 'right' );
				body.style.left= this.setLeftForRight( par, offsets, x ) + 'px'
			}
			else {
				this.setData( 'pos', 'left' );
				body.style.left = this.setRightForRight( par, body, offsets, drop, x ) + 'px';
			}

			if( downPos ) {
				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRight( par, offsets, y ) + 'px' 
			}
			else {
				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px'
			}
		}
		else if( position === 'up' ) {
			topPos = true
			if( offsets.top - drop.height < 0 
				&& offsets.top + offsets.height + height < wheight 
			) {
				topPos = false
			}
			else {
				topPos = true
			}

			rightPos = true
			if( offsets.left + width > wwidth 
				&& offsets.left > offsets.left + offsets.width - body.offsetWidth 
			) {
				rightPos = false
			}
			else if( offsets.left + width <= wwidth ) {
				rightPos = true
			}

			if( topPos ) {
				this.setData( 'pos', 'up' );
				body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y ) + 'px';
			}
			else {
				this.setData( 'pos', 'down' );
				body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px'
			}
			if( rightPos ) {
				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftNotExceedForDown( par, offsets, x ) + 'px';
			}
			else{
				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftExceedForDown( par, body, offsets, drop, x ) + 'px';
			}
		} else if( position === 'left' ) {
			leftPos = true;
			if( offsets.left - drop.width < 0 
				&& offsets.left + drop.width < wwidth 
			) {
				leftPos = false;
			}
			else {
				leftPos = true;
			}

			downPos = true;
			if( offsets.top + drop.height > window.innerHeight ) {
				downPos = false;
			}
			else {
				downPos = true;
			}

			if( leftPos ) {
				this.setData( 'pos', 'left' );
				body.style.left = this.setRightForRight( par, body, offsets, drop, x ) + 'px';
			}
			else {
				this.setData( 'pos', 'right' );
				body.style.left = this.setLeftForRight( par, offsets, x ) + 'px';
			}
			if( downPos ){
				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRight( par, offsets, y ) + 'px';
			}
			else{
				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px';
			}
		} else if( position === 'downLeft' ) {
			downPos = true;
			tempTop = offsets.top + offsets.height;
			if( tempTop + height > wheight && offsets.top > height ) {
				tempTop = offsets.top - height;
				downPos = false
			} else {
				downPos = true;
			}
			rightPos = false
			tempLeft = offsets.left + offsets.width / 2 - width;
			if( tempLeft < 0 ) {
				tempLeft = 0
				rightPos = true
			} else { 
				rightPos  = false
			}

			body.style.top = tempTop + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( downPos ){
				pos = 'downLeft';
			} else {
				pos = 'upLeft';
			}
			this.setData( 'pos', pos);

		} else if( position === 'downRight' ) {
			downPos = true;
			tempTop = offsets.top + offsets.height;
			if( tempTop + height > wheight && offsets.top > height ) {
				tempTop = offsets.top - height;
				downPos = false
			} else {
				downPos = true;
			}
			rightPos = true
			tempLeft = offsets.left + offsets.width / 2;
			if( tempLeft + width > wwidth ) {
				tempLeft = wwidth - width;
				rightPos = false;
			} else { 
				rightPos  = true;
			}

			body.style.top = tempTop + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( downPos ){
				pos = 'downLeft';
			} else {
				pos = 'upLeft';
			}
			this.setData( 'pos', pos);
		} else if( position === 'upLeft' ) {
			downPos = false;
			tempTop = offsets.top - height;
			if( tempTop < 0) {
				tempTop = offsets.top + offsets.height;
				downPos = true
			} else {
				downPos = false;
			}
			rightPos = false
			tempLeft = offsets.left + offsets.width / 2 - width;
			if( tempLeft < 0 ) {
				tempLeft = 0
				rightPos = true
			} else { 
				rightPos  = false
			}

			body.style.top = tempTop + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( downPos ){
				pos = 'downLeft';
			} else {
				pos = 'upLeft';
			}
			this.setData( 'pos', pos);

		} else if( position === 'upRight' ) {
			downPos = false;
			tempTop = offsets.top - height;
			if( tempTop < 0) {
				tempTop = offsets.top + offsets.height;
				downPos = true
			} else {
				downPos = false;
			}
			rightPos = true
			tempLeft = offsets.left + offsets.width / 2;
			if( tempLeft + width > wwidth ) {
				tempLeft = wwidth - width;
				rightPos = false;
			} else { 
				rightPos  = true;
			}

			body.style.top = tempTop + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( downPos ){
				pos = 'downLeft';
			} else {
				pos = 'upLeft';
			}
			this.setData( 'pos', pos);
		}
			
	},

	methods: {
		"on-dateselected":function(){
               this.$node.calendarDiv.classList.add('lyteCalendarHidden');
               if( this.getMethods( 'onCalendarClose' ) ) {
 	     			this.executeMethod( 'onCalendarClose', this.$node.calendarDiv, this.$node )
 	     		}
         },
         hide : function(){
         	if(this.getMethods('onHide')){
         		this.executeMethod('onHide', arguments[0], arguments[1], this.$node);
         	}
         },
         beforeHide : function(){
         	if(this.getMethods('onBeforeHide')){
         		return this.executeMethod('onBeforeHide', arguments[0], arguments[1], this.$node);
         	}
         },
         show : function(){
         	if(this.getMethods('onShow')){
         		this.executeMethod('onShow', arguments[0], arguments[1], this.$node);
         	}
         },
         beforeShow : function(){
         	if(this.getMethods('onBeforeShow')){
         		return this.executeMethod('onBeforeShow', arguments[0], arguments[1], this.$node);
         	}
         },
         optionSelected : function(){
         	this.setData('ltPropDefaultTime', arguments[1].trim());
         },

         scroll : function(){
         	if(this.getMethods('onScroll')){
         		this.executeMethod('onScroll', arguments[0], arguments[1]);
         	}
         },

         positionChange : function(){
         	if(this.getMethods('onPositionChanged')){
         		this.executeMethod('onPositionChanged', arguments[0], arguments[1]);
         	}
         }
	},
   valUpdate : function(){
   		if( !this.$node || !this) {
   			return;
   		}
		delete this._timeout;
		var type = this.getData('ltPropType');
 		if( type == 'date' || type == "datetime" ){
 			var inn = $L('input',this.$node).e[0].value;
 			this.setData('ltPropCurrentDate', inn ? inn : "");
 		}else if(type == "textarea"){
 			var inn = $L('textarea',this.$node).e[0].value;
 			this.setData('ltPropValue', inn ? inn : "");
 		}else{
 			var inn = $L('input',this.$node).e[0].value;
 			this.setData('ltPropValue', inn ? inn : "");
 		}  
   },
   fixSelection : function(val, selectedField, input){
   	// changing selection range
   			input.selectionStart = selectedField.val + val;
			input.selectionEnd = input.selectionStart + 2;
			this.timeClick.call(this, {}, input);
   },
   replaceVal : function(input, val, start, end){
   		var value;
   		if(typeof input == 'string'){
   			value = input
   		}else{
   			value = input.value
   		}
   		var regex = new RegExp('('+ value.slice(start, start + end) +')','i');
		 return value.trim().replace(regex, val);	
   },

   retVal : function( val1, val2, limit ) {
   	 if( parseInt( val1 + val2 ) > limit ) {
   	 	return '0' + val2
   	 }
   	 return val1 + val2;
   },

   convertToPm :function( limit, val, meridian ){
   		if( limit == 12 ) {
   			var mer = val.slice( 6, val.length ), time = val.slice( 0, 5 ), hr = val.slice( 0, 2 ), min = val.slice( 3, 5 )
   			if( hr == '00' && mer == 'AM' || hr == '12' && mer == 'PM' ) {
   				return val
   			}
   			return hr + ':' + min + " " + ( meridian.AM == mer ? meridian.PM : meridian.AM )
   		}
   		return val
   },

   hourTimeSet : function(input, evt, selection, start, end){
   		 var inputVal = input.value.trim(), limit, meridian = this.getData('meridian');
   		 var typedValue  = evt.keyCode - 48;
   		 var newVal = inputVal.slice(start + 1, end) + typedValue;
   		 var timeFormat = this.getData('ltPropTimeFormat');
   		 if(selection == 'hour'){
   		 	limit = timeFormat == 12 ? 12 : 24;
   		 }else{
   		 	limit = 60
   		 }
	 	if(parseInt(newVal) > limit){
	 		newVal = '0' + typedValue;
	 		if((limit == 12 && newVal == '00' && inputVal.slice(6, 8) == meridian.PM)){
	 			inputVal = this.replaceVal.call(this, input, meridian.AM, 6, meridian.AM.length);
	 		}else if(limit == 60 && newVal == '60'){
	 			newVal = '00';
	 		}
	 	}else{
	 		if((limit == 12 && newVal == '12' && inputVal.slice(6, 8) == meridian.AM)){
	 		    inputVal = this.replaceVal.call(this, input, meridian.PM, 6, meridian.AM.length);
	 		} else if((limit == 12 && newVal == '00' && inputVal.slice(6, 8) == meridian.PM)){
	 		    inputVal = this.replaceVal.call(this, input, meridian.AM, 6, meridian.PM.length);
	 		}
	 	}
	 	var final = inputVal.slice(0, start) + newVal + inputVal.slice(end, inputVal.length);
   		var returnV1 = this.maxValCheck(final);
	 	if(returnV1 == false ){
	 		final = inputVal.slice(0, start) + this.retVal( inputVal.slice(start, start + 1), typedValue, limit ) + inputVal.slice(end, inputVal.length);
	 		returnV1 = this.maxValCheck(final);
	 		if(returnV1 == false){
	 			final = inputVal.slice(0, start) + '0' + typedValue + inputVal.slice(end, inputVal.length);
	 			returnV1 = this.maxValCheck(final);
	 			if(returnV1 == false){
	 				final = this.convertToPm( limit, final, meridian)
	 				returnV1 = this.maxValCheck(final);
	 				if(returnV1 == false){
	 					return false;
	 				}
	 			}
	 		}
	 	}
	 	this.setData('ltPropDefaultTime', final);
	 	// restore current selection
	 	$L.fastdom.mutate(function(){
	 		input.selectionStart = start;
			input.selectionEnd = end;
	 	})
   },
   timeIncrease : function(input, evt, selection, start, end, flag){
   		 var inputVal = input.value.trim(), limit, currentValue = parseInt(inputVal.slice(start, end)), interval, timeFormat = this.getData('ltPropTimeFormat'), final, meridian = this.getData('meridian');
   		 if(selection == 'hour'){
   		 	limit = timeFormat == 12 ? 12 : 24;
   		 	if(flag){
   		 		interval = 1;
   		 	}else{
   		 		interval =  this.getData('ltPropHourInterval');
   		 	}
   		 }else{
   		 	limit = 60;
   		 	interval =  this.getData('ltPropMinuteInterval');
   		 }
   		 var newVal = (currentValue + interval) % limit;
   		 if(limit == 12 && newVal < currentValue && inputVal.slice(6, inputVal.length) == meridian.AM){
   		 	if(newVal == 0){
   		 		newVal = '12';
   		 	}
	 	   inputVal = this.replaceVal.call(this, input, meridian.PM, 6, inputVal.length);
	 	 }else if(limit == 12 && newVal < currentValue && inputVal.slice(6, inputVal.length) == meridian.PM){
	 	 	if(currentValue != 12 || newVal == 0){
	 		 	inputVal = this.replaceVal.call(this, input, meridian.AM, 6, inputVal.length);
	 	 	}
	 	 }else if(limit == 12 && newVal == currentValue && inputVal.slice(6, inputVal.length) == meridian.AM){
	 	 		newVal = '12';
	 	 		inputVal = this.replaceVal.call(this, input, meridian.PM, 6, inputVal.length);
	 	 }else if(limit == 60 && newVal <= currentValue) {
	 	 	 var ret = this.timeIncrease.call(this, input, evt, 'hour', 0, 2, true);
	 	 	 if(ret == false){
	 	 	 	return false;
	 	 	 }
	 	 	 inputVal = input.value.trim();
	 	 }
 	 	newVal = newVal.toString();
 	 	if(newVal.length == 1){
 	 		newVal = '0' + newVal;
 	 	}
	 	final = inputVal.slice(0, start) + newVal + inputVal.slice(end, inputVal.length);
	 	var returnV = this.maxValCheck(final)
	 	if(returnV == false){
	 		return false
	 	}
	 	this.setData('ltPropDefaultTime', final);
	 	// restore current selection
	 	$L.fastdom.mutate(function(){
	 		input.selectionStart = start;
			input.selectionEnd = end;
	 	})
   },
    timeDecrease : function(input, evt, selection, start, end, flag){
   		 var inputVal = input.value.trim(), limit, currentValue = parseInt(inputVal.slice(start, end)), interval, timeFormat = this.getData('ltPropTimeFormat'), final, meridian = this.getData('meridian');
   		 if(selection == 'hour'){
   		 	limit = timeFormat == 12 ? 12 : 24;
   		 	if(flag){
   		 		interval = 1;
   		 	}else{
   		 		interval =  this.getData('ltPropHourInterval');
   		 	}
   		 }else{
   		 	limit = 60;
   		 	interval =  this.getData('ltPropMinuteInterval');
   		 }
   		 var newVal = (currentValue - interval + limit) % limit;
   		 if(limit == 12 && newVal > currentValue && inputVal.slice(6, inputVal.length) == meridian.AM){
	 		 inputVal = this.replaceVal.call(this, input, meridian.PM, 6, inputVal.length);
	 	 } else if(limit == 12 && (newVal > currentValue || currentValue == 12) && inputVal.slice(6, inputVal.length) == meridian.PM){
	 	 	inputVal = this.replaceVal.call(this, input, meridian.AM, 6, inputVal.length);
	 	 }else if(limit == 12 && newVal == 0){
	 	 	if(inputVal.slice(6, inputVal.length) == meridian.PM){
	 	 		newVal = '12';
	 	 	}
	 	 }else if(limit == 60 && newVal >= currentValue) {
	 	 	var ret = this.timeDecrease.call(this, input, evt, 'hour', 0, 2, true);
	 	 	if(ret == false){
	 	 		return false;
	 	 	}
	 	 	inputVal = input.value.trim()
	 	 }
 	 	newVal = newVal.toString();
 	 	if(newVal.length == 1){
 	 		newVal = '0' + newVal;
 	 	}
	 	final = inputVal.slice(0, start) + newVal + inputVal.slice(end, inputVal.length);
	 	var returnV = this.maxValCheck(final);
	 	if(returnV == false){
	 		return false
	 	}
	 	this.setData('ltPropDefaultTime', final);
	 	// restore current selection
	 	$L.fastdom.mutate(function(){
	 		input.selectionStart = start;
			input.selectionEnd = end;
	 	})
   },

   findCalendarRange : function(evt, input){
   		var flag = false;
   		if(input.value && this.dateValidation(input.value) != false){
         		var start = input.selectionStart, i;
         		var end = input.selectionEnd;
         		var range = this.getData('dateRange');
         		for(i in range){
         			// checking selected pos
         			if(range[i][0] <= start && range[i][1] >= start){
         				input.selectionStart = range[i][0];
         				input.selectionEnd = range[i][1];
         				this.setData('selectedDateField', i);
         				flag = true;
         				break;
         			}
         		}
         	}
         return flag;	
   },

   hideCalendar : function(){
			var inputs = $L('lyte-input').e;
			for(var i = 0; i < inputs.length; i++){
				if(inputs[i] != this.$node && inputs[i].calendarDiv && !inputs[i].calendarDiv.classList.contains('lyteCalendarHidden')){
					// hides calendar
					inputs[i].calendarDiv.classList.add('lyteCalendarHidden')
	 	     		if( inputs[i].component.getMethods( 'onCalendarClose' ) ) {
	 	     			inputs[i].component.executeMethod( 'onCalendarClose', inputs[ i ].calendarDiv, inputs[ i ] )
	 	     		}
				}
			}
   },

   showCalendar : function(event, input){
   	 this.hideCalendar();
   	 // removing hidden class
	 this.$node.calendarDiv.classList.remove('lyteCalendarHidden')
	 this.scrollFunc.call(this)
	 // initial selection
	 $L.fastdom.mutate(function(){
	 	 input.selectionStart = 0;
	     input.selectionEnd = 0;
		 this.findCalendarRange(event, input);
		 // $L.fastdom.mutate(function(){
		 	// $L.fastdom.mutate(function(){
				 if(this.getMethods('onCalendarOpen')){
				 	this.executeMethod('onCalendarOpen', this.$node.calendarDiv, this.$node);
				 }
			// }.bind(this)) 
		// }.bind(this))	 
	 }.bind(this))
   },

   calendarMousedown : function(event){
   		if( this.$node.calendarDiv.contains( event.target ) ) {
   			this.preventFocus = true
   		}
   },

   timeClick : function( evt, input ){
   		var start;
	 	// measuring clicked position
	 		start = parseInt(input.selectionStart / 3);
	 	// measuring selection
	 		switch(start){
	     		case 2 : {
	     			input.selectionStart = 6;
	     			input.selectionEnd = input.value.length;
	     			this.setData('selectedField', {prop : 'meridian', val : 6});
	     		}
	     		break;
	     		case 1 : {
	     			input.selectionStart = 3;
	     			input.selectionEnd = 5;
	     			this.setData('selectedField', {prop : 'minute', val : 3});
	     		}
	     		break;
	     		default : {
	     			input.selectionStart = 0;
	     			input.selectionEnd = 2;
	     			this.setData('selectedField', {prop : 'hour', val : 0});
	     		}
	      	}
	  if(this.dropbox && this.dropbox.classList.contains('lyteDropdownHidden') && evt.type == "click"){
	  		this.setData('dropdownData', this.getData('originalData'));
	 		this.dropdown.toggle();
	 	}
   },

   calendarKeydown : function( evt, input ){
   		var keyCode = evt.keyCode;
     	var time = this.dateValidation(input.value);
         	if(time != false){
         		var selected = this.getData('selectedDateField');	             		
             	if([37, 38, 39, 40, 9].indexOf(keyCode) != -1){
             			if(input.selectionEnd == input.selectionStart){
	             			this.findCalendarRange(evt, input);
	             		}
	             		var start = input.selectionStart;
	             		var end = input.selectionEnd;
	             		if([38, 40].indexOf(keyCode) != -1){
	             		   evt.preventDefault();
	             		switch(selected){
	             			case 'year' : {
	             				if(keyCode == 40){
	             					time.setFullYear(time.getFullYear() - 1);
	             				}else{
	             					time.setFullYear(time.getFullYear() + 1);
	             				}	
	             			}
	             			break;
	             			case 'month' : {
	             				if(keyCode == 40){
	             					time.setMonth(time.getMonth()  - 1);
	             				}else{
	             					time.setMonth(time.getMonth() + 1);
	             				}
	             			}
	             			break;
	             			default : {
	             				if(keyCode == 40){
	             					time.setDate(time.getDate() - 1);
	             				}else{
	             					time.setDate(time.getDate() + 1);
	             				}
	             			}
	             		}
	             		this.setData('ltPropCurrentDate', this.getDateFromFormat(time, this.getData('ltPropFormat')));
	             	}else{
	             		if((input.selectionEnd == input.value.length && (keyCode == 39 || (!evt.shiftKey && keyCode == 9))) || (input.selectionStart == 0 && (keyCode == 37 || (evt.shiftKey && keyCode == 9)))){
	             			return
	             		}else{
	             			daterange = this.getData('dateRange');
	             			if(keyCode == 39 || (!evt.shiftKey && keyCode == 9)){
	             				input.selectionStart = input.selectionEnd = daterange[selected][1] + 1;
	             			}else if(keyCode == 37 || (evt.shiftKey && keyCode == 9)){
	             				input.selectionStart = input.selectionEnd = daterange[selected][0] - 1;
	             			}
	             			this.findCalendarRange(evt, input);
	             			start = input.selectionStart;
	             			end = input.selectionEnd;
	             			evt.preventDefault();
	             		}
	             	}
	             	// restore current selection
	             	$L.fastdom.mutate(function(){
				 		input.selectionStart = start;
						input.selectionEnd = end;
				 	})
            	 }
             }
   },

	actions: {
			 wormholeDidConnect : function(){
			 	this.$node.calendarComp = $L('lyte-wormhole',this.$node).e[0];
			 	LyteComponent.appendChild(document.body,this.$node.calendarComp);
			 	this.$node.calendarComp.nodeN=this.$node;
			 	this.$node.calendarDiv = $L('div#lyteCalendar', this.$node.calendarComp).e[0];
			 	this._assCalendar = $L('lyte-calendar',this.$node.calendarDiv).e[0];
			 	var func1 = this.calendarMousedown.bind(this);
			 	this.$node.calendarDiv.addEventListener('mousedown', func1, true);
		    	this.setData('eventListeners.mousedown', func1);
			 },

			 focusClass : function(){
			 	this.$node.classList.add( 'lyteInputFocus' )
			 },

			 calFocusout : function(){
			 	if(!this.preventFocus){
			 		if( this.$node.calendarDiv.classList.contains('lyteCalendarHidden') ) {
			 			return
			 		}
	 	     		this.$node.calendarDiv.classList.add('lyteCalendarHidden')
	 	     		setTimeout( function(){
	 	     			if( this.getMethods( 'onCalendarClose' ) ) {
		 	     			this.executeMethod( 'onCalendarClose', this.$node.calendarDiv, this.$node )
		 	     		}
	 	     		}.bind( this ), 0  )
			 	}else {
			 		delete this.preventFocus;
			 	}
			 },

	 	     "blurThrow":function(event, flag){
	 	     	this.$node.classList.remove( 'lyteInputFocus' )
	 	     	if( !flag ) {
	 	     		var type = this.getData( 'ltPropType' )
	 	     		if( type == 'text' || type == "" ) {
	 	     			this.valUpdate()
	 	     		} else {
	 	     			setTimeout( this.valUpdate.bind( this ), 0 );
	 	     		}
	 	     	}
	 	     	if( this.getMethods( 'onBlur' ) ) {
	 	     		setTimeout( function(){
	 	     			this.executeMethod( 'onBlur', event, this.$node )
	 	     		}.bind( this ), 0)
	 	     	}
	 	     },
	 	     "keyup":function(event){
	 	     	if(this.getData('ltPropAutoUpdate')){
	 	     			if(event.keyCode != 9){
			 	     			clearTimeout(this._timeout);
			 	     			this._timeout = setTimeout(this.valUpdate.bind(this), 250);
					 	    }
					}
	 	     },
	 	     "showcalendar":function(event, input){
	 	     	this.$node.classList.add( 'lyteInputFocus' )
	 	     	this.showCalendar(event, input);
	 	     },
	 	    
            // "reset":function(){
            //  	$L('input',this.$node).e[0].value="";
            //  },
             // "fileChange":function(event){
             // 	fileList=$L('input', this.$node).e[0].files;
             // 	var i;
             // 	ErrorMsg=$L('span#preview', this.$node).e[0];
             // 	div=$L('div#lytePreview', this.$node).e[0];
             // 	if(fileList.length)
	            //  	{
	            //  	   if(ErrorMsg)
	            //  	   	{
	            //  	  		ErrorMsg.style.display="none";
	            //  	  		$L('.lyteFileUploadContainer', this.$node).e[0].style.display="block";
	            //  	  	}
	            //  	  var temp=[];
	            //  	  for(i=0;i<fileList.length;i++)
	            //  	  	{
	            //  	  		temp.push(fileList[i]);
	            //  	  	}
	            //  	  this.setData('ltPropFilelist',temp)
	            //  	  // this.setData('fileNo',temp.length)
	            //     }
             // },

             calendarClick : function(evt, input){
             	this.findCalendarRange(evt, input);
             },

             calendarKeydown : function(){
             	this.calendarKeydown.apply(this, arguments)
             },

             timeBlur : function(evt, input){
             	this.$node.classList.remove( 'lyteInputFocus' )
             	this.setData('selectedField', {});
             },

             timeFocus : function(evt, input){
             	this.$node.classList.add( 'lyteInputFocus' )
             	var value = input.value.trim();
             	this.setData('selectedField', {prop : 'hour', val : 0});
             	input.selectionStart = 0;
             	this.fixSelection.call(this, 0, {prop : 'hour', val : 0}, input);
             },

             timeKeydown : function(evt, input){
             	var selectedField = this.getData('selectedField'), meridian = this.getData('meridian'), timeFormat = this.getData('ltPropTimeFormat'), flag = true, oriDrop = this.getData('originalData'), rendered = this.getData('dropdownData');
             	if(selectedField.prop)
	             	{
	             		var start = input.selectionStart, end = input.selectionEnd;
	             		if(start == end){
	             			this.timeClick.call(this, {}, input);
	             			start = input.selectionStart, end = input.selectionEnd;
	             			selectedField = this.getData('selectedField');
	             		}
		         		var keyCode = evt.keyCode
		         		if(keyCode != 9){
		         			evt.preventDefault();
		         		}
		         		if([9, 37, 39].indexOf(keyCode) != -1){
		             		if((evt.shiftKey || keyCode == 37) && selectedField.prop != 'hour' && keyCode != 39){
		             			this.fixSelection.call(this, -3, selectedField, input);
		             			evt.preventDefault();
		             		}
		             		else if((((!evt.shiftKey || keyCode == 39) && selectedField.prop != 'minute' && timeFormat == 24) || (!evt.shiftKey && selectedField.prop != 'meridian' && timeFormat == 12)) && keyCode != 37){
		             			this.fixSelection.call(this, 3, selectedField, input);
		             			evt.preventDefault();
		             		} else{
		             		}
		             		flag = false;

		             	}else if(keyCode >=48 && keyCode <= 57 && selectedField.prop != 'meridian'){
		             		if(selectedField.prop == 'hour'){
		             			this.hourTimeSet.call(this, input, evt, "hour", start, end);
		             		}else if(selectedField.prop == 'minute'){
		             			this.hourTimeSet.call(this, input, evt, 'minute', start, end);
		             		}
		             		this.constructNewDrop(input, timeFormat);
		             	}else if((keyCode == 38 || keyCode == 40) && selectedField.prop != 'meridian'){
		             		if(keyCode == 38){
		             			this.timeIncrease.call(this, input, evt, selectedField.prop, start, end);
		             		}
		             		else{
		             			this.timeDecrease.call(this, input, evt, selectedField.prop, start, end);
		             		}
		             	}else if(selectedField.prop == 'meridian'){
		             		var val = input.value.trim().slice(6,input.value.length), final, key = String.fromCharCode(keyCode).toUpperCase();
		             		if(meridian.PM.toUpperCase().indexOf(key) == 0){
		             			val = meridian.PM;
		             		}else if(meridian.AM.toUpperCase().indexOf(key) == 0){
		             			val = meridian.AM;
		             		}
		             		else if([38, 40].indexOf(keyCode) != -1){
		             			if(val == meridian.PM){
		             				val = meridian.AM
		             			}else{
		             				val = meridian.PM
		             			}
		             		}
		             		if(val == meridian.AM){
		             			if(input.value.trim().slice(0, 2) == '12'){
		             				final = this.replaceVal.call(this, input, '00', 0, 2);
		             			}
		             		}else{
		             			if(input.value.trim().slice(0, 2) == '00'){
		             				final = this.replaceVal.call(this, input, '12', 0, 2);
		             			}
		             		}
		             		if(val){
		             			final = this.replaceVal.call(this, final ? final : input, val, start, end);
		             		}
		             		var returnV = this.maxValCheck(final);
						 	if(returnV == false){
						 		return false;
						 	}
						 	this.setData('ltPropDefaultTime', final);
		             	}
		             	this.fixSelection.call(this, 0, this.getData('selectedField'), input);
		             if(flag)
		             	{
		             		$L.fastdom.mutate(function(){
		             			// restore current selection
						 		input.selectionStart = start;
								input.selectionEnd = end;
						 	})
		             	}
		             if(oriDrop.length != rendered.length && (keyCode < 48 || keyCode > 57)){
		             	this.setData('dropdownData', oriDrop);
		             }	
		          } 
             },

             timeClick : function(){
             	this.timeClick.apply(this, arguments)
             }
     }
});

Lyte.Component.register("lyte-menu",{
_template:"<template tag-name=\"lyte-menu\">\t<lyte-menu-box class=\"{{ltPropWrapperClass}}\" onmousemove=\"{{action( 'mousemove', event, this )}}\">\t<template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\">\t\t\t<lyte-menu-body id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\" tabindex=\"1\">\t\t\t\t<template is=\"for\" items=\"{{ltPropContent}}\" item=\"menu\" index=\"indexVal\"><template is=\"if\" value=\"{{lyteUiOptGroupCheck(menu)}}\"><template case=\"true\">\t\t\t\t\t\t\t        <lyte-menu-group elemorder=\"{{indexVal}}\">\t\t\t\t\t\t\t           <lyte-menu-header>\t\t\t\t\t\t\t           \t  <template is=\"if\" value=\"{{lyteUiReturnOnlyKey(menu)}}\"><template case=\"true\">\t\t\t\t\t\t\t           \t\t\t<b>{{lyteUiReturnOnlyKey(menu)}}</b>\t\t\t\t\t\t\t           \t  </template></template>\t\t\t\t\t\t\t           </lyte-menu-header>\t\t\t\t\t\t\t              <template is=\"for\" items=\"{{lyteUiReturnOnlyValue(menu)}}\" item=\"menu1\" index=\"indexVal1\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(menu1),'==',false)}}\"><template case=\"true\">\t\t\t\t\t\t                                   <lyte-menu-item grporder=\"{{indexVal}}\" elemorder=\"{{indexVal1}}\" data-value=\"{{menu1}}\">\t\t\t\t\t\t                                          <lyte-menu-label>{{menu1}}</lyte-menu-label>\t\t\t\t\t\t                                    </lyte-menu-item>\t\t\t\t\t\t\t                          </template><template case=\"false\">\t\t\t\t\t                                      <lyte-menu-item grporder=\"{{indexVal}}\" elemorder=\"{{indexVal1}}\" id=\"{{menu1.id}}\" class=\"{{menu1.class}}\" data-value=\"{{menu1[ltPropSystemValue]}}\">\t\t\t\t\t                                          <lyte-menu-label>{{menu1[ltPropUserValue]}}</lyte-menu-label>\t\t\t\t\t                                              <template is=\"if\" value=\"{{menu1[ltPropDescription]}}\"><template case=\"true\">\t\t\t\t\t                                                  <lyte-menu-description> {{menu1[ltPropDescription]}}</lyte-menu-description>\t\t\t\t\t                                              </template></template>\t\t\t\t\t                                      </lyte-menu-item>\t\t\t\t\t                                </template></template></template>\t\t\t\t\t\t\t      </lyte-menu-group>\t\t\t\t\t      </template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(menu),'==',false)}}\"><template case=\"true\">\t\t\t                         <lyte-menu-item elemorder=\"{{indexVal}}\" data-value=\"{{menu}}\">\t\t\t                                <lyte-menu-label>{{menu}}</lyte-menu-label>\t\t\t                          </lyte-menu-item>\t\t\t\t                  </template><template case=\"false\">\t\t\t\t                        <lyte-menu-item elemorder=\"{{indexVal}}\" id=\"{{menu.id}}\" class=\"{{menu.class}}\" data-value=\"{{menu[ltPropSystemValue]}}\">\t\t\t\t                            <lyte-menu-label>{{menu[ltPropUserValue]}}</lyte-menu-label>\t\t\t\t                                <template is=\"if\" value=\"{{menu[ltPropDescription]}}\"><template case=\"true\">\t\t\t\t                                    <lyte-menu-description> {{menu[ltPropDescription]}}</lyte-menu-description>\t\t\t\t                                </template></template>\t\t\t\t                        </lyte-menu-item>\t\t\t\t                  </template></template></template></template></template>\t\t    </lyte-menu-body>\t      </template><template case=\"false\">\t   \t\t\t<lyte-yield yield-name=\"yield\"></lyte-yield>\t   \t   </template></template>\t   </lyte-menu-box>\t   \t    </template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,0]}]}},"default":{}},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"for","position":[1,3],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,0]},{"type":"componentDynamic","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}],
_observedAttributes :["ltPropContent","ltPropId","ltPropClass","ltPropQuery","ltPropEvent","ltPropYield","ltPropUserValue","ltPropSystemValue","ltPropCallout","ltPropPosition","ltPropDescription","ltPropTabIndex","ltPropFreeze","ltPropShow","ltPropWidth","ltPropHeight","ltPropQueryClass","ltPropBoundary","ltPropScope","ltPropPreventInsideClick","ltPropAnimate","ltPropSetCss","ltPropWrapperClass","eventListeners","pos","parIndex"],
init : function(){
	var event = this.getData('ltPropEvent');
	var evt = this.checkElementForMenu.bind(this);
	this.setData('eventListeners.event', evt);
	this._close = this.closing.bind( this )
	document.addEventListener(event == 'mouseenter' ? 'mousemove' : event, evt, true);
	this.menuNodes = [];
	if(!document.querySelector('.lytemenufreezelayer') && this.$node.ltProp('freeze')){
			this.appendFreeze.call(this, 'lytemenufreezelayer left lyteMenuHidden')
			this.appendFreeze.call(this, 'lytemenufreezelayer top lyteMenuHidden')
			this.appendFreeze.call(this, 'lytemenufreezelayer bottom lyteMenuHidden')
			this.appendFreeze.call(this, 'lytemenufreezelayer right lyteMenuHidden')
			this.appendFreeze.call(this, 'lytemenufreezelayer nogroup lyteMenuHidden')
			$L('div.nogroup.lytemenufreezelayer').e[0].addEventListener('wheel', this.preventEvent);
		}
	if(!document.hasOwnProperty('_lyteMenu')){
		document.documentElement.addEventListener('click', lyteCloseMenu, true);
		document.documentElement.addEventListener('keydown', this.keydownCheck, true);
		window.addEventListener('resize', this.resizeFunc, true);
		document._lyteMenu = {};
		document._lyteMenu.eventFlag = true;
	}
	if(this.getMethods('beforeRender'))
        {
            this.executeMethod('beforeRender', this.$node);
        }		
},

actions : {
	mousemove : function( evt, _this ) {
		var node = evt.target
		while( node.tagName != "BODY" ) {
			if( node.tagName == 'LYTE-MENU-ITEM' ) {
				break
			}
			node = node.parentElement;
		}
		if( node.tagName == 'LYTE-MENU-ITEM' ) { 
			var prev = $L( '.lyteMenuSelection', _this ).e[ 0 ];
			if( prev == node ) {
				return
			} else if( prev ) {
				prev.classList.remove( 'lyteMenuSelection' )
				node.classList.add( 'lyteMenuSelection' )
			} else if( !prev ) {
				node.classList.add( 'lyteMenuSelection' )
			}
		}
	}
},
 
 arrayFrom : function(nodeList){
 	var arrayList = [];
	for(var i = 0; i < nodeList.length; i++)
		{
			arrayList.push(nodeList[i]);
		}
 	return arrayList.slice();		
 },

heightObs : function(){
	this.menuBody.style.height = this.getData('ltPropHeight');
}.observes( 'ltPropHeight' ).on( 'didConnect' ),

appendFreeze : function(className){
	var freezeLayer ;
	freezeLayer = document.createElement('div')
	freezeLayer.setAttribute('class', className)
	document.body.appendChild(freezeLayer)
},

resizeFunc : function(event){
	clearTimeout( this._resizeTimeout )
	this._resizeTimeout = setTimeout( function(){
		var activeMenu = $L('lyte-menu:not(.lyteMenuClosed)').e
		for(var i = 0; i < activeMenu.length; i++){
			if(!activeMenu[i].component.hasOwnProperty('parentMenu')){
					activeMenu[i].component.setCss.call(activeMenu[i].component)
					var childMenu = activeMenu[i].component.childMenu
					if( childMenu )
						{
							childMenu.setCss.call( childMenu )
						}
					 var temp = activeMenu[i].component;
					 	if(temp.getData('ltPropFreeze')  && !temp.parentMenu)
							{
								setTimeout(temp.setZIndex.bind(temp), 100);
							}
						setTimeout(temp.heightCheck.bind(temp, temp.childComp), 100);
			}
		}
	}.bind(this), 16 )
},

keydownCheck : function(event){
	if(event.keyCode == 27){
		lyteCloseMenu(event, undefined, true);
	} else {
		var menus = $L('lyte-menu:not(.lyteMenuClosed)[lyte-rendered]').e;
		if( menus.length ) {
			event.preventDefault()
			for( var i = 0; i < menus.length; i++ ) {
				var menu = menus[ i ].component;
				if( !menu.childMenu ) {
					menu.traverseList.call(menu, event);
					break;
				}
			}
		}
	}
},

didDestroy : function(){
		var allNodes = this.childComp.querySelectorAll('lyte-menu-item')
		for(var i=0;i<allNodes.length;i++){
			var curValue = allNodes[i].getAttribute('lyte-shortcut')
			if(curValue){
				allNodes[i].setAttribute('lyte-shortcut',JSON.stringify({}))
			}
		}
		var removeEvents = this.getData('eventListeners'), event = this.getData('ltPropEvent');
	if(this.childComp)
		{
			this.childComp.parentElement.removeChild(this.childComp);
		}
	if($L('lyte-menu').e.length == 0)
		{
			var freezeLayers = $L('div.lytemenufreezelayer').e
			for(var i = 0; i < freezeLayers.length; i++)
				{
					document.body.removeChild(freezeLayers[i]);
				}
			if(document._lyteMenu)
				{
					delete document._lyteMenu
					document.documentElement.removeEventListener('keydown', this.keydownCheck, true);
					document.documentElement.removeEventListener('click', lyteCloseMenu, true);
					window.removeEventListener('resize', this.resizeFunc, true);
				}
			// window.lyteCloseMenu = undefined		
     }
	var ltPropQuery = this.getData('ltPropQuery'), parIndex = this.getData( 'parIndex' ), nodeList;
	if( ltPropQuery || parIndex != undefined ){
		if( ltPropQuery ){
			nodeList = document.querySelectorAll(ltPropQuery);
		}
		document.removeEventListener(event == 'mouseenter' ? 'mousemove' : event, removeEvents.event, true);
		if( ltPropQuery ) {
			for(var i = 0; i < nodeList.length; i++)
				{
					delete nodeList[i].menu;
				}
		}
	}
	delete this.menuNodes;	
},

closestFind : function(path, query){
	var parIndex = this.getData( 'parIndex' ),
	elements = this.arrayFrom.call(this, ( parIndex != undefined ? ( this.$node.parentElement.parentElement.querySelectorAll('lyte-menu-item:nth-of-type(' + ++parIndex + ')') ) : document.querySelectorAll( query.trim() ) ) );
	for(var i = 0; i < path.length; i++)
		{
			if(Array.prototype.indexOf.call(elements, path[i]) != -1)
				{
					return path[i];
				}
		}
	return null;	
},

checkElementForMenu : function(event){
	if(!event.menuFlag)
		{
			var query = this.getData('ltPropQuery');
			var closetElem = this.closestFind.call(this, event.path ? event.path : this.composePath.call(this, event), query);
			if(closetElem != null)
				{
				    if(!this.childComp.classList.contains('lyteMenuHidden')  && this.$node.element != closetElem)
						{
							// for opening same menu at diff position menu body should be hided and its animation need to be prevented
							this.childComp.classList.remove( 'lyteAnimate' )
							this._hideStarts = true
							this._closest = closetElem, this._event = event
							var prom =  new Promise( function( resolve, reject ){
								this._promResolve = resolve, this._promReject = reject
								this.hideMenu.call(this, true, event);
							}.bind( this ) )

							Promise.resolve( prom ).then( function(){
								this.openingMenu( this._closest, this._event )
								delete this._closest; delete this._event; delete this._promReject; delete this._promResolve;
							}.bind( this ), function(){
								delete this._closest; delete this._event; delete this._promReject; delete this._promResolve;
							}.bind( this ))
							return
						}
					this.openingMenu( closetElem, event )
				}		
		}
},

openingMenu : function( closetElem, event ){
	if( closetElem.tagName == "LYTE-MENU-ITEM" && event.type == 'click' ) {
		event.stopPropagation();
	}
	if( event.type == 'contextmenu' ) {
		event.preventDefault();
	}	
	event.menuFlag = true;
	$L.fastdom.mutate(function(){
		this.$node.element = closetElem;
		closetElem.menu = this.$node;
		if(!this.parentMenu)
			{
				this.$node.toggle(event || {});
			}
	}.bind(this))
},	

didConnect : function(){
	var menuBody = $L('lyte-menu-body', this.$node).e[0],menuBox = $L('lyte-menu-box', this.$node).e[0];
	this.$node.toggle = function(event, flag){
		if(this.childComp.classList.contains('lyteMenuHidden') || flag )
			{
				if(['mousedown', 'mouseup'].indexOf(event.type) > -1)
					{
						document._lyteMenu.preventClick = false;
					}
				this.openMenu.call(this, event)
			}
		else
			{
				if(!this.childMenu && event.type.indexOf('mouse') == -1 && !this._hideStarts)
					{
						this.hideMenu.call(this, true, event)
					}
			}	
	}.bind(this);
	menuBody.addEventListener('click', this.optionSelect.bind(this));
	menuBody.parent = this.$node;
	menuBox.parent = this.$node;
	this.childComp = menuBox;
	this.menuBody = menuBody;
	menuBox.classList.add('lyteMenuHidden');
	this.$node.classList.add('lyteMenuClosed');
	var span = document.createElement('span');
	span.setAttribute('class','lyteArrow' + ( this.data.ltPropCallout ? '' : ' lyteMenuHidden' ) );
	menuBody.insertBefore(span,menuBody.children[0]);
	menuBox.style.width = this.getData('ltPropWidth');
	LyteComponent.appendChild(document.body, menuBox);
	if(this.getMethods('afterRender'))
        {
            this.executeMethod('afterRender', this.$node);
        }
},

calloutObs : function( arg ){
	var arrow = this.childComp.querySelector( 'span.lyteArrow' )
	if( arg.newValue ) {
		arrow.classList.remove( 'lyteMenuHidden' )
	} else {
		arrow.classList.add( 'lyteMenuHidden' )
	}
}.observes( 'ltPropCallout' ),

data : function(){
	return{
		// user data
		ltPropContent : Lyte.attr('array',{ 'default' : []}),
		ltPropId : Lyte.attr('string',{'default' : ''}),
		ltPropClass : Lyte.attr('string', { 'default' : ''}),
		ltPropQuery : Lyte.attr('string', {'default' : ''}),
		ltPropEvent : Lyte.attr('string', {'default' : 'click'}),
		ltPropYield : Lyte.attr('boolean', {'default' : false}),
		ltPropUserValue : Lyte.attr('string', {'default' : ''}),
		ltPropSystemValue : Lyte.attr('string', {'default' : ''}),
		ltPropCallout : Lyte.attr('boolean', {'default' : false}),
		ltPropPosition : Lyte.attr('string', { 'default' : 'down'}),
		ltPropDescription : Lyte.attr('string', {'default' : ''}),
		ltPropTabIndex : Lyte.attr('number',{'default' : 0}),
		ltPropFreeze : Lyte.attr('boolean',{'default' : true}),
		ltPropShow : Lyte.attr('boolean',{'default' : false}),
		ltPropWidth : Lyte.attr('string',{'default' : 'auto'}),
		ltPropHeight : Lyte.attr('string',{'default' : 'auto'}),
		ltPropQueryClass : Lyte.attr('string', {'default' : 'lyteMenuSelected'}),
		ltPropBoundary : Lyte.attr('object', {'default' : {}}),
		ltPropScope : Lyte.attr('string', {'default' : ''}),
		ltPropPreventInsideClick : Lyte.attr('boolean', {default : false}),
		ltPropAnimate : Lyte.attr( 'boolean', { default : false }),
		ltPropSetCss : Lyte.attr( 'boolean', { default : true }), 
		ltPropWrapperClass : Lyte.attr('string', { 'default' : ''}),

		// system data 
		eventListeners : Lyte.attr('object', { 'default' : {}}),
		pos : Lyte.attr('string' , { default : ''}),
		parIndex : Lyte.attr( 'number' )
	}
},

firePosCallBack: function() {
	if( this.getMethods( 'onPositionChanged' )) {
		this.executeMethod( 'onPositionChanged', this.getData('pos'), this.$node);
	}
}.observes('pos'),

contentChangeObs : function(){
	this.contentChange.call(this);
}.observes('ltPropContent'),

contentChange : function(){
	if(!this.childComp.classList.contains('lyteMenuHidden'))
		{
			this.setCss.call(this);
			this.menuBody.style.removeProperty('height');
		}
},

setContextCss : function(evt, position){
	var element = this.$node.element;
	var menuBody = this.childComp;
	$L.fastdom.measure(function(){
		var clientRect = menuBody.getBoundingClientRect();
		var innerHeightt = window.innerHeight;
		var innerWidtht = window.innerWidth;
		$L.fastdom.mutate(function(){
			if(!position)
				{
					position = this.getData('ltPropPosition')
				}
			switch(position)
				{
					case 'up' :{
						menuBody.style.left = evt.clientX + 'px';
						menuBody.style.top = (evt.clientY - clientRect.height) + 'px';
						if(clientRect.top < 0)
							{
								menuBody.style.top = evt.clientY + 'px';
							}
						if((parseInt(menuBody.style.top) + clientRect.height) > innerHeightt)
							{
								menuBody.style.top = (evt.clientY - clientRect.height) + 'px';
							}	
						this.setData( 'pos', 'up' )	
						break;
					}
					default : {
						menuBody.style.left = evt.clientX + 'px';
						menuBody.style.top = evt.clientY + 'px';
						if((parseInt(menuBody.style.top) + clientRect.height) > innerHeightt)
							{
								menuBody.style.top = (evt.clientY - clientRect.height) + 'px';
							}
						if(parseInt(menuBody.style.top) < 0)
							{
								menuBody.style.top = evt.clientY + 'px';
							}	
						this.setData( 'pos', 'down' )		
					}
				}
			if(clientRect.left < 0)
				{
					menuBody.style.left = evt.clientX + 'px';
				}
			else if(clientRect.right > innerWidtht)
				{
					menuBody.style.left = (evt.clientX - clientRect.width) + 'px';
				}
			// $L.fastdom.measure(function(){	
				this._hgt =  this.heightCheck.call(this, this.menuBody, event, clientRect);
			// }.bind(this))		
		}.bind(this))
	}.bind(this))

},


openMenu : function(event, flagg){
	var onBeforeOpen, eventType = this.getData('ltPropEvent'), targetDiv;
	event = event ? event : {}
	if(!flagg)
		{
			targetDiv = this.targetElem.call(this, event.target);
			if( targetDiv[ 0 ] ) {
				targetDiv[ 0 ].originMenu = targetDiv[ 1 ].component
			}
		}
	if(flagg && eventType != 'contextmenu')
		{
			if(!this.$node.element)
				{
					var query = this.getData('ltPropQuery');
					this.$node.element = (/^#/g.test(query.trim()) && !/\s/g.test(query.trim())) ? $L(query).e : $L(query).e[0];
				}
			if(this.$node.element.tagName == 'LYTE-MENU-ITEM')
				{
					targetDiv = this.targetElem.call(this, this.$node.element);
				}	
			else if(!targetDiv)
				{
					targetDiv = [];
				}	
		}
	if(this.getMethods('onBeforeOpen'))
		{
			onBeforeOpen = this.executeMethod('onBeforeOpen', this.$node, event, this.$node.element);
		}
	if(onBeforeOpen != false)
		{
			//Actual opening process
			$L.fastdom.measure(function(){
				// to set initial position if its scrolled previously
				this.childComp.scrollTop = 0;	
			}.bind(this))
			$L.fastdom.mutate(function(){
				this.childComp.classList.remove('lyteMenuHidden')
				this.$node.classList.remove('lyteMenuClosed');
				this.childComp.style.display = 'block'
				if(!this.parentMenu)
					{
						this.$node.element.classList.add(this.getData('ltPropQueryClass'))
					}
				if( this.getData( 'ltPropHeight' ) ){	
					this.menuBody.style.height = this.getData( 'ltPropHeight' )
				} else {
					this.menuBody.style.removeProperty('height')
				}	
				if(this.getData('ltPropEvent') == 'contextmenu')
					{
						this.setContextCss.call(this, event);
					}	
				else
					{	
						this.setCss.call(this);
					}
				if(targetDiv[0])
					{
						 if(targetDiv[1].tagName == 'LYTE-MENU')
							{
								targetDiv[1].component.childMenu = this
								this.parentMenu = targetDiv[1].component
								targetDiv[1].component.childComp.addEventListener('mousemove',this.mouseleave)
							}
					}
				if(!this.parentMenu && this.$node.element.tagName != 'LYTE-MENU-ITEM')
					{
						lyteCloseMenu(event, this.$node)
					}
				if(this.getData('ltPropFreeze')  && !this.parentMenu)
					{
						this.setZIndex.call(this)
					}
				else if(!document.menu)
					{
						window.addEventListener('scroll',this.addScrollPos, true)
						document.menu = this
					}
				if((eventType == 'mouseenter' || eventType == 'mouseover' || eventType == 'mousemove') && !this.childMenu && !this.parentMenu && !targetDiv[0])
					{
						var evt = this.hoverClose.bind(this);
						this.setData('eventListeners.hoverClose', evt)
						document.addEventListener('mousemove', evt);
						this.$node.element.addEventListener('mousemove', this.preventEvent);
						this.menuBody.addEventListener('mousemove', this.preventEvent);
					}
				if( event.type != 'contextmenu' ) {	
					this._hgt =  this.heightCheck.call(this, this.menuBody, event);
						if( this.getData( 'ltPropAnimate' )  && this._hgt != 0 ){
							// for animating height height need to set as zero and animate class need to be added
							this.menuBody.style.height = 0;
							if( [ 'up', 'upLeft', 'upRight' ].indexOf( this.getData( 'pos' ) ) != -1 ) {
								this.childComp.style.top = parseInt( this.childComp.style.top ) + this._hgt + 'px';
							}
							setTimeout( this.animeClassAdd.bind(this), 20)
						}
					}
				if(this.getMethods('onOpen')){
					   this.executeMethod('onOpen', this.$node, event, this.$node.element);
					}
			}.bind(this))
			if(event.type == 'contextmenu'){
				event.preventDefault();
			}	

		} else {
			this._dontCall = true;
			delete this.$node.element;
			this.setData( 'ltPropShow', false )
			delete this._dontCall;
			if( this._promReject ) {
				this._promReject();
			}
		}
},

animeClassAdd : function(){
	this.childComp.classList.add( 'lyteAnimate' );
	setTimeout( this.heightSet.bind( this ), 20 ) 
},

heightSet : function(){
	// for invert animation
	if( [ 'up', 'upLeft', 'upRight' ].indexOf( this.getData( 'pos' ) ) != -1 ) {
		this.childComp.style.top = parseInt( this.childComp.style.top ) - this._hgt + 'px';
	}
	// animation start
	this.menuBody.style.height = this._hgt + 'px';	
},

heightCheck : function(menuBody, event){
		if(  !this.getData( 'ltPropSetCss' ) ) {
			return
		}
	// here fastdom is removed for proper on open callback
		// menu body properties are required for enable scroll when window size is too small to view full menu body
		var clientRect = menuBody.getBoundingClientRect(), hgt;
		var windowHgt = window.innerHeight;
		// if( !this._hgtWheel ){
		// 	this.menuBody.addEventListener('wheel', this.preventEvent);
		// 	this._hgtWheel = true
		// }
		hgt = clientRect.bottom - clientRect.top;
		if(clientRect.bottom > windowHgt)
			{
				this.menuBody.style.height = (windowHgt - clientRect.top) + 'px';
				hgt = windowHgt - clientRect.top;
			}		
		if(clientRect.top < 0)
			{
				this.menuBody.style.height = clientRect.bottom + 'px';
				this.childComp.style.top = '0px';
				hgt = clientRect.bottom;
			}	
		this._dontCall = true;
		this.$node.ltProp('show', true);
		delete this._dontCall;
		return hgt;
},

composePath : function(event){
		var arr = [], node = event.target;
		while(node.tagName != 'HTML')
			{
				arr.push(node);
				node = node.parentElement;
			}
		return arr;	
},

elementsFromPointCal : function(x, y){
	// for gettting elements from point on hover menu
		var arr = [], element = document.elementFromPoint(x, y);
		while(element != document && element != document.documentElement && element != document.body && element.tagName != 'LYTE-MENU-BODY' )
			{
				element.style.pointerEvents = 'none';
				arr.push(element);
				element = document.elementFromPoint(x, y);
			}
		for(var i = 0; i < arr.length; i++)
			{
				arr[i].style.pointerEvents = 'initial';
			}
		return arr;		
},

hoverClose : function(event){
	if(this.$node)
		{
			if((document.elementsFromPoint ? document.elementsFromPoint(event.clientX, event.clientY) : this.elementsFromPointCal.call(this, event.clientX, event.clientY)).indexOf(this.$node.element) == -1)
				{
					this.hideMenu.call(this, true, event);
				}
		}
},

mouseleave : function(event){
	var component = this.parent.component, target = component.targetElem.call(component, event.target);
	if(component.childMenu)
		{
			if(target[1] == component.$node && target[0] != component.childMenu.$node.element && target[0])
				{
					this.removeEventListener('mousemove',component.childMenu.mouseleave)	
					component.childMenu.hideMenu.call(component.childMenu, true, event)
				}
		}
},

hideToggle : function(arg){
	if(this._dontCall){
		return;
	}
	if(arg.newValue == false)
		{
			this.hideMenu.call(this, true, {});
		}
	else
		{
			this.openMenu.call(this, {}, true);
		}	
}.observes('ltPropShow'),

hideMenu : function(flag, event, flag2){
	var onBeforeClose;
	if(this.childMenu)
		{
			if( !this.childMenu.childComp.contains(event.target) || flag2 ){
				if( !this.childMenu.hideMenu.call( this.childMenu, flag, event, flag2 ) ){
					return
				}
			} else {
				return
			}
		}
		if(this.getMethods('onBeforeClose'))
			{ 
			   onBeforeClose = this.executeMethod('onBeforeClose', this.$node, event);
		    }
	if(onBeforeClose != false)	
		{
			if(this.parentMenu)	
				{
					delete this.parentMenu.childMenu 
					delete this.parentMenu
				}
			else 
				{	
					this.$node.element.classList.remove(this.getData('ltPropQueryClass'))	
					delete document.menu 
					window.removeEventListener('scroll',this.addScrollPos, true)
				}
			this._arguments = arguments;
			if( [ 'mouseenter', 'mousemove', 'mouseover' ].indexOf( this.getData( 'ltPropEvent' ) ) != -1 ) {
				var evt = this.getData('eventListeners.hoverClose');
				this.$node.element.removeEventListener('mousemove', this.preventEvent);
				this.menuBody.removeEventListener('mousemove', this.preventEvent);
				document.removeEventListener('mousemove', evt);
			}
			$L.fastdom.mutate( function(){
				if( this.childComp.classList.contains( 'lyteAnimate' ) && this.data.ltPropEvent != 'contextmenu' ) {
					// for hide height is set to zero
					this.menuBody.style.height = 0;
					// for invert animation
					if( [ 'up', 'upLeft', 'upRight' ].indexOf( this.getData( 'pos' ) ) != -1 ) {
						this.childComp.style.top = parseInt( this.childComp.style.top ) + this._hgt + 'px';
					}
					this.menuBody.addEventListener( 'transitionend', this._close )
				} else {
					delete this._arguments;
					this.closing( flag, event )
				}	
			}.bind(this))
			return true	
		} else {
			this._dontCall = true;
			this.setData( 'ltPropShow', true )
			delete this._dontCall;
			delete this._hideStarts;
			if( this._promReject ) {
				this._promReject();
			}
		}
},

closing : function( ){
	var flag, evt;
	if( this._arguments ) {
	 	flag = this._arguments[ 0 ];
	 	evt = this._arguments[ 1 ];
	 	// height set to its original
		this.menuBody.style.height = this._hgt + 'px';
		delete this._hgt;
		delete this._arguments;
	} else {
		flag = arguments[ 0 ];
	 	evt = arguments[ 1 ];
	}
	this.menuBody.removeEventListener( 'transitionend', this._close )
	this.childComp.classList.add('lyteMenuHidden')
	delete this._hideStarts;
	this.$node.classList.add('lyteMenuClosed');
	if(this.getData('ltPropFreeze') && !this.parentMenu)
		{
			this.setZIndex.call(this, flag)
		}
	this._dontCall = true;
	this.$node.ltProp('show', false);
	delete this._dontCall;
	delete this.$node.element
	this.childComp.classList.remove( 'lyteAnimate' )
	var selection = this.childComp.querySelector( '.lyteMenuSelection' )
	if( selection ) {
		selection.classList.remove( 'lyteMenuSelection' )
	}
	$L.fastdom.measure(function(){
		if(this.getMethods('onClose'))
			{
			 	this.executeMethod('onClose', this.$node, evt);
			}
		if( this._promResolve ) {
				$L.fastdom.mutate( this._promResolve.bind( this ) )
			}	
	}.bind(this))
},
 
targetElem : function(nodeName){
	var currNode
	while(nodeName.tagName != 'LYTE-MENU-BODY' && nodeName.tagName != 'BODY')
		{
			if(nodeName.tagName == 'LYTE-MENU-ITEM')
				{
					currNode = nodeName
				}
			nodeName = nodeName.parentElement;
		}
	return [currNode, nodeName.parent]	
},

optionSelect : function(event){
	var nodeName = this.targetElem.call(this, event.target)[0], flag
	if((event.ctrlKey == true || event.metaKey == true || event.which == 2) && event.target.href != undefined && event.target.href.indexOf('javascript:') != -1 && event.target.target == '_blank'){return false;}
	if(this.getMethods('onMenuClick') && nodeName)
        {
          var value;
          if(this.getData('ltPropYield'))
              {
                value = nodeName.getAttribute('data-value')
              }
           else
              {
                var ltPropContent = this.getData('ltPropContent')
                if(nodeName.hasAttribute('grporder'))
	                  {
	                     var grp = ltPropContent[parseInt(nodeName.getAttribute('grporder'))]
	                     value = grp[Object.keys(grp)[0]][parseInt(nodeName.getAttribute('elemorder'))]
	                  }
	              else
	                  {
	                      value = ltPropContent[parseInt(nodeName.getAttribute('elemorder'))]
	                  }    
              }   
           flag = this.executeMethod('onMenuClick', value, event, this.$node, this.$node.element, { element : nodeName, submenu : !!nodeName.originMenu } );
       }
    if(this.childMenu && !flag)
    	{
    		event.stopPropagation()
    	}
    if(nodeName || (!nodeName && this.getData('ltPropPreventInsideClick')))
    	{
    		lyteCloseMenu(event,undefined, true)
    		// this.hideMenu( false, event, true )
    	}	
  },
	/*
		Calculate left of menu container when it has to come below/above the select element when it exceeds window.innerWidth and there is space to the right
	*/
setLeftExceedForDown: function( element, container, bcr, containerbcr, xscroll ) {
		var scrolledLeft = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		elementWidth = elementBCR.width,
		containerBCR = containerbcr,
		containerWidth = containerBCR.width,
		total = scrolledLeft + elementLeft + elementWidth - containerWidth;

		return total
	},
	/*
		Calculate left of menu container when it has to come below/above the select element when it doesn't exceed window.innerWidth
	*/
	setLeftNotExceedForDown: function( element, bcr, xscroll ) {
		var scrolledLeft = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		total = scrolledLeft + elementLeft;

		return total
	},
	/*
		Calculate top of menu container when it has to come above the select element
	*/
	setTopAboveForDown: function( element, container, bcr, containerbcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		containerBCR = containerbcr,
		containerHeight = containerBCR.height,
		total = scrolledHeight + elementTop  - containerHeight;

		return total
	},
	/*
		Calculate top of menu container when it has to come below the select element
	*/
	setTopBelowForDown: function( element, bcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		elementHeight = elementBCR.height,
		total = scrolledHeight + elementTop + elementHeight;

		return total
	},
	/*
		Calculate left of menu container when it has to come to right of the select element
	*/
	setLeftForRight:function( element, bcr, xscroll ) {
		var scrolledWidth = xscroll,
		elementBCR = bcr,
		elementLeft = elementBCR.left,
		elementWidth = elementBCR.width,
		total = scrolledWidth + elementLeft + elementWidth;

		return total
	},
	/*
		Calculate right of menu container when it has to come to left of the select element of right menu
	*/
	setRightForRight: function( element, container, bcr, elembcr, xscroll ) {
		var scrolledWidth = xscroll,
		elementBCR = bcr,
		containerBCR = elembcr,
		elementLeft = elementBCR.left,
		containerWidth = containerBCR.width,
		total = scrolledWidth + elementLeft - containerWidth;

		return total
	},
	/*
		Calculate top of menu container when it has to come to right of menu and there is space below
	*/
	setTopForRight:function( element, bcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		total = scrolledHeight + elementTop;

		return total
	},
	/*
		Calculate top of menu container when it has to come to right of menu and there is no space below
	*/
	setTopForRightAbove:function( element, container, bcr, elembcr, yscroll ) {
		var scrolledHeight = yscroll,
		elementBCR = bcr,
		elementTop = elementBCR.top,
		elementHeight = elementBCR.height,
		containerBCR = elembcr,
		containerHeight = containerBCR.height,
		total = scrolledHeight + elementTop + elementHeight - containerHeight;

		return total
	},
	/**
		Remove wrong arrow and append proper arrow
		@param string correct - the correct class
	*/
	setCorrectClass: function( cls ) {
		var arrow = this.childComp.querySelector( '.lyteArrow' ),
		list = arrow.classList, i = 0;
		for( ; i < list.length; i++ ) {
			if( list[ i ] == 'lyteArrow' || list[ i ] == cls ) {
				continue;
			}
			else { 
				arrow.classList.remove( list[ i ] );
				i--;
			}
		}

		arrow.classList.add( cls );
	},

	/**
	 * Set the CSS for your menu
	 * refer commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 and previous for the previous stable setCSS function.
	 * commit ID 583ee6ccbeaa6b3729178bf9df0139032b016d19 also gives a better understanding about the hard coded values in this function.
	 */ 
	setCss: function( onlyScroll ) {
		var link = this.childComp;

		if( !link 
			|| link.classList.contains( 'lyteMenuHidden' ) || !this.getData( 'ltPropSetCss' )
		) {
			return;
		}

		// Get properties
		var callout = this.getData( 'ltPropCallout' );


		// Get button
		var body = link,
		par = this.$node.element;

		// Get Geometric propotions
		var wwidth, wheight, wleft, wtop;
		var query = this.getData('ltPropScope'), flag;
		if(query)
			{
				var temp = {target : par};
				var elemm = this.closestFind.call(this, this.composePath.call(this, temp), query);
				if(elemm)
					{
						var rec = elemm.getBoundingClientRect();
						wleft = rec.left < 0 ? 0 : rec.left;
						wwidth =  window.innerWidth > rec.right ? rec.right : window.innerWidth;
						flag = true
					}
			}
		if(!flag)
			{
				wwidth = window.innerWidth
				wleft = 0;
			}
		var wheight= window.innerHeight;
		var wtop = 0,	
		drop = body.getBoundingClientRect(), 
		x = window.pageXOffset || document.documentElement.scrollLeft,
		y = window.pageYOffset || document.documentElement.scrollTop,
		height = body.offsetHeight,
		width = body.offsetWidth, 
		arrow = link.querySelector( '.lyteArrow' ),
		position = this.getData( 'ltPropPosition' ),
		offsets = par.getBoundingClientRect(),
		arrowBcr = arrow ? arrow.getBoundingClientRect() : { width : 0, height : 0 }
		aHeight = arrowBcr.height / 2,
		aWidth = arrowBcr.width / 2;

		// Intialize flags
		var downPos, 
		rightPos, 
		topPos, 
		leftPos; 

		// temp stores
		var tempStore,
		tempTop, 
		tempLeft, 
		tempMarginLeft, 
		tempMarginTop,
		tempNum, 
		tempDenom,
		pos, 
		tempPer;

		if( arrow ){
			arrow.style.removeProperty('left');
			arrow.style.removeProperty('top');
			arrow.style.removeProperty('bottom');
		}
		if( position === 'down' ) {
			downPos = true;
			tempTop = offsets.top + offsets.height; 
			if( tempTop + height > wheight 
				/*&& offsets.top > height */
			) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );		
			}
			rightPos = true;
			tempLeft = offsets.left;
			if( tempLeft + width > wwidth 
				&& tempLeft > tempLeft + offsets.width - body.offsetWidth 
			) {
				rightPos = false;
				
			}
			else if( offsets.left + width <= wwidth ) {
				rightPos = true;
			}

			if( offsets.width > width ) {    
				arrow.style.left = ( ( width / 2 - 0 ) / width ) * 100 + "%"; 
			}

			if( downPos ) {
				pos = 'down'
				if( callout ) {
					this.setCorrectClass( 'lyteArrowTop' );
					tempStore = this.setTopBelowForDown( par, offsets, y ) + aHeight + 'px';
				}
				else { 
					body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px';
				}
				
			}
			else {
				pos = 'up';
				if( callout ) {
					this.setCorrectClass( 'lyteArrowBottom' );
					tempStore = this.setTopAboveForDown( par, body, offsets, drop, y ) - aHeight + 'px';					
				}
				else {
					body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y ) + 'px';
				}
			}

			if( rightPos ) {
				if( callout ) {
					tempNum = Math.max( offsets.width / 2 - aWidth, aWidth / 2 ); // We removed arrow.offsetWidth because it was giving width as 0 px
					tempDenom = width / 100;
					tempPer = tempNum / tempDenom;
					arrow.style.left = tempPer + '%'; 	
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftNotExceedForDown( par, offsets, x ) + 'px';	
			}
			else {
				if( callout ) {
					tempDenom = width / 100;
					tempNum = width - ( offsets.width / 2 ) - aWidth ; // We removed arrow.offsetWidth because it was giving width as 0 px
					tempPer = tempNum / tempDenom;
					arrow.style.left = tempPer + '%'; 
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftExceedForDown( par, body, offsets, drop, x ) + 'px'
			}

			
		}
		else if( position === 'right' ) {
			rightPos = true;
			if( offsets.left + offsets.width + width > wwidth 
				&& offsets.left - drop.width > wleft 
			) {   
				rightPos = false;
				
			}
			else{
				rightPos = true;
			}

			downPos = true;
			if( offsets.top + drop.height > wheight ) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );
			}

			if( rightPos ) {
				pos = 'right';
				if( callout ) {
					this.setCorrectClass( 'lyteArrowLeft' );
					tempStore = this.setLeftForRight( par, offsets, x ) + aWidth + 'px';
				}
				else {
					body.style.left= this.setLeftForRight( par, offsets, x ) + 'px'
				}
			}
			else {
				pos = 'left';
				if( callout ) {
					this.setCorrectClass( 'lyteArrowRight' );
					tempStore = ( this.setRightForRight( par, body, offsets, drop, x ) - aWidth ) + 'px';
				}
				else {
					body.style.left = this.setRightForRight( par, body, offsets, drop, x ) + 'px';
				}
			}

			if( downPos ) {
				if( callout ) { 
					arrow.style.top = Math.max( offsets.height / 2 - aHeight, aHeight / 2 ) + 'px';
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRight( par, offsets, y ) + 'px' 
			}
			else {
				if( callout ) { 
					arrow.style.bottom = Math.max( offsets.height / 2 - aHeight, aHeight / 2 ) + 'px';
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px'
			}
		}
		else if( position === 'up' ) {
			topPos = true
			if( offsets.top - drop.height < wtop
				/*&& offsets.top + offsets.height + height < wheight */
			) {
				topPos = ( wheight - offsets.top ) < ( offsets.bottom - wtop )
			}

			rightPos = true
			if( offsets.left + width > wwidth 
				&& offsets.left > offsets.left + offsets.width - body.offsetWidth 
			) {
				rightPos = false
			}
			else if( offsets.left + width <= wwidth ) {
				rightPos = true
			}

			if( offsets.width > width && arrow ) {     
				arrow.style.left = ( ( width / 2 - 0 ) / width ) * 100 +'%';
			}

			if( topPos ) {
				pos  = 'up';
				if( callout ) {
					this.setCorrectClass( 'lyteArrowBottom' );
					tempStore = this.setTopAboveForDown( par, body, offsets, drop, y ) - aHeight + 'px';	
				}
				else {
					body.style.top = this.setTopAboveForDown( par, body, offsets, drop, y ) + 'px';
				}
			}
			else {
				pos = 'down';
				if( callout ) {
					this.setCorrectClass( 'lyteArrowTop' );
					tempStore = this.setTopBelowForDown( par, offsets, y ) + aHeight + 'px';
				}
				else {
					body.style.top = this.setTopBelowForDown( par, offsets, y ) + 'px'
				}
			}
			if( rightPos ) {
				if( callout ) {
					tempNum = Math.max( offsets.width / 2 - aWidth, aWidth / 2 ); // We removed arrow.offsetWidth because it was giving width as 0 px
					tempDenom = width / 100;
					tempPer = tempNum / tempDenom;
					arrow.style.left = tempPer + '%' 
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftNotExceedForDown( par, offsets, x ) + 'px';
			}
			else{
				if( callout ) {
					tempDenom = width / 100;
					tempNum = width - ( offsets.width / 2 ) - aWidth; // We removed arrow.offsetWidth because it was giving width as 0 px
					tempPer = tempNum / tempDenom; 
					arrow.style.left = tempPer +'%'; 
				}

				body.style.top = tempStore ? tempStore : body.style.top;
				body.style.left = this.setLeftExceedForDown( par, body, offsets, drop, x ) + 'px';
			}
		}
		else if( position === 'left' ) {
			leftPos = true;
			if( offsets.left - drop.width < wleft
				&& offsets.left + drop.width < wwidth 
			) {
				leftPos = false;
			}
			else {
				leftPos = true;
			}

			downPos = true;
			if( offsets.top + drop.height > wheight ) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );
			}

			if( leftPos ) {
				pos = 'left';
				if( callout ) {
					this.setCorrectClass( 'lyteArrowRight' );
					tempStore = ( this.setRightForRight( par, body, offsets, drop, x ) - aWidth ) + 'px';
				}
				else {
					body.style.left = this.setRightForRight( par, body, offsets, drop, x ) + 'px';
				}	
			}
			else {
				pos = 'right';
				if( callout ) {
					this.setCorrectClass( 'lyteArrowLeft' );
					tempStore = ( this.setLeftForRight( par, offsets, x ) + aWidth ) + 'px';
				}
				else {
					body.style.left = this.setLeftForRight( par, offsets, x ) + 'px';
				}
			}
			if( downPos ){
				if( callout ){
					arrow.style.top = Math.max( offsets.height / 2 - aHeight, aHeight / 2 ) + 'px';
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRight( par, offsets, y ) + 'px';
			}
			else{
				if( callout ) {
					arrow.style.bottom = Math.max( offsets.height / 2 - aHeight, aHeight / 2 ) + 'px'; 
				}

				body.style.left = tempStore ? tempStore : body.style.left;
				body.style.top = this.setTopForRightAbove( par, body, offsets, drop, y ) + 'px';
			}
		} else if( position === 'downLeft' ) {
			downPos = true;
			tempTop = offsets.top + offsets.height;
			if( tempTop + height > wheight /*&& offsets.top > height*/ ) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );
			}
			if( !downPos ) {
				tempTop = offsets.top - height;
			}
			rightPos = false

			if( callout ) {
				this.setCorrectClass( downPos ? 'lyteArrowTop' : 'lyteArrowBottom' );
			} 
			tempLeft = Math.max( offsets.left + offsets.width / 2 - width, offsets.left - width + 2 * aHeight );
			if( tempLeft < wleft ) {
				tempLeft = wleft
				rightPos = true
			} else { 
				rightPos  = false
			}
			body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( callout ) {
				var newArrowLeft;
				if( rightPos ) {
					newArrowLeft = ( offsets.left + 0.25 * offsets.width - tempLeft ) + 'px';
				} else { 
					newArrowLeft = Math.min(width - 0.25 * offsets.width, width - ( aHeight * 1.5 ) - 3)  + 'px';
				}
				arrow.style.left = newArrowLeft;
			}
			if( downPos ){
				pos = 'downLeft';
			} else {
				pos = 'upLeft';
			}

		} else if( position === 'downRight' ) {
			downPos = true;
			tempTop = offsets.top + offsets.height;
			if( tempTop + height > wheight /*&& offsets.top > height*/ ) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );
			}

			if( !downPos ) {
				tempTop = offsets.top - height
			}

			rightPos = true

			if( callout ) {
				this.setCorrectClass( downPos ? 'lyteArrowTop' : 'lyteArrowBottom' );
			}
			tempLeft = Math.min( offsets.left + offsets.width / 2, offsets.left + offsets.width - 2 * aHeight );
			if( tempLeft + width > wwidth ) {
				tempLeft = wwidth - width;
				rightPos = false;
			} else { 
				rightPos  = true;
			}

			body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( callout ) {
				var newArrowLeft;
				if( rightPos ) {
					newArrowLeft = Math.max( 0.25 * offsets.width, aWidth / 2 ) + 'px';
				} else { 
					newArrowLeft = ( offsets.left + 0.25 * offsets.width - tempLeft ) + 'px';
				}
				arrow.style.left = newArrowLeft;
			}
			if( downPos ){
				pos = 'downRight';
			} else {
				pos = 'upRight';
			}
		} else if( position === 'upLeft' ) {
			downPos = false;
			tempTop = offsets.top - height;
			if( tempTop < wtop) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );
			}
			if( downPos ) {
				tempTop = offsets.top + offsets.height;
			}
			rightPos = false
			if( callout ) {
				this.setCorrectClass( downPos ? 'lyteArrowTop' : 'lyteArrowBottom' );
			} 
			tempLeft = Math.max( offsets.left + offsets.width / 2 - width, offsets.left - width + 2 * aHeight );
			if( tempLeft < wleft ) {
				tempLeft = wleft
				rightPos = true
			} else { 
				rightPos  = false
			}
			body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( callout ) {
				var newArrowLeft;
				if( rightPos ) {
					newArrowLeft = ( offsets.left + 0.25 * offsets.width - tempLeft ) + 'px';
				} else { 
					newArrowLeft = Math.min( width - 0.25 * offsets.width, width - ( aHeight * 1.5 ) - 3 )  + 'px';
				}
				arrow.style.left = newArrowLeft;
			}
			if( downPos ){
				pos = 'downLeft';
			} else {
				pos = 'upLeft';
			}

		} else if( position === 'upRight' ) {
			downPos = false;
			tempTop = offsets.top - height;
			if( tempTop < wtop) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );
			}
			if( downPos ) {
				tempTop = offsets.top + offsets.height
			}

			rightPos = true

			if( callout ) {
				this.setCorrectClass( downPos ? 'lyteArrowTop' : 'lyteArrowBottom' );
			}
			tempLeft = Math.min( offsets.left + offsets.width / 2, offsets.left + offsets.width - 2 * aHeight );
			if( tempLeft + width > wwidth ) {
				tempLeft = wwidth - width;
				rightPos = false;
			} else { 
				rightPos  = true;
			}

			body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( callout ) {
				var newArrowLeft;
				if( rightPos ) {
					newArrowLeft = Math.max( 0.25 * offsets.width, aWidth / 2 ) + 'px';
				} else { 
					newArrowLeft = ( offsets.left + 0.25 * offsets.width - tempLeft ) + 'px';
				}
				arrow.style.left = newArrowLeft;
			}
			if( downPos ){
				pos = 'downRight';
			} else {
				pos = 'upRight';
			}
		} else if( position === 'downAlignLeft' ) {
			downPos = true;
			tempTop = offsets.top + offsets.height;
			if( tempTop + height > wheight /*&& offsets.top > height*/ ) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );
			}

			if( !downPos ) {
				tempTop = offsets.top - height
			}

			rightPos = false

			if( callout ) {
				this.setCorrectClass( downPos ? 'lyteArrowTop' : 'lyteArrowBottom' );
			} 
			tempLeft = Math.max( offsets.left + offsets.width - width, offsets.left - width + 2 * aHeight );
			if( tempLeft < wleft ) {
				tempLeft = Math.max( Math.min( offsets.left, offsets.left + offsets.width - 2 * aHeight ), wleft )
				rightPos = true
			} else { 
				tempLeft = Math.min( wwidth - width, tempLeft )
				rightPos  = false
			}
			body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( callout ) {
				var newArrowLeft;
				if( rightPos ) {
					newArrowLeft =  ( offsets.right - tempLeft ) / 2 + 'px'; 
				} else { 
					newArrowLeft = Math.min( ( offsets.left - tempLeft + width ) / 2, width - ( aHeight * 1.5 ) - 3)  + 'px';
				}
				arrow.style.left = newArrowLeft;
			}
			if( downPos ){
				pos = 'downAlignLeft';
			} else {
				pos = 'upAlignLeft';
			}

		} else if( position === 'downAlignRight' ) {
			downPos = true;
			tempTop = offsets.top + offsets.height;
			if( tempTop + height > wheight /*&& offsets.top > height*/ ) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );
			}

			if( !downPos ) {
				tempTop = offsets.top - height;
			}

			rightPos = true

			if( callout ) {
				this.setCorrectClass( downPos ? 'lyteArrowTop' : 'lyteArrowBottom' );
			}
			tempLeft = Math.min( offsets.left, offsets.left + offsets.width - 2 * aHeight );
			if( tempLeft + width > wwidth ) {
				tempLeft = Math.min( Math.max( offsets.left + offsets.width - width, offsets.left - width + 2 * aHeight ), wwidth - width );
				rightPos = false;
			} else { 
				tempLeft = Math.max( tempLeft, 0 )
				rightPos  = true;
			}

			body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( callout ) {
				var newArrowLeft;
				if( rightPos ) {
					newArrowLeft = Math.max( 0.5 * ( offsets.right - tempLeft - aWidth ), aWidth / 2 ) + 'px';
				} else { 
					newArrowLeft = ( 0.5 * ( -tempLeft + width + offsets.left ) ) + 'px';
				}
				arrow.style.left = newArrowLeft;
			}
			if( downPos ){
				pos = 'downAlignRight';
			} else {
				pos = 'upAlignRight';
			}
		}else if( position === 'upAlignLeft' ) {
			downPos = false;
			tempTop = offsets.top - height;
			if( tempTop < wtop) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );
			} 
			if( downPos ) {
				tempTop = offsets.top + offsets.height;
			}
			rightPos = false
			if( callout ) {
				this.setCorrectClass( downPos ? 'lyteArrowTop' : 'lyteArrowBottom' );
			} 
			tempLeft = Math.max( offsets.left + offsets.width - width, offsets.left - width + 2 * aHeight );
			if( tempLeft < wleft ) {
				tempLeft = Math.max( Math.min( offsets.left, offsets.left + offsets.width - 2 * aHeight ), wleft )
				rightPos = true
			} else { 
				tempLeft = Math.min( wwidth - width, tempLeft )
				rightPos  = false
			}
			body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( callout ) {
				var newArrowLeft;
				if( rightPos ) {
					newArrowLeft =  ( offsets.right - tempLeft ) / 2 + 'px'; 
				} else { 
					newArrowLeft = Math.min( ( offsets.left - tempLeft + width ) / 2, width - ( aHeight * 1.5 ) - 3)  + 'px';
				}
				arrow.style.left = newArrowLeft;
			}
			if( downPos ){
				pos = 'downAlignLeft';
			} else {
				pos = 'upAlignLeft';
			}
		} else if( position === 'upAlignRight' ) {
			downPos = false;
			tempTop = offsets.top - height;
			if( tempTop < wtop) {
				downPos = ( wheight - offsets.top ) > ( offsets.bottom - wtop );
			} 
			if( downPos ) {
				tempTop = offsets.top + offsets.height;
			}
			rightPos = true

			if( callout ) {
				this.setCorrectClass( downPos ? 'lyteArrowTop' : 'lyteArrowBottom' );
			}
			tempLeft = Math.min( offsets.left, offsets.left + offsets.width - 2 * aHeight );
			if( tempLeft + width > wwidth ) {
				tempLeft = Math.min( Math.max( offsets.left + offsets.width - width, offsets.left - width + 2 * aHeight ), wwidth - width );
				rightPos = false;
			} else { 
				tempLeft = Math.max( tempLeft, 0 )
				rightPos  = true;
			}

			body.style.top = tempTop + aHeight * (downPos ? 1 : -1) + y + 'px';

			body.style.left = tempLeft + x + 'px';
			if( callout ) {
				var newArrowLeft;
				if( rightPos ) {
					newArrowLeft = Math.max( 0.5 * ( offsets.right - tempLeft - aWidth ), aWidth / 2 ) + 'px';
				} else { 
					newArrowLeft = ( 0.5 * ( -tempLeft + width + offsets.left ) ) + 'px';
				}
				arrow.style.left = newArrowLeft;
			}
			if( downPos ){
				pos = 'downAlignRight';
			} else {
				pos = 'upAlignRight';
			}
		}
		this.setData( 'pos', pos);	
	},

	checkForBoundary : function(menuBody){
		var clientRect = this.$node.element.getBoundingClientRect();
		var boundary = this.getData('ltPropBoundary');
		if((boundary.hasOwnProperty('left') ? (clientRect.left < boundary.left) : false) || (boundary.hasOwnProperty('right') ? (clientRect.right > boundary.right) : false)  || (boundary.hasOwnProperty('top') ? (clientRect.top < boundary.top) : false)  || (boundary.hasOwnProperty('bottom') ? (clientRect.bottom > boundary.bottom) : false))		
			{	
				this.hideMenu.call(this);
			}
	},

	traverseList:function(event){
		var kc = event.keyCode
		if((this.childComp && this.childComp.classList.contains('lyteMenuHidden'))||(kc != 13 && kc != 40 && kc != 38)){
				return
		}
		// event.preventDefault();
		var cursel = this.childComp.querySelector('.lyteMenuSelection')
		if(!cursel || !cursel.offsetParent){
			var elem = this.childComp.querySelector('lyte-menu-item:not(.lyteSearchHidden)')
			if(elem && elem.offsetParent){
				elem.classList.add('lyteMenuSelection')
				return ;
			}
		}
		
			var elements = this.childComp.querySelectorAll('lyte-menu-item:not(.lyteSearchHidden)')
			for(var i=0;i<elements.length;i++){
				if( !elements[i].offsetParent ) {
					continue;
				}
				if(elements[i].classList.contains('lyteMenuSelection')){
					break;
				}
			}
			if(kc == 13){
					elements[i].dispatchEvent( new Event( 'click', { bubbles : true } ) )
			}
			else if(kc == 38 && i != 0){
					var j = i
					i=i-1
					for(;i>-1;i--){
						if(!elements[i].classList.contains('lyteMenuActive') && !elements[i].classList.contains('lyteMenuFiltered') && elements[i].offsetParent ){
							break;
						}
					}
					if(i != -1){
						elements[j].classList.remove('lyteMenuSelection')
						elements[i].classList.add('lyteMenuSelection')
					}							
			}
			else if(kc == 40 && i != elements.length -1){
					var j = i
					i=i+1
					for(;i<elements.length;i++){
						if(!elements[i].classList.contains('lyteMenuActive') && !elements[i].classList.contains('lyteMenuFiltered') && elements[i].offsetParent){
							break;
						}
					}
					if(i != elements.length){
						elements[j].classList.remove('lyteMenuSelection')
						elements[i].classList.add('lyteMenuSelection')
					}
			}
	},
	setFreeze:function(nodeName){
		$L('.lytemenufreezelayer:not(.nogroup)').removeClass('lyteMenuHidden')
		// freeze bound calculation
		var node = $L('.lytemenufreezelayer.left').e[0], rect = nodeName.getBoundingClientRect()
		node.style.height = rect.height +"px"
		node.style.width = rect.left + "px"
		node.style.top = rect.top + "px"
		document.body.style.overflow = 'hidden'
		node = $L('.lytemenufreezelayer.right').e[0]
		node.style.height = rect.height +"px"
		node.style.width = rect.left + "px"
		node.style.top = rect.top + "px"
		node = $L('.lytemenufreezelayer.top').e[0]
		node.style.height = rect.top +"px"
		node = $L('.lytemenufreezelayer.bottom').e[0]
		node.style.height = (window.innerHeight - (rect.top + rect.height)) +"px"
		document.addEventListener('wheel', this.preventEvent);
		document.addEventListener('keydown',this.preventEvent);
	},
	preventEvent : function(event){
		if(!(event.metaKey || event.shiftKey || event.ctrlKey))
			{
				if( event.type == 'wheel' && this == document )
					{
						var activeMenus = $L( 'lyte-menu-box:not(.lyteMenuHidden)' ).e
						for( var i = 0; i < activeMenus.length; i++ ) {
							if( activeMenus[ i ].contains( event.target ) ) {
								var menuBody = $L( ' lyte-menu-body', activeMenus[ i ] ).e[ 0 ]
								if( menuBody.scrollHeight > ( menuBody.offsetHeight +menuBody.scrollTop ) || event.deltaY < 0 ){
									return
								}
							}
						}
						event.stopImmediatePropagation()
					}
				event.preventDefault();
				event.stopPropagation();
			}
	},
	addScrollPos : function(){
		if( !document.menu ) {
			return
		}
		if( event.target != window && (document.menu.childComp.contains(event.target) ) ) {
			return
		}
		var component = document.menu;
		component.setCss.call(component)
		while(component.childMenu)
			{
				component = component.childMenu;
				component.setCss.call(component);
			}
		component.checkForBoundary.call(component, component.childComp);			

	},
	removeFreeze : function(){
		if(!document.menu || ( this.data.ltPropAnimate && this.data.ltPropFreeze ))
			{
				document.removeEventListener('wheel', this.preventEvent)
				document.removeEventListener('keydown',this.preventEvent)
				$L('.lytemenufreezelayer').addClass('lyteMenuHidden')
			}
	},
	setZIndex : function(flag){
		var nodeName = this.$node.element;
		if(nodeName)
			{
				while(nodeName && nodeName.tagName != 'HTML')
					{
						if(nodeName.classList.contains('lyteMenuGroup'))
							{
								if(!flag)
									{
										this.setFreeze.call(this, nodeName)
									}
								else
									{
										this.removeFreeze.call(this)
									}
								break		
							}
						else
							{
								nodeName = nodeName.parentElement;
							}	
					}
				if(nodeName && nodeName.tagName == 'HTML')
					{
						if(flag && !document.menu)
							{
								this.removeFreeze.call(this)
							}
						else 
							{	
								var freezeLayer = $L('.lytemenufreezelayer.nogroup').e[0];
								freezeLayer.classList.remove('lyteMenuHidden');
							}
					}	
			}

	}
});

  var lyteCloseMenu = function(event, element, flag){
	if(document._lyteMenu.preventClick != false || element)
	  	{
	  		if((event && event.button != 2) || element || flag)
				{
					var menus = $L('lyte-menu:not(.lyteMenuClosed)[lyte-rendered]').e;
					for(var i = 0; i < menus.length; i++)
						{
							if(menus[i] != element && !menus[i].component.childComp.classList.contains('lyteMenuHidden'))
								{
									if(flag || (!menus[i].component.childComp.contains(event.target)))
										{
											if( !menus[i].component._hideStarts ){
												var ret = menus[i].component.hideMenu.call(menus[i].component, element ? false : true, event, flag)
												if( ret ){
													menus[i].component._hideStarts = true
												}
											}
										}
								}
						}
				}
		}
    if(event && event.type == 'click')
		{
			document._lyteMenu.preventClick = true;
		}	
};




Lyte.createCustomElement("lyte-menu-item", {
	static : {
		"observedAttributes" : {
			get : function() {
				return ['lyte-shortcut'];
			}
		}
	},
	"attributeChangedCallback" : function(attributeName,oldValue,newValue) {
		if (typeof shortcut == "function") {
        	newValue = JSON.parse(newValue);
        	var newKey = newValue.key;
        	var type = newValue.type;
        	var wait = newValue.wait;
        	if (!oldValue) {
          		oldValue = {};
       		}
        	else{
        		oldValue = JSON.parse(oldValue)
        	}
       		shortcut.push({
          		newKey: newKey,
          		type: type,
          		wait: wait,
          		oldKey: oldValue.key,
          		value: this
        	});
      	}
	}
});


Lyte.Component.register("lyte-messagebox", {
_template:"<template tag-name=\"lyte-messagebox\">\t<template is=\"if\" value=\"{{ltPropShow}}\">\t\t<template case=\"true\"><lyte-wormhole style=\"visibility: hidden\">\t\t\t<template is=\"registerYield\" yield-name=\"lyte-content\">\t\t\t\t<div class=\"{{lyteUiConcatTypeClass(ltPropType,'MessageIcon','lyteMessageBox')}}\">\t\t\t\t\t<span class=\"lyteMessageBoxSymbol\"></span>\t\t\t\t\t<template is=\"if\" value=\"{{lyteUiIfEquals(ltPropMessage,'')}}\">\t\t\t\t\t\t<template case=\"false\"><div>\t\t\t\t\t\t\t<span class=\"lyteMessageBoxContent\">{{ltPropMessage}}</span>\t\t\t\t\t\t</div></template>\t\t\t\t\t</template>\t\t\t\t\t<span class=\"lyteMessageBoxClose\" onclick=\"{{action('closeMessageBox')}}\"></span>\t\t\t\t</div>\t\t\t</template>\t\t</lyte-wormhole></template>\t</template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"registerYield","position":[0,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"false":{"dynamicNodes":[{"type":"text","position":[0,1,0]}]}},"default":{}},{"type":"attr","position":[1,5]}]},{"type":"componentDynamic","position":[0]}]}},"default":{}}],
_observedAttributes :["ltPropType","ltPropShow","ltPropMessage","ltPropDuration","ltPropOffset","ltPropTransition"],
	init : function() {

	},
	data : function(){
		return {
			"ltPropType":Lyte.attr("string",{"default":"success"}),
			"ltPropShow":Lyte.attr("boolean",{"default":false}),
			"ltPropMessage":Lyte.attr("string",{"default":""}),
			"ltPropDuration":Lyte.attr("string",{"default":"2000"}),
			"ltPropOffset":Lyte.attr("object",{"default":null}),
			"ltPropTransition":Lyte.attr("object",{"default":{"animation" : "fadeIn","duration" : "0.2s"}})
		}
	},
	setDuration : function(){
		var durationVal = this.$node.ltProp("duration");
		if(durationVal != ""){
			this.setData("ltPropDuration",durationVal);
		}
	}.observes('ltPropDuration'),
	computeOffsetImpl : function(){        
        // $L.fastdom.measure(function(){
        	var messageEle = this.actualMessageDiv;
	        var messageElePosition = messageEle.getBoundingClientRect();
	        var offsetObj = this.$node.ltProp('offset');
	        //console.log(offsetObj);

	        var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	        var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

	        if(this.$node.ltProp('offset')){
	            if(offsetObj.left === "center" || offsetObj.right === "center" || offsetObj.left == undefined || offsetObj.left == ""){
	                var offLeft = (w - messageElePosition.width)/2;
	                if(offLeft < 0){
	                    offLeft = 20;
	                }
	                offsetObj.left = offLeft + "px";
	            }
	            if(offsetObj.top === "center" || offsetObj.bottom === "center"){
	                var offTop = (h - messageElePosition.height)/2;
	                if(offTop < 0){
	                    offTop = 20;
	                }
	                offsetObj.top = offTop + "px";
	            }            
	            if(offsetObj.right && offsetObj.right !== "center"){
	                if(offsetObj.right.indexOf("%") > -1){
	                    offsetObj.left = w-(messageElePosition.width+(w/parseFloat(offsetObj.right)))+"px";
	                }
	                else{
	                    offsetObj.left = w-(messageElePosition.width+parseFloat(offsetObj.right))+"px";   
	                }
	            }
	            if(offsetObj.bottom && offsetObj.bottom !== "center"){
	                if(offsetObj.bottom.indexOf("%") > -1){
	                    offsetObj.top = h-(messageElePosition.height+(h/parseFloat(offsetObj.bottom)))+"px";
	                }
	                else{
	                    offsetObj.top = h-(messageElePosition.height+parseFloat(offsetObj.bottom))+"px";   
	                }
	            }
	            if(!offsetObj.top){
	            	offsetObj.top = 20;
	            }
	            // $L.fastdom.mutate(function(){
	            	messageEle.style.left = parseFloat(offsetObj.left) + "px";
		            if(this.getData('ltPropTransition').animation != "slideFromTop"){
		            	this.actualMessageDiv.style.visibility = "visible";
		            	messageEle.style.top = parseFloat(offsetObj.top) + "px";
		            }
		            else{
		            	// messageEle.style.transitionDuration = this.getData('ltPropTransition').duration ? this.getData('ltPropTransition').duration : '0.2s';
		            	messageEle.style.top = -1 * messageElePosition.height + "px";
		            	this.childComp.style.visibility = "visible";
		            	this.actualMessageDiv.style.visibility = "visible";
		            	// $L.fastdom.mutate(function(){
		            		messageEle.style.transform = "translate(0px,"+ (parseFloat(offsetObj.top) + messageElePosition.height) +"px)";
		            	// })
		            }
	            // },this);
	        }
	        else{
	            var offsetLeft="",offsetTop="";
	            offsetLeft = (document.body.clientWidth - messageElePosition.width)/2;
	            // $L.fastdom.mutate(function(){
	            	messageEle.style.left = parseFloat(offsetLeft)+"px";
		            if(this.getData('ltPropTransition').animation != "slideFromTop"){
		            	this.actualMessageDiv.style.visibility = "visible";
		            	messageEle.style.top = "20px";
		            }
		            else{
		            	// messageEle.style.transitionDuration = this.getData('ltPropTransition').duration ? this.getData('ltPropTransition').duration : '0.2s';
		            	messageEle.style.top = -1 * messageElePosition.height + "px";
		            	this.childComp.style.visibility = "visible";
		            	this.actualMessageDiv.style.visibility = "visible";
		            	// $L.fastdom.mutate(function(){
		            		messageEle.style.transform = "translate(0px,"+ (messageElePosition.height + 20) +"px)";
		            	// });
		            }
	            // },this);
	        }
        // },this);
    },
    closeMessageBoxFn : function(){
    	//console.log("Here");
		if(this.getMethods("onClose")){
			this.executeMethod("onClose");	
		}
	},
	showToggled : function() {
		if(this.$node.ltProp("show")){
			var duration = parseInt(this.getData("ltPropDuration"));
	        var self = this;
	        this.timeOutId = setTimeout(function(){
	        	//console.log("timeOut");
	        	if(self.getData('ltPropTransition').animation != "slideFromTop"){
	        		self.actualMessageDiv.classList.remove('lyteMessageBoxFadeIn');
	        		self.actualMessageDiv.classList.add('lyteMessageBoxFadeOut');
	        		setTimeout(function(){
		        		self.setData("ltPropShow",false);	
		        	},500);
	        	}
	        	else{
	        		self.actualMessageDiv.style.transform = "";
	        		setTimeout(function(){
		        		self.setData("ltPropShow",false);	
		        	},500);
	        	}
	        	
	        },duration);
		}
		else{
			this.closeMessageBoxFn();
		}
	}.observes('ltPropShow'),
	actions : {
		wormholeDidConnect : function(){
			this.childComp = this.$node.querySelector("lyte-wormhole");
			this.actualMessageDiv = this.childComp.querySelector(".lyteMessageBox");
			this.actualMessageDiv.style.position = "fixed";
			LyteComponent.appendChild(document.body,this.childComp);
			// $L.fastdom.mutate(function(){
				if(this.getData('ltPropTransition').animation == "slideFromTop"){
					this.actualMessageDiv.classList.add('lyteMessageBoxSlideFromTop');
					this.computeOffsetImpl();
				}
				else{
					this.computeOffsetImpl();
					this.actualMessageDiv.classList.add('lyteMessageBoxFadeIn');
					this.childComp.style.visibility = "visible";
				}
			// },this);
			
		},
		closeMessageBox : function(){
			clearTimeout(this.timeOutId);
			var self = this;
			if(self.getData('ltPropTransition').animation != "slideFromTop"){
        		self.actualMessageDiv.classList.remove('lyteMessageBoxFadeIn');
        		self.actualMessageDiv.classList.add('lyteMessageBoxFadeOut');
        		setTimeout(function(){
	        		self.setData("ltPropShow",false);	
	        	},500);
        	}
        	else{
        		self.actualMessageDiv.style.transform = "";
        		setTimeout(function(){
	        		self.setData("ltPropShow",false);	
	        	},200);
        	}
		}
	}
	

});

if(!LytePopup){
    var LytePopup = {
        components:[],
        onEscape : function(evt){
            evt = evt || window.event;
            var isEscape = false;
            if ("key" in evt) {
                isEscape = (evt.key == "Escape" || evt.key == "Esc");
            } else {
                isEscape = (evt.keyCode == 27);
            }
            if (isEscape) {
                LytePopup.closePopup(undefined,true);
            }
        },
        bindDocumentKeydown : function(){
            document.addEventListener('keydown',LytePopup.onEscape,true);
        },
        addPopup : function(component) {
            LytePopup.closePopup();
            var compLengh = LytePopup.components.length;
            if(compLengh>0){
                var prevZIndex = 0;
                var prePopup = '', thisPopup = '', thisFreeze = '';
                if(LytePopup.components[compLengh-1].$node.tagName == "LYTE-MODAL"){
                    prePopup = '.lyteModal';
                }
                else if(LytePopup.components[compLengh-1].$node.tagName == "LYTE-POPOVER"){
                    prePopup = '.lytePopover';
                }   
                else{
                    prePopup = '.alertPopup';
                }

                if(component.$node.tagName == "LYTE-MODAL"){
                    thisPopup = '.lyteModal';
                    thisFreeze = 'lyte-modal-freeze';
                }
                else if(component.$node.tagName == "LYTE-POPOVER"){
                    thisPopup = '.lytePopover';
                    thisFreeze = '.lytePopoverFreeze';
                }
                else{
                    thisPopup = '.alertPopup';
                    thisFreeze = '.alertFreezeLayer';
                }
                var node = LytePopup.components[compLengh-1].childComp.querySelector(prePopup);
                prevZIndex = Number(document.defaultView.getComputedStyle(node,null).getPropertyValue('z-index'));
                component.childComp.querySelector(thisPopup).style.zIndex = prevZIndex+2;
                if(component.$node.ltProp('freeze') && component.childComp.querySelector(thisFreeze)){
                    component.childComp.querySelector(thisFreeze).style.zIndex = prevZIndex+1;
                }
            }
            LytePopup.components[compLengh] = component;
        },
        closePopup : function(component,fromEscape){
            if(fromEscape){
                var lastPop = LytePopup.components[LytePopup.components.length-1];
                if(lastPop && lastPop.$node.ltProp("closeOnEscape")){
                    lastPop.$node.ltProp("show",false);
                }
            }
            else{
                if(component){
                    LytePopup.components.splice(LytePopup.components.indexOf(component),1);
                }
                else{
                    for(var i=LytePopup.components.length-1;i>=0;i--){
                        if(LytePopup.components[i].$node && !LytePopup.components[i].$node.ltProp("allowMultiple")){
                            LytePopup.components[i].$node.ltProp("show",false);
                        }
                    }
                }   
            }  
        }   
    };
    LytePopup.bindDocumentKeydown();
};

Lyte.Component.register("lyte-modal",{
_template:"<template tag-name=\"lyte-modal\">\t<template is=\"if\" value=\"{{expHandlers(ltPropBindToBody,'&amp;&amp;',expHandlers(ltPropReRenderModal,'!'))}}\"><template case=\"true\">\t\t<lyte-wormhole case=\"true\" style=\"{{if(ltPropShowCopy,'visibility:visible','visibility:hidden')}}\">\t\t\t<template is=\"registerYield\" yield-name=\"lyte-content\">\t\t\t\t<div class=\"modalWrapper {{ltPropWrapperClass}}\">\t\t\t\t\t<div class=\"lyteModal\">\t\t\t\t\t\t<template is=\"if\" value=\"{{ltPropShowCloseButton}}\">\t\t\t\t\t\t\t<template case=\"true\"><span class=\"lyteModalClose\" onclick=\"{{action('close')}}\"></span></template>\t\t\t\t\t\t</template>\t\t\t\t\t\t<lyte-yield yield-name=\"modal\"></lyte-yield>\t\t\t\t\t</div>\t\t\t\t\t<template is=\"if\" value=\"{{ltPropFreeze}}\">\t\t\t\t\t\t<template case=\"true\"><lyte-modal-freeze></lyte-modal-freeze></template>\t\t\t\t\t</template>\t\t\t\t</div>\t\t\t</template>\t\t</lyte-wormhole>\t</template></template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropShowCopy","'visibility:visible'","'visibility:hidden'"]}}}},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"if","position":[1,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}},{"type":"insertYield","position":[1,1,3]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"componentDynamic","position":[0]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropShow","ltPropFreeze","ltPropShowCloseButton","ltPropCloseOnEscape","ltPropTransition","ltPropOffset","ltPropDimmer","ltPropDraggable","ltPropAllowMultiple","ltPropScrollable","ltPropMaxHeight","ltPropMaxWidth","ltPropWidth","ltPropHeight","ltPropWrapperClass","ltPropHeading","ltPropButtons","ltPropButtonPosition","ltPropBindToBody","ltPropShowCopy","ltPropReRenderModal","first","resizeCalled","prevHeight","returnedFalse"],
    data: function(){
        return {
            //config from callee
            "ltPropShow":Lyte.attr("boolean",{"default": false}),
            "ltPropFreeze":Lyte.attr("boolean",{"default": true}),
            "ltPropShowCloseButton":Lyte.attr("boolean",{"default": true}),
            "ltPropCloseOnEscape":Lyte.attr("boolean",{"default": true}),
            "ltPropTransition":Lyte.attr("object",{"default":{"animation":"slideFromTop","duration":"0.5"}}),
            "ltPropOffset":Lyte.attr("object",{"default":{"top":"center","left":"center"}}),
            "ltPropDimmer":Lyte.attr("object",{"default":{"color":"black","opacity":"0.4"}}),
            "ltPropDraggable":Lyte.attr("boolean",{"default": false}),
            "ltPropAllowMultiple":Lyte.attr("boolean",{"default": false}),
            "ltPropScrollable":Lyte.attr("boolean",{"default": false}),
            "ltPropMaxHeight":Lyte.attr("string",{"default":""}),
            "ltPropMaxWidth":Lyte.attr("string",{"default":""}),
            "ltPropWidth":Lyte.attr("string",{"default":""}),
            "ltPropHeight":Lyte.attr("string",{"default":"auto"}),
            "ltPropWrapperClass":Lyte.attr("string",{"default":""}),

            "ltPropHeading":Lyte.attr("string",{"default":""}),
            "ltPropButtons":Lyte.attr("array",{"default":[{"type":"accept","text":"Ok"}]}),
            "ltPropButtonPosition":Lyte.attr("string",{"default":"right"}),
            "ltPropBindToBody":Lyte.attr("boolean",{"default":false}),

            //local properties
            "ltPropShowCopy":Lyte.attr("boolean",{"default": false}),
            "ltPropReRenderModal":Lyte.attr("boolean",{"default":false}),
            "first":Lyte.attr("boolean",{"default":true}),
            'resizeCalled' : Lyte.attr("boolean",{"default":false}),
            "prevHeight" : Lyte.attr("number"),
            "returnedFalse" : Lyte.attr("boolean",{"default" : false})
        }
    },
    addDragHandler : function(){
        var dragHeader = this.actualModalDiv.querySelector('lyte-modal-header');
        if(dragHeader){
            dragHeader.parentEle = this;
            if(this.$node.ltProp("draggable")){
                dragHeader.addEventListener('mousedown',this.handleMove,true);
                dragHeader.classList.add('draggable');
            }
            else{
                dragHeader.removeEventListener('mousedown',this.handleMove,true);
                dragHeader.classList.remove('draggable');
            }
        }
        else{
            console.warn("This modal is not draggable because it has no header");
            this.$node.ltProp("draggable",false);
        }
    },
    handleMove : function(e){
        var drag = e.currentTarget.parentEle.actualModalDiv;
        LytePopup.node=drag;
        if(e.currentTarget.parentEle.getData('ltPropTransition').animation == "fadeIn"){
            LytePopup.xPos=e.clientX-this.getBoundingClientRect().left;
            LytePopup.yPos=e.clientY-this.getBoundingClientRect().top;
        }
        else{
            LytePopup.xPos=e.clientX;
            LytePopup.yPos=e.clientY;
        }
        var elePos = drag.getBoundingClientRect();
        drag.style.transitionDuration = "0s";
        document.body.addEventListener('mousemove',e.currentTarget.parentEle.handleDrag,true);
        document.body.addEventListener('mouseup',e.currentTarget.parentEle.stopDrag,true);
    },
    handleDrag : function(e){
        var drag = LytePopup.node;
        if(!LytePopup.node){
            return;
        }
        if(LytePopup.node.closest('lyte-wormhole')._callee.component.getData('ltPropTransition').animation == "fadeIn"){
            drag.style.left=(e.clientX-LytePopup.xPos)+'px';
            drag.style.top=(e.clientY-LytePopup.yPos)+'px';
        }
        else{
            var matrix = LytePopup.node.closest('lyte-wormhole')._callee.component.transform,
                x = matrix.x+(e.clientX-LytePopup.xPos),
                y = matrix.y+(e.clientY-LytePopup.yPos);
            drag.style.transform = "translate("+x+"px, "+y+"px)";
        }
        window.getSelection().removeAllRanges();
    },
    stopDrag : function(e){
        var targetElem = e.target;
        while(targetElem && targetElem !== document){
            if(targetElem.parentEle){
                this.removeEventListener('mousemove',targetElem.parentEle.handleDrag,true);
                this.removeEventListener('mouseup',targetElem.parentEle.stopDrag,true);
                break;
            }
            targetElem = targetElem.parentElement ? targetElem.parentElement : document;
        }
        if(LytePopup.node){
            var comp = LytePopup.node.closest('lyte-wormhole')._callee.component;
            LytePopup.node.style.transitionDuration = comp.getData('ltPropTransition').duration;
            if(comp.getData('ltPropTransition').animation != "fadeIn"){
                var matrix = new WebKitCSSMatrix(window.getComputedStyle(comp.actualModalDiv).transform);
                comp.transform = {'x' : matrix.m41, 'y' : matrix.m42};
            }
            LytePopup.node = null;
        }
    },      
    closeAlertFn : function(){
        this.$node.ltProp("show",false);
        if(this.getMethods("onClose")){
            this.executeMethod("onClose");  
        }
    },
    showToggled : function(){
        // debugger
        if(this.getData('returnedFalse')){
            this.setData('returnedFalse',false);
            return;
        }
        if(this.$node.ltProp("reRenderModal")){
            if(this.$node.ltProp("show")){
                this.$node.ltProp({"showCopy":false, "show":false});
            }
            this.$node.ltProp("reRenderModal",false);
        }
        if(this.$node.ltProp("show") && !this.$node.ltProp("showCopy")){
            this.$node.ltProp("bindToBody",true);
            var self = this;
            setTimeout(function(){
                self.onBeforeShowHandling();
            },0);
            
        }
        else{
            if(this.$node.ltProp("showCopy")){
                var self = this;
                setTimeout(function(){
                    self.onBeforeCloseHandling();
                },0);
            }
        }
    }.observes("ltPropShow","ltPropReRenderModal").on('didConnect'),
    changeShow : function(){
        if(!this.getData('ltPropBindToBody')){
            this.actualModalDiv = null;
            this.childComp = null;
            if(this.getData('ltPropShow')){
                this.setData('ltPropShow',false);
            }
        }
    }.observes("ltPropBindToBody"),
    updateScrollHandling : function(){    //It sets the height and width of the modal
        if(!this.$node.ltProp("freeze")){
            this.$node.ltProp("scrollable",true);
        }
        var modalElem = this.actualModalDiv;
        var oldHeight, oldWidth, newHeight, newWidth,
        contentNode = modalElem.querySelector("lyte-modal-content");
        contentNode = contentNode ? contentNode : modalElem;
        modalElem.style.maxWidth = "";
        modalElem.style.maxHeight = "";
        modalElem.style.height = this.$node.ltProp("height")?this.$node.ltProp("height"):"auto";
        modalElem.style.width = this.$node.ltProp("width")?this.$node.ltProp("width"):"auto"; 
        // console.log(this.$node.ltProp("width"));
        /*------------------------------ MEASURE STARTS --------------------------*/
        $L.fastdom.measure(function() {    //Measures the initial height and width
            var modalElemOffset = modalElem.getBoundingClientRect();
            /*IF maxwidth or maxheigth given as a percentage then to calculate the actual width or height 
                                we need the modalElements parent element's width and height*/
            var modalParentOff = modalElem.parentElement.getBoundingClientRect();
            var cs = window.getComputedStyle(modalElem);
            var borderDimensionY = ((cs.borderTop ? parseFloat(cs.borderTop) : 0) +
                                     (cs.borderBottom ? parseFloat(cs.borderBottom) : 0));
            var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
            // console.log(modalElemOffset);
            /*------------------------------ MUTATE STARTS --------------------------*/
            $L.fastdom.mutate(function(){    //Checks for the max height and width provided by the user and sets the modal height and width based on that
                if(this.$node.ltProp("maxHeight")){
                    this.childComp.querySelector(".modalWrapper").classList.add("scrollable");
                    this.$node.ltProp("scrollable",true);
                    oldHeight = modalElemOffset.height - borderDimensionY;
                    var newH = this.$node.ltProp("maxHeight").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp("maxHeight"))/100) * modalParentOff.height) : parseFloat(this.$node.ltProp("maxHeight"));
                    modalElem.style.height = newH + "px";
                    newHeight = newH - borderDimensionY;
                }
                else{
                    oldHeight = modalElemOffset.height - borderDimensionY;
                    newHeight = h-40;
                }

                if(this.$node.ltProp("maxWidth")){
                    this.$node.ltProp("scrollable",true);
                    oldWidth = modalElemOffset.width /*- borderDimensionX*/;
                    newWidth = this.$node.ltProp("maxWidth").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp("maxWidth"))/100) * modalParentOff.width) : parseFloat(this.$node.ltProp("maxWidth"));
                    modalElem.style.width = newWidth + "px";
                    if(oldWidth < newWidth){
                        modalElem.style.width = oldWidth+"px";
                        newWidth = oldWidth;
                    }
                    modalElem.style.overflowX = "auto";
                }
                else{
                    newWidth = modalElemOffset.width /*- borderDimensionX*/;
                }
            

                if(this.$node.ltProp("scrollable")){
                    var modalheader = this.actualModalDiv.querySelector("lyte-modal-header"), modalFooter = this.actualModalDiv.querySelector("lyte-modal-footer");
                    var modalHOff = null,modalFOff = null;
                    /*------------------------------ MEASURE STARTS --------------------------*/
                    $L.fastdom.measure(function(){   //measures the content haeder, content and footer dimensions
                        if(modalheader){
                            modalHOff = modalheader.getBoundingClientRect();
                        }
                        if(modalFooter){
                            modalFOff = modalFooter.getBoundingClientRect();
                        }
                        var contentNodeOffset = contentNode.getBoundingClientRect();
                        var diff = 0;
                        var modalHeight = modalElem.getBoundingClientRect().height;
                        if(this.getData('resizeCalled')){
                            //to get the difference between previous height and current height
                            if(this.getData('prevHeight') < modalHeight){
                                diff = modalHeight - this.getData('prevHeight');
                            }
                            this.setData('resizeCalled',false);
                        }
                        this.setData('prevHeight',modalHeight);
                        /*------------------------------ MUTATE STARTS --------------------------*/
                        $L.fastdom.mutate(function(){   //Sets the final height and width of the modal
                            var newH = (newHeight - ((modalHOff ? modalHOff.height : 0)+ (modalFOff ? modalFOff.height : 0)));
                            contentNode.style.maxHeight = (newH > 0 ? newH : 50) + diff +"px";
                            contentNode.style.overflowY = "auto";
                            if(this.getData('first')){
                                contentNode.style.height = (oldHeight - ((modalHOff ? modalHOff.height : 0)+ (modalFOff ? modalFOff.height : 0))) +"px";
                            }
                            modalElem.style.width = this.$node.ltProp("width")?this.$node.ltProp("width"):"auto";
                            this.actualModalDiv.style.maxWidth = newWidth > 0 ? (newWidth +"px"):("70%");
                            modalElem = null;
                            contentNode = null;
                            modalheader = null;
                            modalFooter = null;
                            this.computeOffsetImpl();
                        },this);
                        /*------------------------------ MUTATE ENDS --------------------------*/
                    },this);
                    /*------------------------------ MEASURE ENDS --------------------------*/
                }
                else{
                    this.childComp.querySelector(".modalWrapper").classList.remove("scrollable");
                    modalElem = null;
                    contentNode = null;
                    this.computeOffsetImpl();
                }

                if (!this.$node.ltProp("freeze")) { 
                    this.childComp.querySelector(".modalWrapper").style.position = "static";
                }
                else{
                    this.childComp.querySelector(".modalWrapper").style.position = "fixed";
                }
            },this);
            /*------------------------------ MUTATE ENDS --------------------------*/
        },this);
        /*------------------------------ MEASURE ENDS --------------------------*/
        
        
    },
    scrollHandling : function(){
        if(!this.getData('ltPropShow')){
            return;
        }
        this.updateScrollHandling();
    }.observes("ltPropWidth","ltPropMaxWidth","ltPropHeight","ltPropMaxHeight"),
    callOnShow: function(){
        if(this.getMethods("onShow")){
            this.executeMethod("onShow",this); 
        }
    },
    callOnResize : function(){
        if(this.getMethods("onResize")){
            this.executeMethod("onResize");
        }
    },

    enableTransform : function(val,pos){
        this.$node.ltProp('showCopy',true);
        if(pos == 'x'){
            this.actualModalDiv.style.transform = "translate("+val+"px,0px)";
            this.transform = {'x' : val, 'y' : 0};
        }
        if(pos == 'y'){
            this.actualModalDiv.style.transform = "translate(0px,"+val+"px)";
            this.transform = {'x' : 0, 'y' : val};
        }
    },

    computeOffsetImplOnResize : function(){
        /*------------------------------ MEASURE STARTS --------------------------*/
         $L.fastdom.measure(function() {   
            var modalEle = this.actualModalDiv;
                modalElePosition = modalEle.getBoundingClientRect();
                w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
                h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
                prevWinH = this.getData('prevWinH'),
                prevWinW = this.getData('prevWinW'),
                transform = this.transform /*new WebKitCSSMatrix(window.getComputedStyle(modalEle).transform)*/,
                newTop = null,
                newLeft = null,
                offsetObj = this.getData('ltPropOffset');
            
            if(this.getData('ltPropTransition').animation === "fadeIn"){
                if(w < prevWinW){
                    if((offsetObj.left && offsetObj.left == "center") || (offsetObj.right && offsetObj.right == "center")){
                        newLeft = modalElePosition.left - ((prevWinW - w) / 2);
                    }
                    else if(offsetObj.right){
                        newLeft = modalElePosition.left - (prevWinW - w);
                    }
                    else if(offsetObj.left){
                        newLeft = modalElePosition.left;
                    }
                }
                if(w > prevWinW){
                    if((offsetObj.left && offsetObj.left == "center") || (offsetObj.right && offsetObj.right == "center")){
                        newLeft = modalElePosition.left + ((w - prevWinW) / 2);
                    }
                    else if(offsetObj.right){
                        newLeft = modalElePosition.left + (w - prevWinW);
                    }
                    else if(offsetObj.left){
                        newLeft = modalElePosition.left;
                    }
                }
                if(h < prevWinH){
                    if((offsetObj.top && offsetObj.top == "center") || (offsetObj.bottom && offsetObj.bottom == "center")){
                        newTop = modalElePosition.top - ((prevWinH - h) / 2);
                    }
                    else if(offsetObj.bottom){
                        newTop = modalElePosition.top - (prevWinH - h);
                    }
                    else if(offsetObj.top){
                        newTop = modalElePosition.top;
                    }
                }
                if(h > prevWinH){
                    if((offsetObj.top && offsetObj.top == "center") || (offsetObj.bottom && offsetObj.bottom == "center")){
                        newTop = modalElePosition.top + ((h - prevWinH) / 2);
                    }
                    else if(offsetObj.bottom && offsetObj.bottom != "center"){
                        newTop = modalElePosition.top + (h - prevWinH);
                    }
                    else if(offsetObj.top && offsetObj.top != "center"){
                        newTop = modalElePosition.top;
                    }
                }
                $L.fastdom.mutate(function() {
                    if(newTop){
                        modalEle.style.top = newTop + "px";
                    }
                    if(newLeft){
                        modalEle.style.left = newLeft + "px";
                    }
                    
                },this);
            }
            else{
                if(w < prevWinW){
                    if((offsetObj.left && offsetObj.left == "center") || (offsetObj.right && offsetObj.right == "center")){
                        newLeft = transform.x - ((prevWinW - w) / 2);
                    }
                    else if(offsetObj.right){
                        newLeft = transform.x - (prevWinW - w);
                    }
                    else if(offsetObj.left){
                        newLeft = transform.x;
                    }
                    this.transform.x = newLeft;
                }
                if(w > prevWinW){
                    if((offsetObj.left && offsetObj.left == "center") || (offsetObj.right && offsetObj.right == "center")){
                        newLeft = transform.x + ((w - prevWinW) / 2);
                    }
                    else if(offsetObj.right){
                        newLeft = transform.x + (w - prevWinW);
                    }
                    else if(offsetObj.left){
                        newLeft = transform.x;
                    }
                    this.transform.x = newLeft;
                }
                if(h < prevWinH){
                    if((offsetObj.top && offsetObj.top == "center") || (offsetObj.bottom && offsetObj.bottom == "center")){
                        newTop = transform.y - ((prevWinH - h) / 2);
                    }
                    else if(offsetObj.bottom){
                        newTop = transform.y - (prevWinH - h);
                    }
                    else if(offsetObj.top){
                        newTop = transform.y;
                    }
                    
                    this.transform.y = newTop;
                }
                if(h > prevWinH){
                    if((offsetObj.top && offsetObj.top == "center") || (offsetObj.bottom && offsetObj.bottom == "center")){
                        newTop = transform.y + ((h - prevWinH) / 2);
                    }
                    else if(offsetObj.bottom && offsetObj.bottom != "center"){
                        newTop = transform.y + (h - prevWinH);
                    }
                    else if(offsetObj.top && offsetObj.top != "center"){
                        newTop = transform.y;
                    }
                    this.transform.y = newTop;
                }
                $L.fastdom.mutate(function() {
                    modalEle.style.transitionDuration = "0s";
                    if(this.getData('ltPropTransition').animation === "slideFromTop" || this.getData('ltPropTransition').animation === "slideFromBottom"){
                        if(w < prevWinW){
                            modalEle.style.left = modalElePosition.left - ((prevWinW - w)/2) + "px";
                        }
                        if(w > prevWinW){
                            modalEle.style.left = modalElePosition.left + ((w - prevWinW)/2) + "px";
                        }
                        modalEle.style.transform = "translate(0px,"+this.transform.y+"px)";
                    }
                    else if(this.getData('ltPropTransition').animation === "slideFromLeft" || this.getData('ltPropTransition').animation === "slideFromRight"){
                        if(h < prevWinH){
                            modalEle.style.top = modalElePosition.top - ((prevWinH - h)/2) + "px";
                        }
                        if(h > prevWinH){
                            modalEle.style.top = modalElePosition.top + ((h - prevWinH)/2) + "px";
                        }
                        modalEle.style.transform = "translate("+this.transform.x+"px,0px)";
                    }
                },this);
            }
            this.setData('prevWinH',h);
            this.setData('prevWinW',w);
        },this);
        /*------------------------------ MEASURE ENDS --------------------------*/
        modalEle = null;
    },

    computeOffsetImpl : function(){     //sets the left and top of the modal based on user provided values   
        var _this = this.nodeName && this.nodeName === "LYTE-MODAL" ? this.component : this;
        /*------------------------------ MEASURE STARTS --------------------------*/
         $L.fastdom.measure(function() {   
            var modalEle = _this.actualModalDiv;
            var offsetObj = Lyte.deepCopyObject(_this.$node.ltProp('offset'));
            var modalElePosition = modalEle.getBoundingClientRect();
            var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
            var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
             // $L.fastdom.mutate(() => {
                modalEle.style.transitionDuration = _this.$node.ltProp("transition").duration+"s";
            // },this);
            _this.setData('prevWinH',h);
            _this.setData('prevWinW',w);
            if(offsetObj){
                if(offsetObj.left === "center" || offsetObj.right === "center"){
                    var offLeft = (w - modalElePosition.width)/2;
                    if(offLeft < 0){
                        offLeft = 20;
                    }
                    offsetObj.left = offLeft + "px";
                }
                if(offsetObj.top === "center" || offsetObj.bottom === "center"){
                    var offTop = (h - modalElePosition.height)/2;
                    if(offTop < 0){
                        offTop = 20;
                    }
                    offsetObj.top = offTop + "px";
                }            
                if(offsetObj.right && offsetObj.right !== "center"){
                    if(offsetObj.right.indexOf("%") > -1){
                        offsetObj.left = w-(modalElePosition.width+(w/parseFloat(offsetObj.right)))+"px";
                    }
                    else{
                        offsetObj.left = w-(modalElePosition.width+parseFloat(offsetObj.right))+"px";   
                    }
                }
                if(offsetObj.bottom && offsetObj.bottom !== "center"){
                    if(offsetObj.bottom.indexOf("%") > -1){
                        offsetObj.top = h-(modalElePosition.height+(h/parseFloat(offsetObj.bottom)))+"px";
                    }
                    else{
                        offsetObj.top = h-(modalElePosition.height+parseFloat(offsetObj.bottom))+"px";   
                    }
                }
                if(offsetObj.left === ""){
                    offsetObj.left = ((w - modalElePosition.width)/2) + "px";
                }
                if(offsetObj.top === ""){
                    offsetObj.top = ((h - modalElePosition.height)/2) + "px";
                } 
                /*------------------------------ MUTATE STARTS --------------------------*/
                 $L.fastdom.mutate(function() {
                    if(_this.getData('ltPropTransition').animation == "slideFromTop"){
                        modalEle.style.left = offsetObj.left;
                        modalEle.style.top = (-1 * modalElePosition.height) + "px";
                        _this.enableTransform(parseInt(offsetObj.top)+modalElePosition.height,"y");
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromBottom"){
                        modalEle.style.left = offsetObj.left;
                        modalEle.style.top = h+1 + "px";
                        _this.enableTransform(-1 * (h - parseInt(offsetObj.top) + 1),"y");
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromLeft"){
                        modalEle.style.top = offsetObj.top;
                        modalEle.style.left = (-1 * modalElePosition.width) + "px";
                        _this.enableTransform(parseInt(offsetObj.left)+modalElePosition.width,'x');
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromRight"){
                        modalEle.style.top = offsetObj.top;
                        modalEle.style.left = w + 1 + "px";
                        _this.enableTransform(-1 * (w - parseInt(offsetObj.left) + 1),'x');
                    }
                    else if(_this.getData('ltPropTransition').animation == "fadeIn"){
                        _this.$node.ltProp('showCopy',true);
                        modalEle.style.left = offsetObj.left;
                        modalEle.style.top = offsetObj.top;
                    }
                    if(_this.getData('first')){
                        _this.callOnShow();
                        _this.setData("first",false);
                    }
                },_this);
                /*------------------------------ MUTATE ENDS --------------------------*/
            }
            else{
                var offsetLeft="",offsetTop="";
                offsetLeft = ((w - modalElePosition.width)/2);
                offsetTop = ((h - modalElePosition.height)/2);
                if(!_this.$node.ltProp("scrollable")){
                    if(offsetLeft < 0){
                        offsetLeft = 20;
                    }
                    if(offsetTop < 0){
                        offsetTop = 20;
                    }
                }
                /*------------------------------ MUTATE STARTS --------------------------*/
                 $L.fastdom.mutate(function() {
                    if(_this.getData('ltPropTransition').animation == "slideFromTop"){
                        modalEle.style.left = offsetLeft + "px";
                        modalEle.style.top = (-1 * modalElePosition.height) + "px";
                        _this.enableTransform(parseInt(offsetTop)+modalElePosition.height,"y");
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromBottom"){
                        modalEle.style.left = offsetLeft + "px";
                        modalEle.style.top = h+1 + "px";
                        _this.enableTransform(-1 * (parseInt(offsetTop) + modalElePosition.height + 1),"y");
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromLeft"){
                        modalEle.style.top = offsetTop + "px";
                        modalEle.style.left = (-1 * modalElePosition.width) + "px";
                        _this.enableTransform(parseInt(offsetLeft)+modalElePosition.width,'x');
                    }
                    else if(_this.getData('ltPropTransition').animation == "slideFromRight"){
                        modalEle.style.top = offsetTop + "px";
                        _modalEle.style.left = w + 1 + "px";
                        this.enableTransform(-1 * (parseInt(offsetLeft) + modalElePosition.width + 1),'x');
                    }
                    else if(_this.getData('ltPropTransition').animation == "fadeIn"){
                        _this.$node.ltProp('showCopy',true);
                        modalEle.style.left = offsetLeft + "px";
                        modalEle.style.top = offsetTop + "px";
                    }
                    if(_this.getData('first')){
                        _this.callOnShow();
                        _this.setData("first",false);
                    }
                },_this);
                /*------------------------------ MUTATE ENDS --------------------------*/
            }
            if(_this.$node.ltProp("transition").animation == "fadeIn"){
                 // $L.fastdom.mutate(() => {
                    modalEle.style.opacity = 1;
                // });
            }
            else{
                 // $L.fastdom.mutate(() => {
                    modalEle.style.opacity = "";
                // });
            }
            if(_this.$node.ltProp("freeze")){
                 // $L.fastdom.mutate(() => {
                    document.body.classList.add('bodyWrapper');
                // });    
            }
        },_this);
        /*------------------------------ MEASURE ENDS --------------------------*/
        modalEle = null;
    },
    onBeforeCloseHandling : function(){
        var result = true;
        var w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
        var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
        if(this.getMethods("onBeforeClose")){
            result = this.executeMethod("onBeforeClose",this); 
        }
        if(result === undefined || result){
            var animDur = parseFloat(this.$node.ltProp('transition').duration) * 1000;
            var self = this;
            setTimeout(function(){
                self.$node.ltProp({"showCopy":false,"show":false});
                LytePopup.closePopup(self);
                if(self.getMethods("onClose")){
                    self.executeMethod("onClose");  
                }
            },animDur);
            var modalEle = this.actualModalDiv;
            var modalElemOffset;
            /*------------------------------ MEASURE STARTS --------------------------*/
            $L.fastdom.measure(function(){
                modalElemOffset = modalEle.getBoundingClientRect();
            });
            /*------------------------------ MEASURE ENDS --------------------------*/
            var val = "";
            /*------------------------------ MUTATE STARTS --------------------------*/
            $L.fastdom.mutate(function(){
                modalEle.style.transitionDuration = this.$node.ltProp("transition").duration+"s";
                
                if(this.getData('ltPropTransition').animation == "slideFromTop"){
                    modalEle.style.transform = "translateY(-100%)";
                }
                else if(this.getData('ltPropTransition').animation == "slideFromBottom"){
                    modalEle.style.transform = "translateY(100%)";
                }
                else if(this.getData('ltPropTransition').animation == "slideFromLeft"){
                    modalEle.style.transform = "translateX(-100%)";
                }
                else if(this.getData('ltPropTransition').animation == "slideFromRight"){
                    modalEle.style.transform = "translateX(100%)";
                }
                else{
                    modalEle.style.opacity = 0;
                }
            },this);
            /*------------------------------ MUTATE ENDS --------------------------*/
            // switch(this.$node.ltProp("transition").animation){
            //     case "slideFromTop":
            //         /*------------------------------ MUTATE STARTS --------------------------*/
            //         $L.fastdom.mutate(function(){
            //             modalEle.style.top = "-"+(modalEle.getBoundingClientRect().height)+"px";
            //         });
            //         /*------------------------------ MUTATE ENDS --------------------------*/
            //         break;
            //     case "slideFromBottom":
            //         modalEle.style.top = h+"px";
            //         break;
            //     case "slideFromLeft":
            //         /*------------------------------ MUTATE STARTS --------------------------*/
            //         $L.fastdom.mutate(function(){
            //             modalEle.style.left = "-"+(modalEle.getBoundingClientRect().width)+"px";
            //         });
            //         /*------------------------------ MUTATE ENDS --------------------------*/
            //         break;
            //     case "slideFromRight":
            //         modalEle.style.left = w+"px";
            //         break;
            //     case "fadeIn":
            //         modalEle.style.opacity = 0;
            //         break;
            // }
            /*------------------------------ MUTATE STARTS --------------------------*/
            $L.fastdom.mutate(function(){
                modalEle = null;
            });
            /*------------------------------ MUTATE ENDS --------------------------*/
            
            modalEle.classList.remove('lyteModalFromTop','lyteModalFromBottom','lyteModalFromLeft','lyteModalFromRight','lyteModalFadeIn');
            if(this.$node.ltProp('freeze') && this.childComp.querySelector("lyte-modal-freeze")){
                this.childComp.querySelector("lyte-modal-freeze").style.opacity = 0;
            }
            this.setData("first",true);
            this.childComp.querySelector(".modalWrapper").style.position = "fixed";
            document.body.classList.remove('bodyWrapper');
            this.$node.alignModal = null;
        }
        else{
            this.setData('returnedFalse',true);
            this.$node.ltProp('show',true);
        }
    },
    onBeforeShowHandling : function(){
        var result = true;
        if(this.getMethods("onBeforeShow")){
            result = this.executeMethod("onBeforeShow") ; 
        }
        if(result === undefined || result){
            this.addDragHandler();
            this.updateScrollHandling();
            var modalEle = this.actualModalDiv;
            var val = "";
            modalEle.style.transitionDuration = this.$node.ltProp("transition").duration+"s";
            var classVal = "lyteModalFrom";
            var modalStyle = this.actualModalDiv.style;
            /*------------------------------ MEASURE STARTS --------------------------*/
            $L.fastdom.measure(function(){   //Measures modal's dimensions for transition effect
                // debugger
                var modalElemOffset = this.actualModalDiv.getBoundingClientRect();
            
                // switch(this.$node.ltProp("transition").animation){
                //     case "slideFromTop":
                //         /*------------------------------ MUTATE STARTS --------------------------*/
                //         $L.fastdom.mutate(function(){
                //             modalStyle.top = "-"+(modalElemOffset.height)+"px";
                //         });
                //         /*------------------------------ MUTATE ENDS --------------------------*/
                //         classVal += "Top";
                //         break;
                //     case "slideFromBottom":
                //         modalStyle.top = "100%";
                //         classVal += "Bottom";
                //         break;
                //     case "slideFromLeft":
                //         /*------------------------------ MUTATE STARTS --------------------------*/
                //         $L.fastdom.mutate(function(){
                //             modalStyle.left = "-"+(modalElemOffset.width)+"px";
                //         });
                //         /*------------------------------ MUTATE ENDS --------------------------*/
                //         classVal += "Left";
                //         break;
                //     case "slideFromRight":
                //         modalStyle.left = "100%";
                //         classVal += "Right";
                //         break;
                //     case "fadeIn":
                //         classVal = "lyteModalFadeIn";
                //         break;
                // }
                /*------------------------------ MUTATE STARTS --------------------------*/
                $L.fastdom.mutate(function(){
                    this.actualModalDiv.classList.add(classVal);
                    modalEle = null;
                },this);
                /*------------------------------ MUTATE ENDS --------------------------*/
            },this);
            /*------------------------------ MEASURE ENDS --------------------------*/
            
            var self = this;
            setTimeout(function(){
                // self.setInitialDimensions();
                // self.computeOffsetImpl();
                /*------------------------------ MUTATE STARTS --------------------------*/
                 $L.fastdom.mutate(function(){
                    // self.$node.ltProp('showCopy',true);
                    // self.childComp.style.visibility = "visible";
                    if(self.$node.ltProp('freeze')){
                        var freezeStyle = self.childComp.querySelector("lyte-modal-freeze").style;
                        freezeStyle.opacity = self.getData('ltPropDimmer').opacity;
                        freezeStyle.background = self.getData('ltPropDimmer').color;
                        if(self.getData('ltPropTransition').duration){
                            freezeStyle.transitionDuration = self.getData('ltPropTransition').duration + "s";
                        }
                    }
                },self);
                /*------------------------------ MUTATE ENDS --------------------------*/
            },0);

            LytePopup.addPopup(this);
            this.$node.alignModal = this.computeOffsetImpl;
        }
        else{
            this.setData('returnedFalse',true);
            this.$node.ltProp({"showCopy":false,"show":false});
        }
    },
    didDestroy : function(){
        if(this.childComp){
            this.childComp.remove();    
        }
        LytePopup.components = [];
    },
    actions: {
        wormholeDidConnect : function(){
            this.childComp = this.$node.querySelector('lyte-wormhole');
            this.actualModalDiv = this.childComp.querySelector(".lyteModal");
            // this.addDragHandler();
            var anim = this.$node.ltProp('transition');
            LyteComponent.appendChild(document.body,this.childComp);
            // this.updateScrollHandling();
        },
        close : function(){
           this.$node.ltProp("show",false);
        }
    }
});

if (document.readyState === "complete" || document.readyState === "interactive"){
    addModalEvent();
}
else{
    document.addEventListener("DOMContentLoaded", function(event){
        addModalEvent(event);
    });
}
function addModalEvent(event){
    window.addEventListener('resize',function(event){
        if(LytePopup._lyteModalRTId){
            // console.log(LytePopup._lyteModalRTId);
            clearTimeout(LytePopup._lyteModalRTId);
            LytePopup._lyteModalRTId = false;
        }
        LytePopup._lyteModalRTId = setTimeout(function(){
            for(var i = LytePopup.components.length - 1 ; i >= 0 ; i--){
                if(LytePopup.components[i].$node && LytePopup.components[i].$node.nodeName == "LYTE-MODAL" && LytePopup.components[i].childComp.style.visibility == "visible" && LytePopup.components[i].childComp.querySelector('.lyteModal')){
                    LytePopup.components[i].$node.component.setData('resizeCalled',true);
                    LytePopup.components[i].$node.component.updateScrollHandling();
                    LytePopup.components[i].$node.component.computeOffsetImplOnResize();
                    LytePopup.components[i].$node.component.callOnResize();
                }
            }
            LytePopup._lyteModalRTId = false;
        },100);
    },true);
}
;



Lyte.Component.register( 'lyte-nav', {
_template:"<template tag-name=\"lyte-nav\"></template>",
_dynamicNodes : [],
_observedAttributes :["arrowTop","arrowBot","ltPropClick","ltPropAlignment"],
	didDestroy: function() {
		var allNodes = this.$node.querySelectorAll('lyte-nav-item'), i = 0, curValue;

		for( ; i < allNodes.length; i++ ) {
			curValue = allNodes[ i ].getAttribute( 'lyte-shortcut' );
			if( curValue ){
				allNodes[ i ].setAttribute( 'lyte-shortcut', JSON.stringify( {} ) );
			}
		}
	},

	// Creating outer div 
	createOuterDiv: function() {
		var div = document.createElement( 'div' );

		div.setAttribute( 'class', 'lyteNavDiv' );
		div.style.overflow = 'hidden';
		return div;
	},

	show: function( arrows, outer ) { 
		this.setData( 'topH', arrows[0].getBoundingClientRect().height );
		this.setData( 'botH', arrows[1].getBoundingClientRect().height );
		this.dispArrow.call( this, arrows, outer );
		if( this.getMethods( 'afterRender' ) ) {
			this.executeMethod( 'afterRender', this );
		}
	},

	didConnect: function() {
		var align = this.getData( 'ltPropAlignment' ), 
		tag = this.$node,
		children = tag.children, 
		length = children.length,
		outer, arrows, i, div;

		if( align === 'vertical' ) {
			outer = this.createOuterDiv();
			arrows = tag.querySelectorAll( 'lyte-arrow' )
			for( i = 0; i < length; i++ ) {
				LyteComponent.appendChild( outer, children[ 0 ] );
			}

			/* 
			 * Did connect executes before the constructors of the children but 
			 * since we are performing an append over here the children are executed first 
			 */
			LyteComponent.appendChild( tag, outer );
			if( arrows.length == 0 ) {
				this.addArrow( 'arrow-up' );
				this.addArrow( 'arrow-down' );
			}
			else {
				tag.insertBefore( arrows[ 0 ], tag.children[ 0 ] );
				tag.appendChild( arrows[ 1 ] );
			}

			arrows = tag.querySelectorAll( 'lyte-arrow' )

			$L.fastdom.measure( this.show.bind( this, arrows, outer ) );

			div = tag.querySelector( '.lyteNavDiv' );
			arrows[0].addEventListener( 'mouseenter', this.moveup.bind( this ) );
			arrows[1].addEventListener( 'mouseenter', this.movedown.bind( this ) );

			var that = this;
			div.addEventListener( 'wheel', function( e ) {
				var topHeight, botHeight, total, 
				deltaY = e.deltaY,
				scrollH = div.scrollHeight, 
				height = div.getBoundingClientRect().height, 
				scrollT = div.scrollTop;

				e.preventDefault();

				if( Math.floor( scrollH ) == Math.floor( height ) ) {
					return ;
				}

				topHeight = arrows[ 0 ].getBoundingClientRect().height;
				botHeight = arrows[ 1 ].getBoundingClientRect().height;

				if ( deltaY < 0 ) {
    				scrollT = div.scrollTop = div.scrollTop - 6;

    				if( arrows[ 1 ].style.display === 'none' ) {
    					arrows[ 1 ].style.display = 'inline-block';
    					botHeight = that.getData( 'botH' );
    					total = topHeight + botHeight;
    					div.style.height = 'calc(100% - ' + total + 'px)';
    				}

    				if( scrollT <= 0 ) {
    					arrows[ 0 ].style.display = "none"
    					div.style.height = 'calc(100% - ' + botHeight + 'px)';
    				}
  				}

  				if ( deltaY > 0 ) {
    				scrollT = div.scrollTop = div.scrollTop + 6;

    				if( arrows[ 0 ].style.display === 'none' ) {
    					arrows[ 0 ].style.display = 'inline-block';
    					topHeight = that.getData( 'topH' );
    					total = topHeight + botHeight;
    					div.style.height = 'calc(100% - ' + total + 'px)';
    				}

    				if( Math.floor( height ) + Math.floor( scrollT ) >= Math.floor( scrollH ) ) {
    					arrows[ 1 ].style.display = 'none';
    					div.style.height = 'calc(100% - ' + topHeight + 'px)';
    				}
  				}
			} );

			arrows[ 0 ].addEventListener( 'mouseleave', this.removeup.bind( this ) );
			arrows[ 1 ].addEventListener( 'mouseleave', this.removedown.bind( this ) );

			
		}
	},

	removedown: function() {
		window.cancelAnimationFrame( this.getData( 'arrowdid' ) )
	},

	removeup: function() {
		window.cancelAnimationFrame( this.getData( 'arrowuid' ) );
	},

	down: function( div, ar, bot ) {
		var id,
		scrollT = div.scrollTop, 
		scrollH = div.scrollHeight, 
		height = div.getBoundingClientRect().height;

		if( scrollT + height < scrollH ) {
			scrollT = div.scrollTop = div.scrollTop + 3
		}

    	if( Math.floor( height ) + Math.floor( scrollT ) >= scrollH ) {
    		ar[ 1 ].style.display = 'none';
    		div.style.height = 'calc(100% - ' + bot + 'px)';
    	}

    	id = window.requestAnimationFrame( this.down.bind( this, div, ar, bot ) );
		this.setData( 'arrowdid', id );
	},

	up: function( div, ar, top ) {
		var scrollT = div.scrollTop, id;

		if( scrollT !== 0 ) {
			scrollT = div.scrollTop = div.scrollTop - 3;
		}

   		if( scrollT <= 0 ) {
   			ar[ 0 ].style.display = 'none';
   			div.style.height = 'calc(100% - ' + top + 'px)';
   		}

		id = window.requestAnimationFrame( this.up.bind( this, div, ar, top ) );
		this.setData( 'arrowuid', id );
	},

	movedown: function() {
		var top, bot, total,
		tag = this.$node, 
		div = tag.querySelector( '.lyteNavDiv' ), 
		ar = tag.querySelectorAll( 'lyte-arrow' ), 
		height = div.getBoundingClientRect().height, 
		scroll = div.scrollHeight;

		ar[ 0 ].style.display = 'inline-block';
		top = this.getData( 'topH' );
		bot = this.getData( 'botH' );
		total = top + bot;
		div.style.height = 'calc(100% - ' + total + 'px)';

		// Call Animation inside a rAF.
		window.requestAnimationFrame( this.down.bind( this, div, ar, bot ) );		
	},

	moveup: function() {
		var top, bot, total,
		tag = this.$node, 
		div = tag.querySelector( '.lyteNavDiv' ), 
		ar = tag.querySelectorAll( 'lyte-arrow' ), 
		height = div.getBoundingClientRect().height, 
		scroll = div.scrollHeight;

		ar[ 1 ].style.display = 'inline-block';
		top = this.getData( 'topH' );
		bot = this.getData( 'botH' );
		total = top + bot;
		div.style.height = 'calc(100% - ' + total + 'px)';

		// Call Animation inside a rAF
		window.requestAnimationFrame( this.up.bind( this, div, ar, top ) );			
	},

	addArrow: function( cls ) {
		var i = document.createElement( 'i' ),
		ar = document.createElement( 'lyte-arrow' ), 
		tag = this.$node;

		i.setAttribute( 'class', cls ); 
		ar.appendChild( i );

		if( cls.indexOf('up') !== - 1 ) {
			tag.insertBefore( ar, tag.children[ 0 ] );
		}
		else {
			tag.appendChild( ar )
		}
	},

	dispArrow: function( arrows, div ) {
		var which = 0, topHeight = 0, botHeight = 0, total = 0;
		
		if( this.getData( 'arrowTop' ) ) {
			topHeight = this.getData( 'topH' );
			which = 1;
		}

		if( this.getData( 'arrowBot' ) ) {
			botHeight = this.getData( 'botH' );
			if( which == 1 ) {
				which = 3
			}
			else {
				which = 2
			}
		}

		switch( which ) {
			case 1:
				div.style.height = 'calc(100% - ' + topHeight + 'px)'
				arrows[ 1 ].style.display = "none"
				break;
			case 2:
				div.style.height = 'calc(100% - ' + botHeight + 'px)'
				arrows[ 0 ].style.display = "none"
				break
			case 3:
				total = topHeight + botHeight
				div.style.height = 'calc(100% - ' + total + 'px)'
				break;
		}
	},

	data: function() {
		return {
			'arrowTop': Lyte.attr( 'boolean', { 
				'default': false 
			} ),
			'arrowBot':Lyte.attr( 'boolean', { 
				'default': false 
			} ),
			'ltPropClick': Lyte.attr( 'string', { 
				'default': 'lyteNavActive' 
			} ),
			'ltPropAlignment':Lyte.attr( 'string', { 
				'default': 'horizontal' 
			} )
		}
	}
})



Lyte.createCustomElement( 'lyte-nav-item', {
	constructor: function() {
		var parent = this, component, align, div = this;

    	while( 
    		parent.tagName != 'LYTE-NAV' 
    		&& parent.tagName != 'HTML' 
    	) {
      		parent = parent.parentElement
    	}

    	if( parent.tagName == 'HTML' ) {
    		return ;
  		}

    	component = parent.component;
    	align = component.getData( 'ltPropAlignment' );
    	if( align === 'vertical' ) {
        	while( !div.classList.contains( 'lyteNavDiv' ) ) {
          		div = div.parentElement
        	}  
   	 	}

   	 	$L.fastdom.measure( function() {
   	 		var offsetTop, newElemOffset;

   	 		if( 
    			this.hasAttribute( 'selected' ) 
    			&& this.getAttribute( 'selected' ) 
    		) {
        		if( align === 'vertical' ) {   
          			offsetTop = this.offsetTop;
          			div.scrollTop = offsetTop
          			if( offsetTop != 0 ) {
            			component.setData( 'arrowTop', true );
          			} 
          			
          			component.setData( 'arrowBot', false );
        		}

        		this.classList.add( component.getData( 'ltPropClick' ) );
    		}
    		else if( align === 'vertical' ) {
      			newElemOffset = this.offsetTop;
      			if( newElemOffset + this.getBoundingClientRect().height > div.getBoundingClientRect().height + div.scrollTop ) {
           			component.setData( 'arrowBot', true )    
        		}
    		}
   	 	}, this )

    	

    	this.addEventListener( 'click', function() {
      		this.setAttribute( 'selected', true );
    	}.bind( this ) );
	},

	static : {
		"observedAttributes" : {
			get : function() {
				return [ 'selected', 'lyte-shortcut' ];
			}
		}
	},

	"attributeChangedCallback" : function( attributeName, oldValue, newValue, namespace ) {
		var parent = this, component, click, prevSelected, val;
		if ( attributeName === 'lyte-shortcut' ) {
        	if ( typeof shortcut === 'function' ) {
          		if ( !newValue ) {
            		return;
         	 	}
          		newValue = JSON.parse( newValue );
          		oldValue = oldValue ? JSON.parse( oldValue ) : {};
          		shortcut.push( {
           			newKey: newValue.key,
            		type: newValue.type,
            		wait: newValue.wait,
            		oldKey: oldValue.key,
            		value: this
          		} );
        	}
      	} 
      	else if ( attributeName == 'selected' && newValue && newValue !== 'false' ) {
        	val = this.getAttribute( 'selected' );
        	while (
        		parent.tagName != 'LYTE-NAV' 
        		&& parent.tagName != 'HTML' 
        	) {
          		parent = parent.parentElement;
        	}

        	if ( parent.tagName == 'HTML' ) {
          		return;
        	}

        	component = parent.component;
        	click = component.getData('ltPropClick');
        	prevSelected = parent.querySelector('.' + click);
        	if ( prevSelected && prevSelected != this ) {
          		prevSelected.setAttribute( 'selected', '' );
        	}

        	if ( val ) {
          		this.classList.add( click );
          		if( component.getMethods( 'onItemSelected' ) ){
          			component.executeMethod( 'onItemSelected', this, component )
          		}
        	}
      	} 
      	else if ( attributeName == 'selected' ) {
        	parent = this;
        	while ( 
        		parent.tagName != 'LYTE-NAV' 
        		&& parent.tagName != 'HTML' 
        	) {
          		parent = parent.parentElement;
        	}

        	if (parent.tagName == 'HTML') {
          		return;
        	}

        	component = parent.component;
        	click = component.getData( 'ltPropClick' );
        	this.classList.remove( click );
      	}
	}
});

Lyte.Component.register('lyte-navigator', {
_template:"<template tag-name=\"lyte-navigator\"><template is=\"if\" value=\"{{expHandlers(ltPropType,'==','default')}}\"><template case=\"true\">\t<div class=\"lyteNavigator\" onclick=\"{{action('prevent', event)}}\">\t\t<div class=\"lyteNavigator lyteDoubleBack lyteIconDoubleBack\" onclick=\"{{action('goFirst',event)}}\"></div>\t\t<div class=\"lyteNavigator lyteSingleBack lyteIconSingleBack\" onclick=\"{{action('onBackward',event)}}\"></div>\t\t<div class=\"lyteNavigatorMidPoint\">{{startRecord}} <span class=\"lyteNavigatorText\">{{ltPropMiddleText}}</span> {{endRecord}}</div> \t\t<div class=\"lyteNavigator lyteSingleFront lyteIconSingleFront\" onclick=\"{{action('onForward',event)}}\"></div>\t\t<div class=\"lyteNavigator lyteDoubleFront lyteIconDoubleFront\" onclick=\"{{action('goLast',event)}}\"></div>\t</div></template></template><template is=\"if\" value=\"{{expHandlers(ltPropType,'==','simple')}}\"><template case=\"true\">\t<div class=\"lyteNavigator\" onclick=\"{{action('prevent', event)}}\">\t<div class=\"lytepagination\">\t\t<div class=\"lyteNavArrow lyteDoubleBack hover\" onclick=\"{{action('goFirst',event)}}\"></div>\t\t\t<div class=\"lyteNavArrow lyteSingleBack hover\" onclick=\"{{action('onBackward',event)}}\">\t\t\t<lyte-yield yield-name=\"nav-arrow\"></lyte-yield>\t\t\t</div>\t\t\t<div class=\"lytepage\">\t\t\t\t<template is=\"for\" items=\"{{ltPropPaginationRange}}\" item=\"page\" indexval=\"pageno\">\t\t\t\t\t<a href=\"\" id=\"{{page}}\" class=\"lytesimple\" onclick=\"{{action('onSelect',event)}}\">{{unescape(page)}}</a>                </template>             </div>            <div class=\"lyteNavArrow lyteSingleFront hover\" onclick=\"{{action('onForward',event)}}\">\t\t\t</div>\t\t\t<div class=\"lyteNavArrow lyteDoubleFront hover\" onclick=\"{{action('goLast',event)}}\"></div>\t\t\t</div>\t</div>    </template></template>    <template is=\"if\" value=\"{{expHandlers(ltPropType,'==','border')}}\"><template case=\"true\">\t<div class=\"lyteNavigator\" onclick=\"{{action('prevent', event)}}\">\t<div class=\"lytepagination\">\t\t<div class=\"lyteNavArrowBorder lyteDoubleBack hover lyteborder\" onclick=\"{{action('goFirst',event)}}\"></div>\t\t\t<div class=\"lyteNavArrowBorder lyteSingleBack hover lyteborder\" onclick=\"{{action('onBackward',event)}}\">\t\t\t<lyte-yield yield-name=\"nav-arrow\"></lyte-yield>\t\t\t</div>\t\t\t<div class=\"lytepage\">\t\t\t\t<template is=\"for\" items=\"{{ltPropPaginationRange}}\" item=\"page\" indexval=\"pageno\">\t\t\t\t\t<a href=\"\" id=\"{{page}}\" class=\"lyteborder\" onclick=\"{{action('onSelect',event)}}\">{{unescape(page)}}</a>                </template>             </div>            <div class=\"lyteNavArrowBorder lyteSingleFront hover lyteborder\" onclick=\"{{action('onForward',event)}}\">\t\t\t</div>\t\t\t<div class=\"lyteNavArrowBorder lyteDoubleFront hover lyteborder\" onclick=\"{{action('goLast',event)}}\"></div>\t\t\t</div>\t</div>    </template></template></template>",
_dynamicNodes : [{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"text","position":[1,5,0]},{"type":"text","position":[1,5,2,0]},{"type":"text","position":[1,5,4]},{"type":"attr","position":[1,7]},{"type":"attr","position":[1,9]}]}},"default":{}},{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"attr","position":[1,1,3]},{"type":"insertYield","position":[1,1,3,1]},{"type":"attr","position":[1,1,5,1]},{"type":"for","position":[1,1,5,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]},{"type":"attr","position":[1,1,7]},{"type":"attr","position":[1,1,9]}]}},"default":{}},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"attr","position":[1,1,3]},{"type":"insertYield","position":[1,1,3,1]},{"type":"attr","position":[1,1,5,1]},{"type":"for","position":[1,1,5,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,0]}]},{"type":"attr","position":[1,1,7]},{"type":"attr","position":[1,1,9]}]}},"default":{}}],
_observedAttributes :["ltPropPerpage","ltPropValue","ltPropRecords","ltPropMoreRecords","ltPropMiddleText","ltPropRecordValue","ltPropType","ltPropPaginationRange","ltPropSelected","ltPropShowOnlyIcon"],
	init : function(){

		if(this.getMethods('beforeRender'))
            {
                this.executeMethod('beforeRender', this.$node);
            }

	},
	didConnect:function(){
		// var a=document.querySelector("lyte-arrow").textContent.length;
		// this.setData('ltPropArrowCount',a);

		this.buttonDisable.call(this);
		this.checkButton.call(this);
		if(this.getData("ltPropType")!="default")
		{   
			 var elems=this.$node.querySelectorAll('lyte-nav-arrow');
			if(elems.length==4)
        	{   
        		
        		$L('div.lyteDoubleBack', this.$node).e[0].appendChild(elems[0]);
        		$L('div.lyteSingleBack', this.$node).e[0].appendChild(elems[1]);
        		$L('div.lyteSingleFront', this.$node).e[0].appendChild(elems[2]);
        		$L('div.lyteDoubleFront', this.$node).e[0].appendChild(elems[3]);
        		
        	}
        	if(elems.length==2)
        	{   
        		$L('div.lyteDoubleBack', this.$node).e[0].style.display = "none";
        		$L('div.lyteSingleBack', this.$node).e[0].appendChild(elems[0]);
        		$L('div.lyteSingleFront', this.$node).e[0].appendChild(elems[1]);
        		$L('div.lyteDoubleFront', this.$node).e[0].style.display = "none";
        	}
        	// this.pagination();
        	// this.activeAdd();
        }
			if(this.getMethods('afterRender'))
            {  
                this.executeMethod('afterRender', this.$node);
            }
       		
       	
	}, 
	data: function(){
		return {
			ltPropPerpage:Lyte.attr("number", {"default":10}), 
			ltPropValue:Lyte.attr("number", {"default":0}), 
			ltPropRecords:Lyte.attr("number", {"default":undefined}), 
			ltPropMoreRecords:Lyte.attr("boolean", {"default":false}),
			ltPropMiddleText : Lyte.attr('string', {'default' : 'to'}),
			ltPropRecordValue:Lyte.attr("number", {"default":1}),
			ltPropType:Lyte.attr("string", {"default":'default'}),
			ltPropPaginationRange:Lyte.attr("array",{"default":undefined}),
			ltPropSelected:Lyte.attr("number",{"default":0}),
			ltPropShowOnlyIcon:Lyte.attr("boolean",{"default":false})
		}
	}, 
	buttonDisable:function(){
		
        if(!this.getMethods('onNext'))
        	{
        		$L('div.lyteSingleFront', this.$node).e[0].style.display = "none";
        	}
        
		if(!this.getMethods('onHome'))
        	{
        		$L('div.lyteDoubleBack', this.$node).e[0].style.display = "none";
        	}
		if(!this.getMethods('onEnd'))
        	{
        		$L('div.lyteDoubleFront', this.$node).e[0].style.display = "none";
        	}
        if(!this.getMethods('onPrevious'))
        	{
        		$L('div.lyteSingleBack', this.$node).e[0].style.display = "none";
        	}
        	
        if(this.getData('ltPropShowOnlyIcon')&& this.getData('ltPropType')!='default')
        	{
        		//console.log($L('div.lytepage', this.$node).e[0]);
        		$L('div.lytepage', this.$node).e[0].style.display = "none";
        	}
       
        
        
	}, 
	activeAdd:function()
	{

		if(this.getData("ltPropType")!='default'&&!this.getData('ltPropShowOnlyIcon'))
		{
			var a=this.$node.querySelector('a[href=""][id="'+this.getData('ltPropSelected')+'"]');
			a.classList.add('lyteActiveAdd');
		}
	},

	pagination:function(){
		var current = this.getData('ltPropSelected'),
        propRecord = this.getData('ltPropRecords'),
        delta = 1,
        left = current - delta,
        right = current + delta + 1,
        range = [],
        rangeWithDots = [],
        l,last;
        last = Math.ceil(propRecord/this.getData('ltPropPerpage'));

        if(last>5)
        {
        	if(current==1&&current!=last){
        		right+=1;
        	}
        	if(current==last&&current!=1){
        		left-=1;
        	}
	    	for (var i = 1; i < last; i++)
	    	{
	        	if (i == 1 || i == last || i >= left && i < right)
	        	{
	            	range.push(i); 
	        	}
	        	else if(i>1&& i<left)
	        	{
	        		i=left-1;
	        	}
	        	else if(i>=right&&i<last)
	        	{
	        		i=last-1;
	        	}
	        	
	        	
	    	}
	    	range.push(last);
			for (var i of range)
			{
	        	if (l)
	        	{
	             	if (i - l !== 1) 
	             	{
	               	 	rangeWithDots.push("&#8230;");
	            	}
	        	}
	        rangeWithDots.push(i);
	        l = i;
	    	}
    }
    else
    {
    	for(var i=1;i<=last;i++)
    	{
    		rangeWithDots.push(i);
    	}	
    }
    	this.setData("ltPropPaginationRange",rangeWithDots);
    	this.activeAdd();
},
paginationObs:function(){
this.pagination();
}.observes('ltPropSelected','ltPropPerpage'),
	
	checkButtonObs : function(){
		this.checkButton.call(this);
	}.observes('ltPropPerpage', 'ltPropValue', 'ltPropRecords', 'ltPropMoreRecords'),

	checkButton:function(){
		var firstIndex = this.getData('ltPropValue'), perPage = this.getData('ltPropPerpage'), MaxRecords = this.getData('ltPropRecords')
		var singleFront = $L('div.lyteSingleFront', this.$node).e[0], singleBack = $L('div.lyteSingleBack', this.$node).e[0], doubleBack = $L('div.lyteDoubleBack', this.$node).e[0], doubleFront = $L('div.lyteDoubleFront', this.$node).e[0];
		$L.fastdom.mutate(function(){
			if(firstIndex <= 0)
				{
					doubleBack.classList.add('lyteDisabled')
				}
				else
				{
					doubleBack.classList.remove('lyteDisabled')
				}
				
			if(firstIndex <= 0)
				{
					singleBack.classList.add('lyteDisabled')
				}
			else
				{
					singleBack.classList.remove('lyteDisabled')
				}	
			if((firstIndex + perPage >= MaxRecords) && !this.getData('ltPropMoreRecords'))
				{
					singleFront.classList.add('lyteDisabled')
				}
			else
				{
					singleFront.classList.remove('lyteDisabled')
				}	
				
			if((firstIndex + perPage >= MaxRecords))
				{
					doubleFront.classList.add('lyteDisabled')
				}
				else
				{
					doubleFront.classList.remove('lyteDisabled')
				}
				
		   	 if(this.getData("ltPropType")!="default"&&!this.getMethods('onSelect'))
	        	{
	        		$L('div.lytepage', this.$node).e[0].classList.add("lyteDisabled");
	        	}
			// if(this.getData('ltPropMoreRecords'))
			// 	{
					this.setData('startRecord', (firstIndex + 1) > MaxRecords ? MaxRecords : (firstIndex + 1))
					this.setData('endRecord', (firstIndex + perPage) > MaxRecords ? MaxRecords : firstIndex + perPage)
					if(this.getData("ltPropType")!="default")
					{
						this.setData("ltPropSelected",Math.ceil(this.getData('startRecord')/this.getData('ltPropPerpage')));
						var ele=this.$node.querySelectorAll('a[href=""][id="&#8230;"]');
						for(var i=0;i<ele.length;i++)
						{   
							// ele[i].classList.remove("lyteSinglePage");
							ele[i].classList.add("lyteDisabled");
						}
					}
				// }
			// else
			// 	{	
			// 		this.setData('startRecord', Math.ceil((firstIndex + 1) / perPage))
			// 		this.setData('endRecord', Math.ceil(MaxRecords / perPage))
			// 		this.setData('middleText', 'of')
			// 	}
		}.bind(this))
				
	}, 
	actions : {
			  "onForward" : function(evt){
			  	
			       		var firstIndex = this.getData('ltPropValue'), perPage = this.getData('ltPropPerpage'), MaxRecords = this.getData('ltPropRecords')
			       		firstIndex += perPage
			       		var z = (firstIndex) > MaxRecords ? MaxRecords : firstIndex;
			        	var actionName = this.getMethods('onNext');
			        	
			        	if(actionName)
				    	 {
				    		this.executeMethod('onNext', z, this.$node, evt)
				   		 }
				   		 
				}, 			
			 "onBackward" : function(evt){
				    var firstIndex = parseInt(this.getData('ltPropValue')), perPage = parseInt(this.getData('ltPropPerpage'))
			        firstIndex -= perPage
			        var z = (firstIndex) < 0 ? 0 : firstIndex;
			        if(this.getMethods('onPrevious'))
				    {
				    	this.executeMethod('onPrevious', z, this.$node, evt)
				    }
				    
				}, 
			 "goFirst" : function(evt){
				    this.setData('ltPropValue', 0, this.$node, evt);
			       if( this.getMethods('onHome'))
				    	 {
				    		this.executeMethod('onHome', this.getData('ltPropValue'), this.$node, evt);
				    		var singleFront = $L('div.lyteSingleFront', this.$node).e[0];singleFront.classList.remove('lyteDisabled')
				    	 }
				    if(this.getData('ltPropType')!="default")
				    {
				    	if(this.getData('ltPropSelected')>=1)
				        {   
				        	this.setData('ltPropSelected',1);

				        	
				        }
				    	this.activeAdd();
				    }
				}, 
			 "goLast" : function(evt){
				    var firstIndex = this.getData('ltPropValue'), perPage = this.getData('ltPropPerpage'), MaxRecords = this.getData('ltPropRecords')
				    var x = Math.floor(MaxRecords / perPage) * perPage >= MaxRecords ? MaxRecords - perPage : Math.floor(MaxRecords / perPage) * perPage;
			        if(this.getMethods('onEnd'))
				    	 {
				    		this.executeMethod('onEnd', x, this.$node, evt);
				    	}
				    
				},
			"onSelect" : function(evt){
			  	
			       		var firstIndex = this.getData('ltPropValue'), perPage = this.getData('ltPropPerpage'), MaxRecords = this.getData('ltPropRecords')
			       		firstIndex += perPage
			       		var x = (parseInt(evt.target.id) * perPage)-perPage >= MaxRecords ? MaxRecords - perPage : (parseInt(evt.target.id)*perPage)-perPage;
			        	var actionName = this.getMethods('onSelect');
			        	if(actionName)
				    	 {
				    		this.executeMethod('onSelect', x, this.$node, evt)
				   		 }
				   		 
				 		
				},
			'prevent' : function(evt){
					evt.preventDefault();
			   }	
	}
});
/* Previously when the freeze property of the popover was false it was getting bound to the parent 
element of the origin element istead of getting bound to the body. So there was a problem with the 
calculation of top and left. Now it is bound to the body to solve that problem.*/

/*------------------------   NOTES   ------------------------*/
/*
  Things needed to document:
  1. Added onResize callback to be called on resize event being triggered
  2. Added onScroll callback to be called on resize event being triggered
  3. ltPropHeaderPadding
  4. ltPropContentPadding
  5. ltPropFooterPadding
  6. close popover on clicking freeze layer
*/
if(!LytePopup){
    var LytePopup = {
        components:[],
        onEscape : function(evt){
            evt = evt || window.event;
            var isEscape = false;
            if ("key" in evt) {
                isEscape = (evt.key == "Escape" || evt.key == "Esc");
            } else {
                isEscape = (evt.keyCode == 27);
            }
            if (isEscape) {
                LytePopup.closePopup(undefined,true);
            }
        },
        bindDocumentKeydown : function(){
            document.addEventListener('keydown',LytePopup.onEscape,true);
        },
        addPopup : function(component) {
            LytePopup.closePopup();
            var compLengh = LytePopup.components.length;
            if(compLengh>0){
                var prevZIndex = 0;
                var prePopup = '', thisPopup = '', thisFreeze = '';
                if(LytePopup.components[compLengh-1].$node.tagName == "LYTE-MODAL"){
                    prePopup = '.lyteModal';
                }
                else if(LytePopup.components[compLengh-1].$node.tagName == "LYTE-POPOVER"){
                    prePopup = '.lytePopover';
                }   
                else{
                    prePopup = '.alertPopup';
                }

                if(component.$node.tagName == "LYTE-MODAL"){
                    thisPopup = '.lyteModal';
                    thisFreeze = 'lyte-modal-freeze';
                }
                else if(component.$node.tagName == "LYTE-POPOVER"){
                    thisPopup = '.lytePopover';
                    thisFreeze = 'lyte-popover-freeze';
                }
                else{
                    thisPopup = '.alertPopup';
                    thisFreeze = '.alertFreezeLayer';
                }
                var node = LytePopup.components[compLengh-1].childComp.querySelector(prePopup);
                prevZIndex = Number(document.defaultView.getComputedStyle(node,null).getPropertyValue('z-index'));
                component.childComp.querySelector(thisPopup).style.zIndex = prevZIndex+2;
                if(component.$node.ltProp('freeze') && component.childComp.querySelector(thisFreeze)){
                    component.childComp.querySelector(thisFreeze).style.zIndex = prevZIndex+1;
                }
            }
            LytePopup.components[compLengh] = component;
        },
        closePopup : function(component,fromEscape){
            if(fromEscape){
                var lastPop = LytePopup.components[LytePopup.components.length-1];
                if(lastPop && lastPop.$node.ltProp("closeOnEscape")){
                    lastPop.$node.ltProp("show",false);
                }
            }
            else{
                if(component){
                    LytePopup.components.splice(LytePopup.components.indexOf(component),1);
                }
                else{
                    for(var i=LytePopup.components.length-1;i>=0;i--){
                        if(LytePopup.components[i].$node && !LytePopup.components[i].$node.ltProp("allowMultiple")){
                            LytePopup.components[i].$node.ltProp("show",false);
                        }
                    }
                }   
            }  
        }   
    };
    LytePopup.bindDocumentKeydown();
    
};

Lyte.Component.register("lyte-popover",{
_template:"<template tag-name=\"lyte-popover\">\t<template is=\"if\" value=\"{{ltPropBindToBody}}\"><template case=\"true\"> \t<lyte-wormhole case=\"true\" style=\"{{if(ltPropShowCopy,'visibility:visible','visibility:hidden')}}\">\t\t<template is=\"registerYield\" yield-name=\"lyte-content\">\t\t\t<div class=\"popoverWrapper {{ltPropWrapperClass}}\">\t\t\t\t<div class=\"lytePopover\">\t\t\t\t\t<span id=\"lytePopoverArrow\" class=\"lytePopoverArrowIcon\"></span>\t\t\t\t\t<template is=\"if\" value=\"{{ltPropShowCloseButton}}\">\t\t\t\t\t\t<template case=\"true\"><span class=\"lytePopoverClose\" onclick=\"{{action('close')}}\"></span></template>\t\t\t\t\t</template>\t\t\t\t\t<lyte-yield yield-name=\"popover\"></lyte-yield>\t\t\t\t</div>\t\t\t\t<template is=\"if\" value=\"{{ltPropFreeze}}\">\t\t\t\t\t<template case=\"true\"><lyte-popover-freeze></lyte-popover-freeze></template>\t\t\t\t</template>\t\t\t</div>\t\t</template>\t</lyte-wormhole>\t</template></template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","helperInfo":{"name":"if","args":["ltPropShowCopy","'visibility:visible'","'visibility:hidden'"]}}}},{"type":"registerYield","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]}]}},"default":{}},{"type":"insertYield","position":[1,1,5]},{"type":"attr","position":[1,3]},{"type":"if","position":[1,3],"cases":{"true":{"dynamicNodes":[{"type":"componentDynamic","position":[0]}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropShow","ltPropType","ltPropFreeze","ltPropShowCloseButton","ltPropCloseOnEscape","ltPropOriginElem","ltPropPosition","ltPropPlacement","ltPropScrollable","ltPropDraggable","ltPropAllowMultiple","ltPropMaxHeight","ltPropMaxWidth","ltPropWidth","ltPropHeight","ltPropWrapperClass","ltPropBoundary","ltPropHeading","ltPropButtons","ltPropButtonPosition","ltPropCloseOnBodyClick","ltPropDuration","ltPropOffset","ltPropBindToBody","ltPropHeaderPadding","ltPropContentPadding","ltPropFooterPadding","ltPropDimmer","buttons","ltPropShowCopy","visible","timeOutId","classTobeAdded","keys","first","arrowHidden","arrowEle","returnedFalse"],

    data: function(){
        return {
            //config from callee
            "ltPropShow":Lyte.attr("boolean",{"default": false}),
            "ltPropType":Lyte.attr("string",{"default":"callout"}),
            "ltPropFreeze":Lyte.attr("boolean",{"default": true}),
            "ltPropShowCloseButton":Lyte.attr("boolean",{"default": true}),
            "ltPropCloseOnEscape":Lyte.attr("boolean",{"default": true}),
            "ltPropOriginElem":Lyte.attr("string",{"default":""}),
            "ltPropPosition":Lyte.attr("string",{"default":"bottom"}),
            "ltPropPlacement":Lyte.attr("string",{"default":""}),
            "ltPropScrollable":Lyte.attr("boolean",{"default": false}),
            "ltPropDraggable":Lyte.attr("boolean",{"default": false}),
            "ltPropAllowMultiple":Lyte.attr("boolean",{"default": false}),
            "ltPropMaxHeight":Lyte.attr("string",{"default":""}),
            "ltPropMaxWidth":Lyte.attr("string",{"default":""}),
            "ltPropWidth":Lyte.attr("string",{"default":""}),
            "ltPropHeight":Lyte.attr("string",{"default":"auto"}),
            "ltPropWrapperClass":Lyte.attr("string",{"default":""}),
            "ltPropBoundary" : Lyte.attr("object",{"default":{}}),
            "ltPropHeading":Lyte.attr("string",{"default":""}),
            "ltPropButtons":Lyte.attr("string",{"default":""}),
            "ltPropButtonPosition":Lyte.attr("string",{"default":"right"}),
            "ltPropCloseOnBodyClick" : Lyte.attr("boolean",{"default" : true}),
            "ltPropDuration" : Lyte.attr("number",{"default" : 800}),
            "ltPropOffset" : Lyte.attr("object",{"default" : {}}),
            "ltPropBindToBody" : Lyte.attr("boolean",{"default":false}),
            "ltPropHeaderPadding":Lyte.attr("string",{"default":"15px 30px"}),
            "ltPropContentPadding":Lyte.attr("string",{"default":"15px 30px"}),
            "ltPropFooterPadding":Lyte.attr("string",{"default":"15px 30px"}),
            //local properties
            "ltPropDimmer":Lyte.attr("object",{"default":{"color":"black","opacity":"0.4"}}),
            "buttons":Lyte.attr("array",{"default":[{"type":"accept","text":"Ok"}]}),
            "ltPropShowCopy":Lyte.attr("boolean",{"default": false}),
            "visible" : Lyte.attr("boolean",{"default" : true}),
            "timeOutId" : Lyte.attr("number"),
            "classTobeAdded" : Lyte.attr("string"),
            "keys" : Lyte.attr("object", {"default" : {37: 1, 38: 1, 39: 1, 40: 1}}),
            "first" : Lyte.attr("boolean",{"default":true}),
            "arrowHidden" : Lyte.attr("boolean", {"default" : false}),
            "arrowEle" : Lyte.attr("object"),
            "returnedFalse" : Lyte.attr("boolean",{"default":false})
        }
    },

    addDragHandler : function(){
        var dragHeader = this.actualModalDiv.querySelector('lyte-popover-header');
        if(dragHeader){
            dragHeader.parentEle = this;
            if(this.$node.ltProp("draggable")){
                dragHeader.addEventListener('mousedown',this.handleMove,true);
                dragHeader.classList.add('draggable');
            }
            else{
                dragHeader.removeEventListener('mousedown',this.handleMove,true);
                dragHeader.classList.remove('draggable');
            }
        }
        else{
            console.warn("This popover is not draggable because it has no header");
            this.$node.ltProp("draggable",false);
        }
    },
    handleMove : function(e){
        var drag = e.currentTarget.parentEle.actualModalDiv;
        LytePopup.node=drag;
        LytePopup.xPos=e.clientX-this.getBoundingClientRect().left;
        LytePopup.yPos=e.clientY-this.getBoundingClientRect().top;
        var elePos = drag.getBoundingClientRect();
        drag.style.transitionDuration = "0s";
        var arrowEle = drag.parentElement.querySelector("#lytePopoverArrow");
        if(arrowEle){
            this.parentEle.setData('arrowHidden',true);
            this.parentEle.setData('arrowEle',arrowEle);
            arrowEle.style.display = "none";    
        }
        document.body.addEventListener('mousemove',e.currentTarget.parentEle.handleDrag,true);
        document.body.addEventListener('mouseup',e.currentTarget.parentEle.stopDrag,true);
    },
    handleDrag : function(e){
        var drag = LytePopup.node;
        drag.style.left=(e.clientX-drag.offsetParent.getBoundingClientRect().left-LytePopup.xPos)+'px';
        drag.style.top=(e.clientY-drag.offsetParent.getBoundingClientRect().top-LytePopup.yPos)+'px';
        window.getSelection().removeAllRanges();
    },
    stopDrag : function(e){
        var targetElem = e.target;
        while(targetElem && targetElem !== document){
            if(targetElem.parentEle){
                this.removeEventListener('mousemove',targetElem.parentEle.handleDrag,true);
                this.removeEventListener('mouseup',targetElem.parentEle.stopDrag,true);
                break;
            }
            targetElem = targetElem.parentElement ? targetElem.parentElement : document;
        }
    },
    closeAlertFn : function(){
        this.$node.ltProp("show",false);
        if(this.getMethods("onClose")){
            this.executeMethod("onClose");  
        }
    },
    showToggled : function(){
        // debugger
        if(this.getData('returnedFalse')){
            this.setData('returnedFalse',false);
            return;
        }
        if(this.$node.ltProp("show") && !this.$node.ltProp("showCopy")){
            this.$node.ltProp("bindToBody",true);
            var self = this;
            setTimeout(function(){
                self.onBeforeShowHandling();
            },0);
        }
        else{
            if(this.$node.ltProp("showCopy")){
                var self = this;
                setTimeout(function(){
                    self.onBeforeCloseHandling();
                },0);
            }
        }
    }.observes("ltPropShow").on('didConnect'),
    changeShow : function(){
        if(!this.getData('ltPropBindToBody')){
            if(this.getData('ltPropShow')){
                this.setData('ltPropShow',false);
            }
        }
    }.observes("ltPropBindToBody"),
    callOnResize : function(event){
        if(this.getMethods('onResize')){
            this.executeMethod('onResize',event,this);
        }
    },
    callOnScroll: function(event){
        var returnVal;
        if(this.getMethods('onScroll')){
            returnVal = this.executeMethod('onScroll',event,this);
        }
        return (returnVal == undefined ? true : returnVal);
    },
    updateScrollHandling : function(){   //Sets the height and width of the popover
        if(!this.$node.ltProp("freeze") && this.$node.ltProp("scrollable")){
            this.$node.ltProp("scrollable",true);
        }
        var modalElem = this.actualModalDiv;
        var oldHeight, oldWidth, newHeight, newWidth,
        contentNode = modalElem.querySelector("lyte-popover-content");
        contentNode = contentNode ? contentNode : modalElem;
        modalElem.style.maxWidth = "";
        modalElem.style.maxHeight = "";
        modalElem.style.height = this.$node.ltProp("height")?this.$node.ltProp("height"):"auto";
        modalElem.style.width = this.$node.ltProp("width")?this.$node.ltProp("width"):"auto";
        /*------------------------------ MEASURE STARTS --------------------------*/
        $L.fastdom.measure(function(){   //Measures the initial height and width based on the content of popover
            var modalElemOffset = modalElem.getBoundingClientRect();
            /*IF maxwidth or maxheigth given as a percentage then to calculate the actual width or height 
                                we need the modalElements parent element's width and height*/
            var modalParentOff = modalElem.parentElement.getBoundingClientRect();
            var totalHeight = ((modalElem.querySelector('lyte-popover-header') ? modalElem.querySelector('lyte-popover-header').getBoundingClientRect().height : 0) +
                                    (modalElem.querySelector('lyte-popover-content') ? modalElem.querySelector('lyte-popover-content').getBoundingClientRect().height : 0) +
                                        (modalElem.querySelector('lyte-popover-footer') ? modalElem.querySelector('lyte-popover-footer').getBoundingClientRect().height : 0))
            var cs = window.getComputedStyle(modalElem);
            var borderDimensionY = ((cs.borderTop ? parseFloat(cs.borderTop) : 0) +
                                     (cs.borderBottom ? parseFloat(cs.borderBottom) : 0));
            var h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
            /*------------------------------ MUTATE STARTS --------------------------*/
            $L.fastdom.mutate(function(){  //Measures and sets the height and width based on the user provided max values
                // debugger
                if(this.$node.ltProp("maxHeight") && totalHeight >= parseInt(this.$node.ltProp("maxHeight"))){
                    this.childComp.querySelector(".popoverWrapper").classList.add("scrollable");
                    this.$node.ltProp("scrollable",true);
                    oldHeight = modalElemOffset.height - borderDimensionY;
                    var newH = this.$node.ltProp("maxHeight").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp("maxHeight"))/100) * modalParentOff.height) : parseFloat(this.$node.ltProp("maxHeight"));
                    modalElem.style.height = this.$node.ltProp("maxHeight");
                    newHeight = newH - borderDimensionY;
                }
                else{
                    oldHeight = modalElemOffset.height - borderDimensionY;
                    newHeight = h-20;
                }

                if(this.$node.ltProp("maxWidth")){
                    this.$node.ltProp("scrollable",true);
                    oldWidth = modalElemOffset.width;
                    modalElem.style.width = this.$node.ltProp("maxWidth");
                    newWidth = this.$node.ltProp("maxWidth").indexOf('%') != -1 ? ((parseFloat(this.$node.ltProp("maxWidth"))/100) * modalParentOff.width) : parseFloat(this.$node.ltProp("maxWidth"));
                    if(oldWidth < newWidth){
                        modalElem.style.width = oldWidth+"px";
                        newWidth = oldWidth;
                    }
                    modalElem.style.overflowX = "auto";
                }
                else{
                    newWidth = modalElemOffset.width;
                }

                if(this.$node.ltProp("scrollable")){
                    var popoverHeader = this.actualModalDiv.querySelector("lyte-popover-header"), popoverFooter = this.actualModalDiv.querySelector("lyte-popover-footer");
                    var popoverHOff = 0,popoverFOff = 0;
                    /*------------------------------ MEASURE STARTS --------------------------*/
                    $L.fastdom.measure(function(){    //Measures the heaser and footer dimensions
                        if(popoverHeader){
                            popoverHOff = popoverHeader.getBoundingClientRect().height;
                        }
                        if(popoverFooter){
                            popoverFOff = popoverFooter.getBoundingClientRect().height;
                        }
                        /*------------------------------ MUTATE STARTS --------------------------*/
                        $L.fastdom.mutate(function(){   //Sets the final height and width of the popover
                            var newH = (newHeight - (popoverHOff + popoverFOff));
                            contentNode.style.maxHeight = (newH > 0 ? newH : 50) +"px";
                            contentNode.style.overflowY = "auto"; 
                            if(this.getData('ltPropHeight')){
                                contentNode.style.height = (oldHeight - (popoverHOff + popoverFOff))+"px";
                            }
                            else{
                                contentNode.style.height = "auto";
                            }
                            modalElem.style.width = this.$node.ltProp("width")?this.$node.ltProp("width"):"auto";
                            this.actualModalDiv.style.maxWidth = newWidth > 0 ? (newWidth +"px"):("70%");
                            modalElem = null;
                            contentNode = null;
                            popoverHeader = null;
                            popoverFooter = null;
                        },this);
                        /*------------------------------ MUTATE ENDS --------------------------*/
                    },this);
                    /*------------------------------ MEASURE ENDS --------------------------*/
                }
                else{
                    this.childComp.querySelector(".popoverWrapper").classList.remove("scrollable");
                    modalElem = null;
                    contentNode = null;
                }
                if(this.$node.ltProp('freeze')){
                    this.childComp.querySelector(".popoverWrapper").style.position = "fixed";
                }
                else{
                    this.childComp.querySelector(".popoverWrapper").style.position = "inherit";   
                }
            },this);
            /*------------------------------ MUTATE ENDS --------------------------*/
        },this);
        /*------------------------------ MEASURE ENDS --------------------------*/
    },
    scrollHandling : function(){
        if(!this.getData('ltPropShow')){
            return;
        }
        this.updateScrollHandling();
    }.observes("ltPropWidth","ltPropMaxWidth","ltPropHeight","ltPropMaxHeight"),

    //Sets the left and top of the popover
    computeOffsetImpl : function(){
        var classTobeAdded = "", offsetLeft="",offsetTop="";
        var modalEle = this.actualModalDiv;
        modalEle.classList.remove('lytePopoverCenter','lytePopoverBottomCenter','lytePopoverBottomLeft','lytePopoverBottomRight','lytePopoverTopCenter','lytePopoverTopLeft','lytePopoverTopRight','lytePopoverLeft','lytePopoverRight');
        // modalEle.style.left = "";
        // modalEle.style.top = "";
        /*------------------------------ MEASURE STARTS --------------------------*/
        $L.fastdom.measure(function(){
            if(this.$node.ltProp("showCopy")){
                if(this.$node.ltProp('originElem') != ""){
                    // debugger
                    var ele = document.querySelector(this.$node.ltProp('originElem'));
                    var modalElePosition = modalEle.getBoundingClientRect();
                    var xscroll = window.pageXOffset || document.documentElement.scrollLeft;
                    var yscroll = window.pageYOffset || document.documentElement.scrollTop;
                    var bodyHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) + yscroll;
                    var bodyWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0) + xscroll;  
                    var eleOffset = ele.getBoundingClientRect();
                    var origElemPosition;
                    if(Lyte.Component.registeredHelpers.lyteUiIsEmptyObject(this.$node.ltProp('offset'))){
                        origElemPosition = {top: eleOffset.top,
                                            right: eleOffset.right,
                                            bottom: eleOffset.bottom,
                                            left: eleOffset.left,
                                            width: eleOffset.width,
                                            height: eleOffset.height
                                          };
                    }
                    else{
                        origElemPosition = {width:this.$node.ltProp('offset').width || 0,
                                            height:this.$node.ltProp('offset').height || 0,
                                            top:this.$node.ltProp('offset').top,
                                            left:this.$node.ltProp('offset').left,
                                            bottom:(this.$node.ltProp('offset').top + (this.$node.ltProp('offset').height || 0)),
                                            right:(this.$node.ltProp('offset').left + (this.$node.ltProp('offset').width || 0))
                                            }
                    }
                    if(!this.getData('ltPropFreeze')){
                        origElemPosition.top = origElemPosition.top + yscroll;
                        origElemPosition.left = origElemPosition.left + xscroll;
                    }
                    
                    var elementPosition = origElemPosition;
                    var offObj = {}, newOffObj = {};
                    var position =  this.$node.ltProp('positionNew');
                    var flag = true;
                    var count = 0;
                    do{
                        if(this.$node.ltProp('placement') && !this.$node.ltProp('freeze')){
                            flag = true;
                            offObj = this.positionPopover(this.$node.ltProp('placement'),elementPosition,modalElePosition);
                            if(!this.$node.ltProp('freeze')){
                                newOffObj.offsetTop = origElemPosition.top + origElemPosition.height; 
                                newOffObj.offsetLeft = origElemPosition.left + origElemPosition.width; 
                            }
                            else{
                                newOffObj = offObj;
                            }
                            switch(this.$node.ltProp('placement')){
                                case 'bottom':
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'bottomLeft':
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'bottomRight':
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'top':
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'topLeft':
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'topRight':
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'left':
                                    
                                    if((newOffObj.offsetTop-modalElePosition.height) < 0 ){
                                        offObj.offsetTop = elementPosition.top;
                                    }
                                    if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){
                                        offObj.offsetTop = bodyHeight - modalElePosition.height;
                                    }
                                    break;
                                case 'right':
                                    
                                    if((newOffObj.offsetTop-modalElePosition.height) < 0 ){
                                        offObj.offsetTop = elementPosition.top;
                                    }
                                    if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){
                                        offObj.offsetTop = bodyHeight - modalElePosition.height;
                                    }
                                    break;
                            }
                            position = this.$node.ltProp('placement');
                        }
                        else{
                           count++;
                            flag = true;
                            offObj = this.positionPopover(position,elementPosition,modalElePosition);
                            if(!this.$node.ltProp('freeze')){
                                newOffObj.offsetTop = origElemPosition.top + origElemPosition.height; 
                                newOffObj.offsetLeft = origElemPosition.left + origElemPosition.width; 
                            }
                            else{
                                newOffObj = offObj;
                            }
                            switch(position){
                                case 'bottom':
                                    if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height)){
                                        position = "top";
                                        flag = false;
                                        break;
                                    }
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'bottomLeft':
                                    if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height)){
                                        position = "top";
                                        flag = false;
                                        break;
                                    }

                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'bottomRight':
                                    if(bodyHeight < (newOffObj.offsetTop+modalElePosition.height)){
                                        position = "top";
                                        flag = false;
                                        break;
                                    }
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'top':
                                    if((newOffObj.offsetTop-modalElePosition.height) < 0){
                                        position = "right";
                                        flag = false;
                                        break;
                                    }
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'topLeft':
                                    if((newOffObj.offsetTop-modalElePosition.height) < 0){
                                        position = "right";
                                        flag = false;
                                        break;
                                    }
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'topRight':
                                    if((newOffObj.offsetTop-modalElePosition.height) < 0){
                                        position = "left";
                                        flag = false;
                                        break;
                                    }
                                    
                                    if((newOffObj.offsetLeft-modalElePosition.width) < 0){
                                        offObj.offsetLeft = elementPosition.left;
                                        flag = true;
                                    }
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        offObj.offsetLeft = bodyWidth - modalElePosition.width - 10;
                                        flag = true;
                                    }
                                    break;
                                case 'left':
                                    if(newOffObj.offsetLeft < 0){
                                        position = "right";
                                        offsetLeft = (elementPosition.left + elementPosition.width)+9;
                                        offsetTop = elementPosition.top;
                                    }

                                    if((newOffObj.offsetTop-modalElePosition.height) < 0 ){
                                        offObj.offsetTop = elementPosition.top;
                                    }
                                    if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){
                                        offObj.offsetTop = bodyHeight - modalElePosition.height;
                                    }
                                    break;
                                case 'right':
                                    if(bodyWidth < (newOffObj.offsetLeft+modalElePosition.width)){
                                        position = "left";
                                        offObj.offsetLeft = (elementPosition.left - modalElePosition.width)-9;
                                        offObj.offsetTop = elementPosition.top;
                                    }

                                    if((newOffObj.offsetTop-modalElePosition.height) < 0 ){
                                        offObj.offsetTop = elementPosition.top;
                                    }
                                    if(bodyHeight < (offObj.offsetTop+modalElePosition.height)){
                                        offObj.offsetTop = bodyHeight - modalElePosition.height;
                                    }
                                    break;
                            }

                        }
                        
                    }while(!flag && count <= 8)
                    var positions = ["bottom","bottomLeft","bottomRight","top","topLeft","topRight","right","left"];

                    offsetLeft = offObj.offsetLeft;
                    offsetTop = offObj.offsetTop;

                    if(this.$node.ltProp('type') === "callout"){
                        if(position.indexOf("bottom") > -1){
                            offObj.classTobeAdded = "lytePopoverArrowTop";
                        }
                        else if(position.indexOf("top") > -1){
                            offObj.classTobeAdded = "lytePopoverArrowBottom";
                        }
                        else if(position === "left"){
                             offObj.classTobeAdded = "lytePopoverArrowRight";
                        }
                        else if(position === "right"){
                             offObj.classTobeAdded = "lytePopoverArrowLeft";
                        }
                        var arrowIcon = modalEle.querySelector("#lytePopoverArrow");
                        arrowIcon.classList.remove("lytePopoverArrowTop","lytePopoverArrowBottom","lytePopoverArrowRight","lytePopoverArrowLeft");
                        arrowIcon.classList.add(offObj.classTobeAdded);
                        var arrowIconOffset;
                        /*------------------------------ MEASURE STARTS --------------------------*/
                        $L.fastdom.measure(function(){
                        arrowIconOffset = arrowIcon.getBoundingClientRect();
                        });
                        /*------------------------------ MEASURE ENDS --------------------------*/
                        /*------------------------------ MUTATE STARTS --------------------------*/
                        //Positions the arrowIcon of the popover and the popover too based on origin elem
                        $L.fastdom.mutate(function(){   //If originElem -> height < arrowIcon -> height OR originElem -> width < arrowIcon -> width
                            if(offObj.classTobeAdded === "lytePopoverArrowTop" || offObj.classTobeAdded === "lytePopoverArrowBottom"){
                                arrowIcon.style.left = Math.abs(offsetLeft - (elementPosition.left+(elementPosition.width-arrowIcon.offsetWidth)/2))+"px"; 
                                arrowIcon.style.top = "";
                                if(arrowIconOffset.left < 12 && origElemPosition.width <= 16){
                                    var diff = 12 - arrowIconOffset.left;
                                    if(origElemPosition.left == offsetLeft && (offsetLeft - diff) >= 0){
                                        arrowIcon.style.left = arrowIconOffset.left + diff + "px";
                                        offsetLeft -= diff;
                                    }
                                }
                                else if(modalElePosition.width - arrowIconOffset.right < 12 && origElemPosition.width <= 16){
                                    var diff = 12 - (modalElePosition.width - arrowIcon.getBoundingClientRect().right);
                                    if(origElemPosition.left + origElemPosition.width == modalElePosition.width + offsetLeft){
                                        arrowIcon.style.left = arrowIconOffset.left - diff + "px";
                                        offsetLeft += diff;
                                    }
                                }
                            }
                            else{
                                arrowIcon.style.left = "";
                                arrowIcon.style.top = Math.abs(offsetTop - (elementPosition.top+(elementPosition.height-arrowIcon.offsetHeight)/2)) + 5 +"px"; 
                                if(arrowIconOffset.top < 12 && origElemPosition.height <= 16){
                                    var diff = 12 - arrowIconOffset.top;
                                    if(origElemPosition.top == offsetTop && (offsetTop - diff) >= 0){
                                        arrowIcon.style.top = arrowIconOffset.top + diff + "px";
                                        offsetTop -= diff;
                                    }
                                }
                                else if(modalElePosition.height - arrowIconOffset.bottom < 12 && origElemPosition.height <= 16){
                                    var diff = 12 - (modalElePosition.height - arrowIconOffset.bottom);
                                    if(origElemPosition.top + origElemPosition.height == modalElePosition.height + offsetTop){
                                        arrowIcon.style.top = arrowIconOffset.top - diff + "px";
                                        offsetTop += diff;
                                    }
                                }
                            }
                        });
                        /*------------------------------ MUTATE ENDS --------------------------*/
                        
                    }
                    this.setData('classTobeAdded',offObj.classTobeAdded);
                }         
                this.$node.ltProp('positionNew',position);
                /*------------------------------ MUTATE STARTS --------------------------*/
                $L.fastdom.mutate(function(){ 
                    modalEle.style.left = offsetLeft+"px";
                    modalEle.style.top = offsetTop+"px";
                    if(this.getData("first")){
                        this.callOnShow();
                        this.setOpacityAndVisibility();
                        this.setData("first",false);
                    }
                },this);
                /*------------------------------ MUTATE ENDS --------------------------*/
            }
        },this);
        /*------------------------------ MEASURE ENDS --------------------------*/
        if(this.$node.ltProp("freeze")){
            document.body.classList.add('bodyWrapper');    
        }
    },
    positionPopover : function(position,elementPosition,modalElePosition){
        var  offsetLeft=0,offsetTop=0;
        switch(position){
            case 'bottom':
                offsetLeft = elementPosition.left - (modalElePosition.width - elementPosition.width)/2;
                offsetTop = elementPosition.top+elementPosition.height+9;
                classTobeAdded = "lytePopoverArrowTop";
                break;
            case 'bottomLeft':
                offsetLeft = elementPosition.left;
                offsetTop = elementPosition.top +elementPosition.height+9;
                classTobeAdded = 'lytePopoverArrowTop';
                break;
            case 'bottomRight':
                offsetLeft = (elementPosition.left + elementPosition.width) - modalElePosition.width;
                offsetTop =  elementPosition.top +elementPosition.height+9;
                classTobeAdded = 'lytePopoverArrowTop';
                break;
            case 'top':
                offsetLeft = elementPosition.left - (modalElePosition.width - elementPosition.width)/2;
                offsetTop = elementPosition.top - (modalElePosition.height+9);
                classTobeAdded = 'lytePopoverArrowBottom';
                break;
            case 'topLeft':
                offsetLeft = elementPosition.left;
                offsetTop = elementPosition.top - (modalElePosition.height+9);
                classTobeAdded = 'lytePopoverArrowBottom';
                break;
            case 'topRight':
                offsetLeft = (elementPosition.left + elementPosition.width) - modalElePosition.width;
                offsetTop = elementPosition.top - (modalElePosition.height+9);
                classTobeAdded = 'lytePopoverArrowBottom';
                break;
            case 'left':
                offsetLeft = (elementPosition.left - modalElePosition.width)-9;
                offsetTop = elementPosition.top;
                classTobeAdded = 'lytePopoverArrowRight';
                break;
            case 'right':
                offsetLeft = (elementPosition.left + elementPosition.width)+9;
                offsetTop = elementPosition.top;
                classTobeAdded = 'lytePopoverArrowLeft';
                break;
        }
        return {offsetLeft:offsetLeft,offsetTop:offsetTop,classTobeAdded:classTobeAdded};
    },

    callOnShow:function(){
        if(this.getMethods("onShow")){
            this.executeMethod("onShow",this); 
        }
    },
    setOpacityAndVisibility : function(){
        this.actualModalDiv.style.transitionDuration = (parseFloat(this.getData('ltPropDuration'))/1000) + "s";
        LytePopup.makingVisible = true;
        this.actualModalDiv.style.opacity = "1";
        if(this.$node.ltProp('freeze')){
            var freezeStyle = this.childComp.querySelector("lyte-popover-freeze").style;
            freezeStyle.transitionDuration = (parseFloat(this.getData('ltPropDuration'))/1000) + "s";
            freezeStyle.opacity = this.getData('ltPropDimmer').opacity;
            freezeStyle.background = this.getData('ltPropDimmer').color;
        }
        
        if(!this.$node.ltProp('freeze') && this.getData('classTobeAdded') && (this.getData('classTobeAdded') == "lytePopoverArrowLeft" || this.getData('classTobeAdded') == "lytePopoverArrowRight")){
            var actualModalDivOffset = this.actualModalDiv.getBoundingClientRect();
            var origElemPosition = document.querySelector(this.getData('ltPropOriginElem')).getBoundingClientRect();
            if(actualModalDivOffset.top != origElemPosition.top){
                this.actualModalDiv.style.top = origElemPosition.top + "px";
            }
        }
    },
    
    /*computeOffset : function(){
        this.computeOffsetImpl();
    }.observes("ltPropOriginElem","ltPropPosition","ltPropType","ltPropShowCopy","ltPropOffset"),*/
    onBeforeCloseHandling : function(){
        var result = true;
        var event = event || window.event;
        if(this.getMethods("onBeforeClose")){
            result = this.executeMethod("onBeforeClose",event,this); 
        }
        if(result === undefined || result){
            if(this.getData('arrowHidden')){
                this.getData('arrowEle').style.display = "";
                this.setData('arrowHidden',false);
                this.setData('arrowEle',null);
            }
            var animDur = parseInt(this.getData('ltPropDuration'));
            var self = this;
            var timeOutId = setTimeout(function(){
                self.$node.ltProp({"showCopy":false,"show":false});
                // console.log("hidden");
            },animDur);
            this.setData('timeOutId',timeOutId);
            this.actualModalDiv.style.transitionDuration = (animDur / 1000)+"s";
            this.actualModalDiv.style.opacity = 0;
            LytePopup.closePopup(this);
            this.setData('visible',false);
            if(this.getMethods("onClose")){
                this.executeMethod("onClose",this);  
            }
            if(this.$node.ltProp('freeze') && this.childComp.querySelector("lyte-popover-freeze")){
                this.childComp.querySelector("lyte-popover-freeze").style.opacity = 0;
            }
            this.childComp.querySelector(".popoverWrapper").style.position = "";
            document.body.classList.remove('bodyWrapper');
            if(!this.getData('ltPropFreeze') && document.body.classList.contains('lyteStopBodyScrolling')){
                document.body.classList.remove('lyteStopBodyScrolling');
            }
        }
        else{
            this.setData('returnedFalse',true);
            if(!this.getData('visible')){
                this.setData('visible',true);
            }
            this.$node.ltProp('show',true);
        }
    },
    onBeforeShowHandling : function(){
        var result = true;
        if(this.getMethods("onBeforeShow")){
            result = this.executeMethod("onBeforeShow",this); 
        }
        if(result === undefined || result){
            if(this.getData('ltPropDraggable')){
                this.addDragHandler();
            }
            this.updateScrollHandling();
            if(this.$node.ltProp('freeze')){
                this.childComp.querySelector(".popoverWrapper").style.position = "fixed";
            }
            else{
                this.childComp.querySelector(".popoverWrapper").style.position = "inherit";   
            }

            this.$node.ltProp("positionNew",this.$node.ltProp("position"));
            var self = this;
            setTimeout(function(){
                /*------------------------------ MUTATE STARTS --------------------------*/
                self.$node.ltProp('showCopy',true);
                $L.fastdom.mutate(function(){
                    self.computeOffsetImpl();
                },self);
                /*------------------------------ MUTATE ENDS --------------------------*/

            },0);
            if(!this.getData("first")){
                this.setData("first",true);
            }
            if(!this.getData('ltPropFreeze')){
                document.body.classList.add('lyteStopBodyScrolling');
            }
            if(!this.getData('visible')){
                this.setData('visible',true);
            }
             LytePopup.addPopup(this);
            
        }
        else{
            // setTimeout( function(){
                 this.$node.ltProp({"showCopy":false,"show":false});
            //  }.bind(this), 0 )
        }
    },
    didDestroy : function(){
        if(this.childComp){
            if(this.getData('timeOutId')){
                clearInterval(this.getData('timeOutId'));
            }
            this.childComp.remove();    
        }
        LytePopup.components = [];
    },
    actions: {
        wormholeDidConnect : function(){   
            // debugger
            
            this.childComp = this.$node.querySelector('lyte-wormhole');

            //Sets the padding style based on user provide padding values
            if(this.$node.parentElement && this.$node.parentElement.tagName == 'LYTE-COLORPICKER'){
                this.$node.parentElement.component.childComp = this.childComp;
            }
            if(this.childComp.querySelector('lyte-popover-header')){
                this.childComp.querySelector('lyte-popover-header').style.padding = this.getData('ltPropHeaderPadding');
            }
            if(this.childComp.querySelector('lyte-popover-content')){
                this.childComp.querySelector('lyte-popover-content').style.padding = this.getData('ltPropContentPadding');
            }
            if(this.childComp.querySelector('lyte-popover-footer')){
                this.childComp.querySelector('lyte-popover-footer').style.padding = this.getData('ltPropFooterPadding');
            }
            this.actualModalDiv = this.childComp.querySelector(".lytePopover");
            if(this.childComp.querySelector('lyte-popover-header') && this.getData('ltPropShowCloseButton')){
                var headerHeight=0, closeHeight= 0;
                $L.fastdom.measure(function(){
                    headerHeight = this.childComp.querySelector('lyte-popover-header').getBoundingClientRect().height;
                    closeHeight = this.childComp.querySelector('.lytePopoverClose').getBoundingClientRect().height;
                },this);
                $L.fastdom.mutate(function(){
                    this.childComp.querySelector('.lytePopoverClose').style.top = (headerHeight - closeHeight) / 2 + "px";
                },this);
            }
            
            LyteComponent.appendChild(document.body,this.childComp)
            // console.log("appending");
        },
        close : function(){
           this.$node.ltProp("show",false);
        }
    }
});



if (document.readyState === "complete" || document.readyState === "interactive"){
    addPopoverEvent();
}
else{
    document.addEventListener("DOMContentLoaded", function(event){
        addPopoverEvent(event);
    });
}

function addPopoverEvent(event){

    document.addEventListener('click',function(event){
        var ele = event.target;
        while(!$L(ele).hasClass('popoverWrapper') && ele.tagName != "LYTE-POPOVER-FREEZE" && ele.tagName != 'LYTE-DROP-BOX' && ele.tagName != 'HTML'){
            ele = ele.parentElement;
            if(!ele){
                return
            }
        }
        if(ele.tagName == 'HTML' || ele.tagName == "LYTE-POPOVER-FREEZE"){
            for(var i = LytePopup.components.length -1 ; i>=0; i--){
                if(LytePopup.components[i].$node.tagName == "LYTE-POPOVER" && LytePopup.components[i].childComp.style.visibility == "visible"){
                    var popover = LytePopup.components[i].$node;
            
                    if(popover && popover.component.getData('visible') && popover.component.getData('ltPropCloseOnBodyClick')){
                        popover.component.setData('visible',false);
                        popover.ltProp('show',false);
                    }
                }
            }
        }
    },true);

    document.body.addEventListener('scroll',function(event){    //This is for closing the dropdown when an outside area is clicked(CODE HELP)
       // console.log("called scroll");
       if(LytePopup.makingVisible) {
        LytePopup.makingVisible = false;
        return;
       }
        var wormhole;
        for(var i=LytePopup.components.length-1;i>=0;i--){
            if(LytePopup.components[i].$node && LytePopup.components[i].$node.nodeName == "LYTE-POPOVER" && LytePopup.components[i].childComp.style.visibility == "visible"){
                wormhole = LytePopup.components[i].childComp;
                if(wormhole && wormhole._callee.component.$node.ltProp("scrollable")){
                    if(LytePopup.components[i].callOnScroll(event)){
                        var ele =  wormhole.querySelector('.lytePopover');
                        if(!ele){
                            return ;
                        }
                        while(ele.tagName != 'LYTE-WORMHOLE'){
                            ele = ele.parentElement
                        }
                        var curscroll = event.target
                        if(curscroll.nodeName == "#document"){     //This probably happens because scrollIntoView is used to focus the dropdown which is open at the start so the event.target is #document(CODE HELP)
                            return ;
                        }
                        while(curscroll.tagName != "LYTE-WORMHOLE" && curscroll.tagName != 'HTML'){
                            curscroll = curscroll.parentElement
                        }
                        if(curscroll.tagName == 'LYTE-WORMHOLE' && curscroll.isEqualNode(ele)){
                            return ;
                        }
                        // console.log("didnt return");
                        ele._callee.component.computeOffsetImpl();

                        var par = document.querySelector(ele._callee.ltProp('originElem'));
                        var screl = event.target
                        var pbcr = par.getBoundingClientRect();
                        var sbcr = screl.getBoundingClientRect();

                        var boundary = ele._callee.ltProp("boundary");
                        var popoverElem = ele.querySelector('.lytePopover');
                        if(!(Object.keys(boundary).length === 0 && boundary.constructor === Object)){
                            if(boundary.top && popoverElem.getBoundingClientRect().top < parseFloat(boundary.top)){
                                ele._callee.ltProp('show',false);
                            }
                            else if(boundary.bottom && popoverElem.getBoundingClientRect().bottom > parseFloat(boundary.bottom)){
                                ele._callee.ltProp('show',false);
                            }
                            else if(boundary.left && popoverElem.getBoundingClientRect().left < parseFloat(boundary.left)){
                                ele._callee.ltProp('show',false);
                            }
                            else if(boundary.right && popoverElem.getBoundingClientRect().right > parseFloat(boundary.right)){
                                ele._callee.ltProp('show',false);
                            }
                        }
                        // console.log("for moving up",sbcr.top,pbcr.top)
                        // console.log("for moving down",(sbcr.top+sbcr.height),(pbcr.top+pbcr.height))
                        if(ele.querySelector('#lytePopoverArrow') && ele.querySelector('#lytePopoverArrow').classList.contains('lytePopoverArrowBottom') && ((pbcr.top+(pbcr.height/2)) > window.innerHeight)){
                            ele._callee.ltProp('show',false);
                        }
                        if(sbcr.top > pbcr.top || (sbcr.top+sbcr.height)<(pbcr.top+pbcr.height) || (ele.querySelector('#lytePopoverArrow') && (ele.querySelector('#lytePopoverArrow').classList.contains('lytePopoverArrowLeft') || ele.querySelector('#lytePopoverArrow').classList.contains('lytePopoverArrowRight')) &&(ele.querySelector('#lytePopoverArrow').getBoundingClientRect().bottom >= ele.querySelector('.lytePopover').getBoundingClientRect().bottom))){
                            ele._callee.ltProp('show',false);
                        }
                        if(sbcr.left > pbcr.left || (sbcr.left+sbcr.width)<(pbcr.left+pbcr.width)){
                            ele._callee.ltProp('show',false);
                        }
                    }
                }
            }
        }
        
       
    },true);

    window.addEventListener("resize",function(event){
        if(LytePopup._lytePopoverRTId){
            // console.log(LytePopup._lytePopoverRTId);
            clearTimeout(LytePopup._lytePopoverRTId);
            LytePopup._lytePopoverRTId = false;
        }
        LytePopup._lytePopoverRTId = setTimeout(function(){
            for(var i = LytePopup.components.length - 1 ; i >= 0 ; i--){
                if(LytePopup.components[i].$node && LytePopup.components[i].$node.nodeName == "LYTE-POPOVER" && LytePopup.components[i].childComp.style.visibility == "visible" && LytePopup.components[i].childComp.querySelector('.lytePopover')){
                    LytePopup.components[i].$node.component.updateScrollHandling();
                    LytePopup.components[i].$node.component.computeOffsetImpl();
                    LytePopup.components[i].$node.component.callOnResize(event);
                }
            }
        },100);
    },true);

};


Lyte.Component.register('lyte-progressbar',{
_template:"<template tag-name=\"lyte-progressbar\">\t<template is=\"if\" value=\"{{lyteUiIfEquals(ltPropType,'circle')}}\">\t\t<template case=\"true\"><div class=\"lyteProgressBar lyteCircle\">\t\t\t<div class=\"lyteCircleType\">\t\t\t\t<svg class=\"svgValueEle\" width=\"{{lyteUiSetWH(ltPropRadius)}}\" height=\"{{lyteUiSetWH(ltPropRadius)}}\">\t\t\t\t    <circle style=\"{{lyteUiConcat('transition:','stroke-dashoffset ',duration,' ',timingfn,';')}}\" cx=\"{{ltPropRadius}}\" cy=\"{{ltPropRadius}}\" r=\"{{lyteUiSetRadius(ltPropRadius,ltPropStroke)}}\" fill=\"none\" stroke=\"#DCE0E3\" stroke-width=\"{{ltPropStroke}}\"></circle>\t\t\t\t    <circle style=\"{{lyteUiConcat('transition:','stroke-dashoffset ',duration,' ',timingfn,';')}}\" cx=\"{{ltPropRadius}}\" cy=\"{{ltPropRadius}}\" r=\"{{lyteUiSetRadius(ltPropRadius,ltPropStroke)}}\" fill=\"none\" stroke=\"{{ltPropBackground}}\" stroke-width=\"{{ltPropStroke}}\" stroke-dasharray=\"{{lyteUiSetDashArray(ltPropRadius,ltPropStroke)}}\" stroke-dashoffset=\"{{lyteUiSetOffset(ltPropRadius,ltPropStroke,percentage)}}\"></circle>\t\t\t\t</svg>\t\t\t\t<svg width=\"{{lyteUiSetWH(ltPropRadius)}}\" height=\"{{lyteUiSetWH(ltPropRadius)}}\" transform=\"{{lyteUiTextTransform(ltPropRadius)}}\" viewBox=\"{{lyteUiConcat('0 ','0 ',lyteUiSetWH(ltPropRadius),' ',lyteUiSetWH(ltPropRadius))}}\">\t\t\t\t\t<text font-size=\"1.5rem\" text-anchor=\"middle\" dy=\".2em\" x=\"50%\" y=\"50%\">{{lyteUiConcat(percentageDisplay,\"%\")}}</text>\t\t\t\t</svg>\t\t\t</div>\t\t</div></template>\t\t<template case=\"false\"><div class=\"lyteProgressBar lyteHorizontal\" style=\"{{lyteUiConcat('width:',ltPropWidth,';height:',ltPropHeight)}}\">\t\t\t<span class=\"lyteProgressStatus\" style=\"{{lyteUiConcat('width: ',percentage,'% ;','transition:','width ',duration,' ',timingfn,';','background:',ltPropBackground)}}\">\t\t\t\t<template is=\"if\" value=\"{{ltPropAnimated}}\">\t\t\t\t\t<template case=\"true\"><span class=\"ltPropProgressAnimated progressMovingObj\"></span></template>\t\t\t\t</template>\t\t\t\t<template is=\"if\" value=\"{{ltPropShowPercentage}}\">\t\t\t\t\t<template case=\"true\"><span class=\"lyteProgressPercentage\">{{lyteUiConcat(percentageDisplay,\"%\")}}</span></template>\t\t\t\t</template>\t\t\t</span>\t\t</div></template>\t</template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0,1,1]},{"type":"attr","position":[0,1,1,1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'transition:'","'stroke-dashoffset '","duration","' '","timingfn","';'"]}}}},{"type":"attr","position":[0,1,1,3],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'transition:'","'stroke-dashoffset '","duration","' '","timingfn","';'"]}}}},{"type":"attr","position":[0,1,3]},{"type":"text","position":[0,1,3,1,0]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width:'","ltPropWidth","';height:'","ltPropHeight"]}}}},{"type":"attr","position":[0,1],"attr":{"style":{"name":"style","helperInfo":{"name":"lyteUiConcat","args":["'width: '","percentage","'% ;'","'transition:'","'width '","duration","' '","timingfn","';'","'background:'","ltPropBackground"]}}}},{"type":"attr","position":[0,1,1]},{"type":"if","position":[0,1,1],"cases":{"true":{"dynamicNodes":[]}},"default":{}},{"type":"attr","position":[0,1,3]},{"type":"if","position":[0,1,3],"cases":{"true":{"dynamicNodes":[{"type":"text","position":[0,0]}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropValue","ltPropType","ltPropProgressFillColor","ltPropCompletedFillColor","ltPropWidth","ltPropHeight","ltPropRadius","ltPropStroke","ltPropValueCopy","ltPropAnimated","ltPropShowPercentage","ltPropProgressProperty","percentage","duration","timingfn","percentageDisplay"],
	didConnect: function(){
		// this.setData('ltPropValueCopy',this.getData('ltPropValue'));
		$L.fastdom.mutate(this.setBackground.bind(this))
	},
	data: function(){
		return {
			ltPropValue : Lyte.attr("string",{"default":'0'}),
			ltPropType : Lyte.attr("string",{"default":'bar'}),
			ltPropProgressFillColor : Lyte.attr("string",{"default":'#42a2eb'}),
			ltPropCompletedFillColor : Lyte.attr("string",{"default":'#3fbd5f'}),
			ltPropWidth : Lyte.attr("string",{"default":'100%'}),
			ltPropHeight : Lyte.attr("string",{"default":'12px'}),
			ltPropRadius : Lyte.attr("string",{"default":'50'}),
			ltPropStroke : Lyte.attr("string",{"default":'5'}),
			ltPropValueCopy : Lyte.attr("string",{"default":'0'}),
			ltPropAnimated : Lyte.attr("boolean",{"default": true}),
			ltPropShowPercentage : Lyte.attr("boolean",{"default": true}),
			ltPropProgressProperty : Lyte.attr('object',{"default" : {"value" : "0", "duration" : "0s"}}),
			percentage : Lyte.attr('string',{"default" : '0'}),
			duration : Lyte.attr('string',{"default" : '2s'}),
			timingfn : Lyte.attr('string',{"default" : 'linear'}),
			percentageDisplay : Lyte.attr('string',{"default" : '0'})
		}
	},
	didDestroy: function(){
		if(this.sid){
			window.clearTimeout(this.getData('sid'));
		}
		if(this.iId){
			window.clearInterval(this.getData('iId'));
		}
	},
	percentageChange : function(obj){
		this.setBackground();
	}.observes('ltPropProgressProperty'),
	setBackground : function(){
		// this.setData('ltPropValue',Math.round(this.getData('ltPropValue')));
		// this.setData('ltPropValueCopy',this.getData('ltPropValue'));
		var value = parseFloat(this.getData('ltPropProgressProperty').value);
		var duration = this.getData('ltPropProgressProperty').duration ? this.getData('ltPropProgressProperty').duration : this.getData('duration');
		if(this.getData('ltPropProgressProperty').timingfn){
			this.setData('timingfn',this.getData('ltPropProgressProperty').timingfn);
		}
		if(this.getData('ltPropType') === 'circle'){
			if(parseInt(value) >= 100){
				this.setData('duration',duration);
				this.setData('percentage','100');
				duration = parseFloat(duration) * 1000;
				var self = this;
				this.sid = setTimeout(function(){
					self.sid = false;
					self.$node.querySelector('.lyteProgressBar').classList.add('lyteProgressCompleted');
					self.setData('ltPropBackground',self.getData('ltPropCompletedFillColor'));
				},duration);
			}
			else{
				// console.log(this.sid);
				if(this.sid){
					clearTimeout(this.sid);
					this.sid = false;
				}
				this.$node.querySelector('.lyteProgressBar').classList.remove('lyteProgressCompleted');
				this.setData('ltPropBackground',this.getData('ltPropProgressFillColor'));
				this.setData('duration',duration);
				this.setData('percentage',value + "");
			}
		}
		else{
			if(parseInt(value) >= 100){
				this.setData('duration',duration);
				this.setData('percentage','100');
				// this.$node.querySelector('.lyteProgressStatus').style.width = "100%";
				duration = parseFloat(duration) * 1000;
				var self = this;
				this.sid = setTimeout(function(){
					this.sid = false;
					self.$node.querySelector('.lyteProgressBar').classList.add('lyteProgressCompleted');
					self.setData('ltPropBackground',self.getData('ltPropCompletedFillColor'));
					if(self.getData('ltPropAnimated')){
						self.$node.querySelector('.lyteProgressBar .ltPropProgressAnimated').classList.remove('progressMovingObj');	
					}
				},duration);
			}
			else{
				if(this.sid){
					clearTimeout(this.sid);
					this.sid = false;
				}
				this.$node.querySelector('.lyteProgressBar').classList.remove('lyteProgressCompleted');
				this.setData('ltPropBackground',this.getData('ltPropProgressFillColor'));
				if(this.getData('ltPropAnimated')){
					this.$node.querySelector('.lyteProgressBar .ltPropProgressAnimated').classList.add('progressMovingObj');	
				}
				// debugger
				this.setData('duration',duration);
				this.setData('percentage',value + "");

				// this.$node.querySelector('.lyteProgressStatus').style.width = value + "%";
			}
		}
		if(this.iId){
			clearInterval(this.iId);
			this.iId = false;
		}
		var p = parseFloat(this.getData('percentageDisplay')),
		self = this;
		if(parseInt(this.getData('duration')) == 0){
			this.setData('percentageDisplay', value+"");
		}
		else if(p > value){
			var diff = p - value;
			var margin = ((diff / (parseInt(this.getData('duration')) * 1000)) * 100);
			this.iId = setInterval(function(){
				p -= margin;
				self.setData('percentageDisplay',Math.max(parseFloat(p.toFixed(2)), value) + "");
				if(parseFloat(p) == value){
					clearInterval(self.iId);
					self.iId = false;
				}
			}, 100)
		}
		else if(p < value){
			var diff = value - p;
			var margin = ((diff / (parseInt(this.getData('duration')) * 1000)) * 100);
			this.iId = setInterval(function(){
				p += margin;
				// console.log(p, p.toFixed(2), value, Math.min(parseFloat(p.toFixed(2)), value),margin)
				if(!self.$node){
					clearInterval(self.iId);
				}
				self.setData('percentageDisplay',Math.min(parseFloat(p.toFixed(2)), value) + "");
				if(parseFloat(p) >= value){
					clearInterval(self.iId);
					self.iId = false;
				}
			}, 100)
		}
		
	},
	setCircleStroke: function(circle,val){
		var per = circle.getAttribute('stroke-dasharray') * (1 - parseInt(val)/100);
		circle.setAttribute('stroke-dashoffset', per);
	},
	actions:{
		
	}
});
Lyte.Component.register( 'lyte-radiobutton', {
_template:"<template tag-name=\"lyte-radiobutton\">\t<template is=\"switch\" value=\"{{ltPropType}}\"><template case=\"default\"></template><template case=\"primary\"></template><template case=\"secondary\">\t\t\t<label class=\"{{radioclass}}\" onmouseup=\"{{action('mup',event)}}\">\t\t\t\t<input type=\"radio\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" class=\"lyteHide\" onclick=\"{{action('valueChanged',event)}}\" disabled=\"{{ltPropDisabled}}\" checked=\"{{ltPropChecked}}\">\t\t\t\t<span class=\"{{ltPropClass}}\">\t\t\t\t\t<span class=\"lyteRadioCheck\">\t\t\t\t\t</span>\t\t\t\t</span>\t\t\t\t<span class=\"{{ltPropLabelClass}}\">\t\t\t\t\t{{ltPropLabel}}\t\t\t\t</span>\t\t\t</label>\t\t\t</template><template case=\"switch\">\t\t\t<label class=\"\" onmouseup=\"{{action('mup',event)}}\">\t\t\t\t<input type=\"radio\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{unbound(ltPropChecked)}}\" disabled=\"{{ltPropDisabled}}\" class=\"lyteHide on-off-sw\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('valueChanged',event)}}\">\t\t\t\t<span class=\"{{ltPropClass}}\">\t\t\t\t\t<span class=\"on-btn\"></span>\t\t\t\t</span>\t\t\t\t<span class=\"{{ltPropLabelClass}}\">\t\t\t\t\t{{ltPropLabel}}\t\t\t\t</span>\t\t\t</label>\t\t\t</template><template case=\"slider\">\t\t\t<label class=\"lyteRadioSliderLabel\" onmouseup=\"{{action('mup',event)}}\">\t\t\t\t<input type=\"radio\" id=\"{{ltPropId}}\" name=\"{{ltPropName}}\" value=\"{{ltPropValue}}\" checked=\"{{unbound(ltPropChecked)}}\" disabled=\"{{ltPropDisabled}}\" class=\"lyteHide\" readonly=\"{{ltPropReadonly}}\" onclick=\"{{action('valueChanged',event)}}\">\t\t\t\t<span class=\"{{ltPropClass}}\">\t\t\t\t\t<span class=\"{{ltPropLabelClass}}\">\t\t\t\t\t\t{{ltPropLabel}}\t\t\t\t\t</span>\t\t\t\t</span>\t\t\t\t\t\t\t</label>\t\t</template></template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"switch","position":[1],"cases":{"default":{"dynamicNodes":[],"additional":{"next":"primary"}},"primary":{"dynamicNodes":[],"additional":{"next":"secondary"}},"secondary":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,5]},{"type":"text","position":[1,5,1]}]},"switch":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,5]},{"type":"text","position":[1,5,1]}]},"slider":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,3]},{"type":"attr","position":[1,3,1]},{"type":"text","position":[1,3,1,1]}]}},"default":{}}],
_observedAttributes :["ltPropType","ltPropName","ltPropDisabled","ltPropChecked","ltPropLabel","ltPropValue","ltPropFireOnInit","ltPropLabelClass","ltPropClass","ltPropColor"],
	data: function() {
		return {
			'ltPropType': Lyte.attr( 'string', { 
				'default': 'default'
			} ),
			'ltPropName': Lyte.attr( 'string', { 
				'default': undefined
			} ),
			'ltPropDisabled': Lyte.attr( 'boolean', { 
				'default': false
			} ),
			'ltPropChecked': Lyte.attr( 'boolean', { 
				'default': false
			} ),
			'ltPropLabel': Lyte.attr( 'string', { 
				'default': undefined
			} ),
			'ltPropValue': Lyte.attr( 'string', { 
				'default': undefined
			} ),
			'ltPropFireOnInit': Lyte.attr( 'boolean', { 
				'default': false
			} ),
			'ltPropLabelClass': Lyte.attr( 'string', { 
				'default':'' 
			} ),
			'ltPropClass': Lyte.attr( 'string', { 
				'default': '' 
			} ),

			/* Experimental Feature */

			'ltPropColor': Lyte.attr( 'string', { 
				'default': '#72C98A'
			} )

			/* Experimental Feature */
		}
	},

	changeStyle: function() {
		this.changeStyleFunction()
	}.observes( 'ltPropType' ),

	changeStyleFunction: function() {

		var type = this.getData( 'ltPropType' ), 
		checked = this.getData('ltPropChecked'),
		cls = this.getData( 'ltPropClass' ), 
		labelCls = this.getData( 'ltPropLabelClass' );

		if( 
			type.indexOf( 'slider' ) === -1 
			&& type.indexOf( 'switch' ) === -1 
			&& type.indexOf( 'default' ) === -1 
			&& type.indexOf( 'primary' ) === -1 
			&& type.indexOf( 'secondary' ) === -1 
		) {
			this.setData( 'ltPropType', 'default' );
		}

		if( type.indexOf( 'default' ) !== -1 ) {
			this.setData( 'radioclass', 'lyteRadioBtn lyteDefault' )
			this.setData( 'ltPropClass', cls ? cls : 'lyteRadioLayer' ) 
			this.setData( 'ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel' )
		}
		else if( type.indexOf( 'primary' ) !== -1 && !cls ) {
			this.setData( 'radioclass', 'lyteRadioBtn lytePrimary' )
			this.setData( 'ltPropClass', cls ? cls : 'lyteRadioLayer' )
			this.setData( 'ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel' )
		}
		else if( type.indexOf( 'secondary' ) !== -1 && !cls ) {
			this.setData( 'radioclass', 'lyteRadioBtn lyteSecondary' )
			this.setData( 'ltPropClass', cls ? cls : 'lyteRadioLayer' )
			this.setData( 'ltPropLabelClass', labelCls ? labelCls : 'lyteRadioLabel' )
		}
		else if( type.indexOf( 'switch' ) !== -1 ) {
			this.setData( 'ltPropClass', cls ? cls : 'lyteRadioSwitch' )	
		}
		else if( type.indexOf('slider') !== -1 ) {
			this.setData( 'ltPropClass', cls ? cls : 'lyteRadioSlider' )	
			this.setData( 'ltPropLabelClass', labelCls ? labelCls : 'lyteRadioSliderText' )	
		}
	},

	reduceOpacity: function() {
		if( this.getData( 'ltPropDisabled' ) ) {
			this.$node.style.opacity = '0.5';
		}
		else {
			this.$node.style.opacity = '';
		}
	},

	disabledChange: function() {
		this.reduceOpacity();
	}.observes( 'ltPropDisabled' ),

	init: function() {
		this.reduceOpacity();
		this.changeStyleFunction();
	},

	didConnect: function() {
		this.colorizeSwitch( true );
		this.callMethodsOnInit( true );
	},

	colorizeSwitch: function( onrender ) {
		/* Experimental Features */

		var type = this.getData( 'ltPropType' ), 
		checked = this.getData( 'ltPropChecked' ),
		colorElement = this.$node.querySelector( '.lyteRadioSwitch' );

		if( type.indexOf( 'switch' ) !== -1 
			&& ( onrender && checked ) 
			|| !onrender 
		) {
			if( colorElement ) {
				colorElement.style.backgroundColor = this.getData( 'ltPropColor' );
			}
		}

		/* Experimental Features */
	},

	check: function( inp, comp ) {
		if( this.getMethods( 'onChecked' ) ) {
			this.executeMethod( 'onChecked', inp, comp );
		}
	},

	uncheck: function( inp, comp ) {
		if( this.getMethods( 'onUnchecked' ) ) {
			this.executeMethod( 'onUnchecked', inp, comp );
		}
	},

	beforeCheck: function( inp, comp ) {
		if( this.getMethods( 'onBeforeChecked' ) ) {
			this.executeMethod( 'onBeforeChecked', inp, comp );
		}
	},

	beforeUncheck: function( inp, comp ) {
		if( this.getMethods( 'onBeforeUnchecked' ) ) {
			this.executeMethod( 'onBeforeUnchecked', inp, comp );
		}
	},

	onchanged: function( inp, comp ) {
		if( this.getMethods( 'onChanged' ) ) {
			this.executeMethod( 'onChanged', inp, comp );
		}
	},

	extractRadios: function() {
		var name = this.getData( 'ltPropName' ), i = 0, tag,
		inp = document.querySelectorAll( 'input[type="radio"][name="' + name + '"]' );

		for( ; i < inp.length; i++ ) {
			tag = inp[ i ];
			while( tag.tagName !== 'LYTE-RADIOBUTTON' 
					&& tag.tagName !== 'HTML' 
			) {
				tag = tag.parentElement;
			}

			if( tag.tagName === 'LYTE-RADIOBUTTON'
				&& tag.ltProp( 'checked' ) 
				&& tag != this.$node
			) {
				return tag;
			}
		}
	},

	changeChecks: function( change ) {
		var radio = this.extractRadios(), 
		inp = radio && radio.querySelector( 'input' ),
		comp = radio && radio.component,
		cur = this.$node.querySelector( 'input' );

		// A checked radiobutton is checked
		// This check probably never executes because 
		// observers never fire when oldValue and newValue are the same. Its just a safety check
		if( change.newValue && change.oldValue ) {
			return ;
		}

		// A radiobutton that is different from the currently checked radiobutton is checked
		else if( change.newValue ) {
			this.setData( 'prevent', true );
			this.setData( 'ltPropChecked', false );

			// Unchecking the previously checked radiobutton and calling before uncheck callbacks
			if( radio ) {
				this.beforeUncheck( cur, this );
				comp.setData( 'prevent', true );
				radio.ltProp( 'checked', false );
				comp.setData( 'prevent', false );
			}

			this.beforeCheck( cur, this );
			this.setData( 'ltPropChecked', true );
			this.setData( 'prevent', false );

			// calling the uncheck callback of the previously checked radiobutton 
			if( radio ) {
				this.uncheck( cur, this );
			}

			this.check( cur, this );
			this.onchanged( cur, this );
		}

		// A radiobutton is unchecked but it was not previously unchecked
		else if( !change.newValue && change.oldValue ) {
			this.setData( 'prevent', true );
			this.setData( 'ltPropChecked', true );
			this.beforeUncheck( cur, this );
			this.setData( 'ltPropChecked', false );
			this.uncheck( cur, this );
			this.onchanged( cur, this );
			this.setData( 'prevent', false );
		}
 
	},

	change: function( change ) {

		var name = this.getData( 'ltPropName' ),
		input = document.querySelector( 'input[type="radio"][name="' + name + '"]:checked' );

		if( !this.getData( 'onChange' ) ) {
			this.changeChecks( change );
		}
		else {
			if( !change.newValue ) {
				this.uncheck( input, this.getData( 'second' ) );
			}
			else {
				this.check( input, this );
			}
		}	
	},

	unColorize: function( node ) {
		var type = this.getData( 'ltPropType' );

		if( type.indexOf( 'switch' ) !== -1 ) {
			node.nextElementSibling.style.backgroundColor = '';
		}
	},

	valueChanged: function( change ) {
		if( this.getData( 'prevent' ) ) {
			return ;
		}

		this.change( change );	
	}.observes( 'ltPropChecked' ),

	callMethodsOnInit: function() {
		var foi = this.getData( 'ltPropFireOnInit' ), 
		checked = this.getData( 'ltPropChecked' );

		if(	!foi ) {
			return ;
		}

		if( checked ) {
			var element = this.$node.querySelector( 'input' ),
			value = element.getAttribute( 'value' );

			this.beforeCheck( element, this );
			this.check( element, this );
			this.onchanged( element, this );
		}
	},

	actions: {
		mup: function( event ) {
			var name = this.getData( 'ltPropName' ), 
			checkedNode = document.querySelector( 'input[type="radio"][name="' + name + '"]:checked' );

			this.setData( 'shouldCallUnChecked', false );
			if( checkedNode ) {
				this.setData( 'prev', checkedNode.getAttribute( 'value' ) );
				this.setData( 'node', checkedNode );
				this.setData( 'shouldCallUnChecked', true );
			} 

			var element = this.$node.querySelector( 'input' ), checked = element.checked;

			if( element.disabled ) {
				return ;
			}

			if( !checked ) {
				if( this.getData( 'shouldCallUnChecked' ) ) {
					this.beforeUncheck( element, this );
				}

				this.beforeCheck( element, this );
			}
		},

		valueChanged: function( event ) {
			var ele = event.target, 
			val = ele.getAttribute( 'value' ), 
			prev = this.getData( 'prev' ), 
			node = this.getData( 'node' ),
			comp = node && node.parentElement.parentElement.component,
			parent = ele.parentElement.parentElement;

			event.stopPropagation();
			this.colorizeSwitch( false );
			if( val === prev ) {
				return ;
			}

			if( node ) {
				while( node.tagName !== 'LYTE-RADIOBUTTON' ) {
					node = node.parentElement;
				}

				comp.setData( 'onChange', true );

				// We are using a variable called second so that we can pass the current radiobutton's this to the callback.
				// We won't get the current radiobutton's this in a different radiobutton's observer - we are setting ltPropChecked to false below.
				comp.setData( 'second', this );
				node.ltProp( 'checked', false );
				comp.setData( 'second', undefined );
				comp.setData( 'onChange', false );
			}

			node = this.getData( 'node' );
			if( node ) {
				this.unColorize( node );
				this.setData( 'node', undefined );
			}

			this.setData( 'onChange', true );
			this.setData( 'ltPropChecked', true );
			this.setData( 'onChange', false );
			this.onchanged( ele, this );	
		}
	}
});
 

Lyte.Component.register("lyte-search",{
_template:"<template tag-name=\"lyte-search\">    <lyte-input lt-prop-auto-update=\"{{ltPropAutoUpdate}}\" lt-prop-tab-index=\"{{ltPropTabIndex}}\" lt-prop-id=\"{{ltPropId}}\" lt-prop-wrapper-style=\"{{ltPropWrapperStyle}}\" lt-prop-class=\"{{ltPropClass}}\" lt-prop-autofocus=\"{{ltPropAutofocus}}\" lt-prop-autocomplete=\"{{ltPropAutocomplete}}\" lt-prop-type=\"{{ltPropType}}\" lt-prop-name=\"{{ltPropName}}\" lt-prop-placeholder=\"{{ltPropPlaceholder}}\" lt-prop-width=\"{{ltPropWidth}}\" lt-prop-height=\"{{ltPropHeight}}\" onkeyup=\"{{action('keyup', event, this)}}\" lt-prop-style=\"{{ltPropStyle}}\" lt-prop-value=\"{{lbind(ltPropValue)}}\" onkeypress=\"{{action('keypress', event, this)}}\" lt-prop-appearance=\"{{ltPropAppearance}}\" lt-prop-direction=\"{{ltPropDirection}}\" lt-prop-disabled=\"{{ltPropDisabled}}\" lt-prop-readonly=\"{{ltPropReadonly}}\" on-value-change=\"{{method('valuechange')}}\" lt-prop-input-title=\"{{ltPropInputTitle}}\" lt-prop-pattern=\"{{ltPropPattern}}\"></lyte-input></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}],
_observedAttributes :["ltPropAutocomplete","ltPropPlaceholder","ltPropAutofocus","ltPropDisabled","ltPropStyle","ltPropMaxlength","ltPropReadonly","ltPropId","ltPropClass","ltPropType","ltPropName","ltPropWidth","ltPropHeight","ltPropValue","ltPropAppearance","ltPropDirection","ltPropQuerySelector","ltPropMinLength","ltPropMethod","ltPropWrapperStyle","ltPropTabIndex","ltPropAjaxRequest","ltPropAutoUpdate","ltPropPattern","ltPropInputTitle","timeout"],
   init : function(){
        if(this.getMethods('beforeRender'))
            {
                this.executeMethod('beforeRender', this.$node);
            }
        this.$node.focus = function(){
              this.$node.querySelector( 'input' ).focus();
        }.bind( this )      
      },
     didConnect : function(){
        this.$node.setValue = function(value){
              $L('lyte-input',this.$node).e[0].ltProp({'value' : value});
              this.pressFunc.call(this, value != undefined ? value : '', {})
        }.bind(this);
        if(this.getMethods('afterRender'))
            {
                this.executeMethod('afterRender', this.$node);
            }
     },

     data : function (){
      //user data
            return {
               ltPropAutocomplete : Lyte.attr("string",{"default" : 'off'}),
               ltPropPlaceholder : Lyte.attr("string",{"default" : ''}),
               ltPropAutofocus : Lyte.attr("boolean",{"default" : false}),
               ltPropDisabled : Lyte.attr("boolean",{"default" : false}),
               ltPropStyle : Lyte.attr("string",{"default" : ''}),
               ltPropMaxlength : Lyte.attr("number",{"default" : 25}),
               ltPropReadonly : Lyte.attr("boolean",{"default" : false}),
               ltPropId : Lyte.attr("string",{"default" : 'inputId'}),
               ltPropClass : Lyte.attr("string",{"default" : ''}),
               ltPropType : Lyte.attr("string",{"default" : 'search'}),
               ltPropName : Lyte.attr("string",{"default" : ''}),
               ltPropWidth : Lyte.attr("string",{"default" : '100%'}),
               ltPropHeight  : Lyte.attr("string",{"default" : ''}),
               ltPropValue : Lyte.attr("string",{"default" : ''}),
               ltPropAppearance : Lyte.attr("string",{"default" : 'flat'}),
               ltPropDirection : Lyte.attr("string",{"default" : 'vertical'}),
               ltPropQuerySelector : Lyte.attr("object",{"default" : {}}),
               ltPropMinLength : Lyte.attr('number',{'default' : 1}),
               ltPropMethod : Lyte.attr('string',{'default' : 'contains'}),
               ltPropWrapperStyle : Lyte.attr('string', {'default' : ''}),
               ltPropTabIndex : Lyte.attr('string',{default : '0'}),
               ltPropAjaxRequest : Lyte.attr("object",{"default":{}}),
               ltPropAutoUpdate : Lyte.attr('boolean', { default : true}),
               ltPropPattern : Lyte.attr('string', { default : '.+'}),
               ltPropInputTitle : Lyte.attr('string', { default : '' }),

               //system data
               timeout : Lyte.attr("number",{"default" : undefined}),

             }
         },

      methods : {

        valuechange : function(arg1){
            if(this.getMethods('onValueChange')){
               this.executeMethod('onValueChange', arg1, this.$node);
            }
        }
      },   

       arrayFrom : function(nodeList){
              var arrayList = [];
              for(var i = 0; i < nodeList.length; i++)
                {
                  arrayList.push(nodeList[i]);
                }
              return arrayList.slice(); 
             },  

// Function for finding textContents when data were not properly given for DOM search
      searchList : function(nodeName){
              var searchList=[];
              var target=[];
              query=this.getData('ltPropQuerySelector')
              if(typeof query =="string")
                  {
                      query=JSON.parse(query);
                  }
              for(var i=0;i<nodeName.childElementCount;i++)
                {
                  while(nodeName.children[i].childElementCount)
                     {
                        returnedVal=this.searchList.call(this,nodeName.children[i]);
                        searchList=searchList.concat(returnedVal[0]);
                        target=target.concat(returnedVal[1]);
                        break;
                     }
                  if(!nodeName.children[i].childElementCount) 
                      {
                        searchList.push(nodeName.children[i].textContent);
                        if(query.target)
                          {
                            var scope = typeof query.scope == 'string' ? ((/^#/g.test(query.scope.trim()) && !/\s/g.test(query.scope.trim())) ? $L(query.scope).e : $L(query.scope).e[0]) : query.scope
                            targetList=$L(query.target, scope).e;
                            node=nodeName.children[i];
                            while(node != scope)
                              {
                                var flag=false;
                                for(var j=0;j<targetList.length;j++)
                                  {
                                      if(node==targetList[j])
                                         {
                                            target.push(node);
                                            flag=true;
                                            break;
                                         }
                                  }
                                if(flag)
                                    {
                                        break;
                                    }
                                 else
                                   {
                                      node=node.parentElement;
                                   }
                              }
                          }
                        else
                          {
                            target.push(nodeName.children[i]);
                          }
                    }
                }
              return [searchList,target];
         },

     actions : {
         "keypress":function(event){             
               var keyCode = event.keyCode    
               if(!(keyCode >= 37 && keyCode <= 40) && keyCode != 13)  
                    {
                      event.stopPropagation() 
                    }  
            },
        //filtering process  checks
        "keyup":function(event, lyteInput){
              if([37,13,38,39,40,91,27,16,18].indexOf(event.keyCode) > -1){ 
                return
              }
              if(this.getData('timeout') != undefined)
                { 
                    clearTimeout(this.getData('timeout'))
                }
              var val = $L('input', this.$node).e[0].value;
              if(val.length >= this.getData('ltPropMinLength') || event.keyCode == 8)
                  {
                         this.setData('timeout', setTimeout(function(){  
                             this.pressFunc.call(this, val, event)
                           }.bind(this, event),100))
                  }    
            }
          },
        filteringArray : function(searchList, targetList, val, searchComp, evt){
            var flag, method = this.getData('ltPropMethod'), visibleList = [], hiddenList = [];
             if(val.length)
                {
                   for(var i = 0; i < searchList.length; i++)
                     {
                        switch(method)
                          {
                            case 'contains' : {
                                if(searchList[i].trim().toLowerCase().indexOf(val.toLowerCase()) >= 0)
                                    {
                                        visibleList.push(searchComp[i]);
                                    } else {
                                      hiddenList.push(searchComp[i])
                                    }
                                break;    
                             }
                             case 'startsWith' : {
                                  if(searchList[i].trim().toLowerCase().startsWith(val.toLowerCase()))
                                      {
                                        visibleList.push(searchComp[i]);
                                     }  else {
                                      hiddenList.push(searchComp[i])
                                    }
                                  break;
                             }
                             case 'endsWith' : {
                                  if(searchList[i].trim().toLowerCase().endsWith(val.toLowerCase()))
                                      {
                                          visibleList.push(searchComp[i]);
                                     }  else {
                                      hiddenList.push(searchComp[i])
                                    }
                                  break;
                             }
                          }  
                      }
                }
             else
                {
                   visibleList = searchComp;
                }
              if(this.getMethods('onSearch'))
                {
                  flag = this.executeMethod('onSearch',visibleList, this.$node, evt, val, hiddenList)
                }
              if(flag != false)
                {
                  var lyteSearchHidden = this.getData('ltPropHideClass')
                  $L.fastdom.mutate(function(){
                    // mismatched elements are hided here
                      for(var i = 0; i < searchList.length; i++)
                         {  
                            switch(method)
                              {
                                case 'contains' : {
                                    if(searchList[i].trim().toLowerCase().indexOf(val.toLowerCase()) < 0)
                                        {
                                           targetList[i].classList.add('lyteSearchHidden')
                                        }
                                      else
                                        {
                                           targetList[i].classList.remove('lyteSearchHidden')
                                        }  
                                    break;    
                                 }
                                 case 'startsWith' : {
                                      if(!searchList[i].trim().toLowerCase().startsWith(val.toLowerCase()))
                                          {
                                              targetList[i].classList.add('lyteSearchHidden')
                                           }
                                         else
                                          {
                                             targetList[i].classList.remove('lyteSearchHidden')
                                          }  
                                        break;
                                 }
                                 case 'endsWith' : {
                                      if(!searchList[i].trim().toLowerCase().endsWith(val.toLowerCase()))
                                          {
                                              targetList[i].classList.add('lyteSearchHidden')
                                          }
                                        else
                                         {
                                            targetList[i].classList.remove('lyteSearchHidden')
                                         }  
                                      break;
                                 }
                              }      
                         }
                  }.bind(this)) 
                }   
        },  
        pressFunc : function (val, evt){ 
                  var retVal;
                  if(this.getMethods("onBeforeSearch"))
                      { 
                         retVal = this.executeMethod('onBeforeSearch', evt, this);
                      }  
                   if(retVal != false)   
                    {
                       var content = [], searchList = [], target = [], query = this.getData('ltPropQuerySelector');
                       var scope = typeof query.scope == 'string' ? ( (/^#/g.test(query.scope.trim()) && !/\s/g.test(query.scope.trim())) ? $L(query.scope).e : $L(query.scope).e[0]) : query.scope;
                       if(query.search)
                          {
                            (/^#/g.test(query.search.trim()) && !/\s/g.test(query.search.trim())) ? searchList.push($L(query.search, scope).e) : searchList = searchList.concat(this.arrayFrom.call(this, $L(query.search, scope).e));
                          }
                       query.target ? ((/^#/g.test(query.target.trim()) && !/\s/g.test(query.target.trim())) ? target.push($L(query.target, scope).e) : target = target.concat(this.arrayFrom.call(this, $L(query.target, scope).e))) : (target = target.concat(searchList.slice()));  
                       if(!query.search)
                          {
                              returnedVal=this.searchList.call(this,scope);
                              content = returnedVal[0];
                              target = returnedVal[1];
                              searchList = target.slice();
                          }
                        else
                          {
                            for(var j=0;j<searchList.length;j++)
                             {
                                content[j]=searchList[j].textContent;
                             }
                          }
                      this.filteringArray.call(this, content, target, val, searchList, evt) 
                      this._prevVal = val; 
                }   
        }  
  });

Lyte.Component.register('lyte-slider',{
_template:"<template tag-name=\"lyte-slider\">\t<div class=\"lyteSlide {{if(ltPropDisabled, 'lyteSliderDisabled', '')}}\">\t\t<div class=\"lyteRangeSlider {{ltPropDirection}}\" onclick=\"{{action('click',event)}}\" tabindex=\"0\" onkeydown=\"{{action('keydown', event)}}\">\t\t\t<div class=\"lyteSliderFill\"></div>\t\t\t<div class=\"lyteSliderHandler {{ltPropHandler}} lyteHandler1\" lt-prop-title=\"{{if(expHandlers(ltPropTooltip, '&amp;&amp;', true), if(ltPropRangeHandler,ltPropMinValue, ltPropValue), '')}}\" tabindex=\"0\" onmousedown=\"{{action('mousedown', event, this)}}\" lt-prop-tooltip-config=\"{{ltPropTooltipConfig}}\" lt-prop-tooltip-style=\"{{ltPropTooltipStyle}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\"></div>\t\t\t<template is=\"if\" value=\"{{ltPropRangeHandler}}\"><template case=\"true\">\t\t\t\t\t<div class=\"lyteSliderHandler {{ltPropHandler}} lyteHandler2\" tabindex=\"0\" onmousedown=\"{{action('mousedown', event, this)}}\" lt-prop-title=\"{{if(ltPropTooltip, ltPropMaxValue, '')}}\" lt-prop-tooltip-config=\"{{ltPropTooltipConfig}}\" lt-prop-tooltip-style=\"{{ltPropTooltipStyle}}\" lt-prop-tooltip-class=\"{{ltPropTooltipClass}}\"></div>\t\t\t\t</template></template><template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\">\t\t\t\t<lyte-yield yield-name=\"yield\"></lyte-yield>\t\t\t</template><template case=\"false\">\t\t\t\t<div class=\"lyteScaleOption {{ltPropHandler}}\">\t\t\t\t\t<template is=\"for\" items=\"{{divLength}}\" index=\"indexVal\">\t\t\t\t\t\t<span class=\"lyteScaleLine\" style=\"{{item}}\">\t\t\t\t\t\t\t<span></span>\t\t\t\t\t\t\t<span class=\"lyteScalLable\">{{scaleVal[indexVal]}}</span>\t\t\t\t\t\t</span>\t\t\t\t\t</template>\t\t\t\t</div>\t\t\t </template></template>\t\t\t</div>\t</div>\t</template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"attr","position":[1,1,3]},{"type":"attr","position":[1,1,5]},{"type":"if","position":[1,1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]}]}},"default":{}},{"type":"attr","position":[1,1,6]},{"type":"if","position":[1,1,6],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1],"attr":{"style":{"name":"style","dynamicValue":"item"}}},{"type":"text","position":[1,3,0]}]}]}},"default":{}}],
_observedAttributes :["divLength","scaleVal","ltPropMin","ltPropMax","ltPropScaleInterval","ltPropStep","ltPropHandler","ltPropDirection","ltPropWidth","ltPropFillColor","ltPropNonFillColor","ltPropHeight","ltPropValue","ltPropDiscrete","ltPropContent","ltPropRangeHandler","ltPropMinValue","ltPropMaxValue","ltPropDisabled","ltPropSelectedValue1","ltPropSelectedValue2","ltPropYield","ltPropTooltipStyle","ltPropTooltip","ltPropScaleUnit","ltPropTooltipClass","ltPropTooltipConfig","ltPropMinDiff","preventObs"],
		init:function(){
			var config = this.setData( 'ltPropTooltipConfig' ), dir = this.getData('ltPropDirection'), style = this.getData('ltPropTooltipStyle');
			if( !config ) {
				this._config = true;
				this.setData('preventObs', true)
				this.$node.ltProp('tooltipConfig', { position : ( dir == 'lyteHorizontal' ? 'top' : 'right' ), showdelay : 500, margin : 10 })
				this.setData('preventObs', false)
			}

			if( !style ) {
				this._style = true;
				this.setData('preventObs', true)
				this.$node.ltProp('tooltipStyle', "background-color : " + this.getData('ltPropFillColor') + ";");
				this.setData('preventObs', false)
			}

			if( [ undefined, '', null ].indexOf( this.getData( 'ltPropScaleInterval' ) ) != -1 ) {
				this.setData('preventObs', true);
				var newScale;
				if( this.getData( 'ltPropHandler' ).indexOf( 'Arrow' ) != -1 ) {
					if( this.getData('ltPropContent').length == 0 ) {
						newScale = 0.1 * ( parseFloat( this.getData( 'ltPropMax' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) )
					}
				} 
				if( this.getData('ltPropContent').length ) {
					newScale = 'true';
				}
				if( newScale ) {
					this.setData( 'ltPropScaleInterval', newScale.toString() )
				}
				this.setData('preventObs', false);
			}
			if(this.getMethods('beforeRender'))
	            {
	                this.executeMethod('beforeRender', this.$node);
	            }
		},

		heightSetObs : function(){
			this.heightSet.call(this, arguments[0])
		}.observes('ltPropWidth','ltPropHeight'),

		heightSet : function (){
			var width = this.getData('ltPropWidth'), height = this.getData('ltPropHeight')
		    if(this.getData('ltPropDirection').indexOf('Horizontal')!=-1)
					{
						if(!width) {
								this.setData('ltPropWidth','200px')
								width = '200px';
							}
						if(!height) {
								this.setData('ltPropHeight','30px')
								height = '30px';
							}
					}
			else
				{
					if(!width){
							this.setData('ltPropWidth','30px')
							width = '30px'
						}
					if(!height){
							this.setData('ltPropHeight','200px')
							height = '200px';
						}
				}
		    this.$node.style.width = width;
			this.$node.style.height = height;
			if(arguments.length){
		   		this.didConnectWrk.call(this)   
			}
		},

		initialWorkObs : function(){
			if(this.getData('preventObs')){
				return;
			}
			this.setData('preventObs', true);
			this.initialWork.call(this, arguments[ 0 ]);
			this.setData('preventObs', false);
		}.observes('ltPropContent','ltPropMax','ltPropMin', 'ltPropScaleInterval','ltPropDiscrete','ltPropStep','ltPropValue', 'ltPropScaleUnit').on('init'),

		initialWork : function (arg){
			var ltPropContent = this.getData('ltPropContent').slice(), direction = this.getData('ltPropDirection'), discrete = this.getData( 'ltPropDiscrete' ), rangeHandler = this.getData( 'ltPropRangeHandler' );
			if( !ltPropContent.length )
				{
					var min = parseFloat( this.getData( 'ltPropMin' ) ), max = parseFloat( this.getData( 'ltPropMax' ) )
					if( !rangeHandler ) {
						var value = parseFloat( this.getData( 'ltPropValue' ) );
						if( value < min || isNaN( value ))
							{	
								this.setData('ltPropValue', min.toString());
							}
						else if( value > max)
							{
								this.setData('ltPropValue', max.toString());
							}
						this.setData('ltPropSelectedValue1', this.getData('ltPropValue'));
					} else {
						var minVal = parseFloat( this.getData( 'ltPropMinValue' ) ), maxVal = parseFloat( this.getData( 'ltPropMaxValue' ) );
						if( isNaN( minVal ) || minVal < min || minVal >= max ) {
							this.setData( 'ltPropMinValue', min.toString() );
						}
						if( isNaN( maxVal ) || maxVal > max || maxVal <= min) {
							this.setData( 'ltPropMaxValue', max.toString() );
						}
						this.setData('ltPropSelectedValue1', this.getData('ltPropMinValue'));
						this.setData('ltPropSelectedValue2', this.getData('ltPropMaxValue'));
					}	
					if( discrete ) {
						var minDiscrete = 0.1 * ( parseFloat( this.getData( 'ltPropMax' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) );
						discrete = parseFloat( discrete );
						discrete = Math.max( isNaN( discrete ) ? 0 : discrete, minDiscrete ).toString();
						this.setData( 'ltPropDiscrete', discrete);
						this.setData( 'ltPropStep', discrete );
						this.setData( 'ltPropScaleInterval', discrete );					
					}
				}
			else if(ltPropContent.length)
				{
					this.setData('ltPropMax','100');
					this.setData('ltPropStep',this.getData('ltPropScaleInterval'))
					if( this.getData( 'ltPropScaleInterval' ) || ( arg && arg.item == 'ltPropContent' ) ) {
						this.setData('ltPropScaleInterval', '' + parseFloat( 100 / ( ltPropContent.length - 1 ) ) + '')
					}
					this.setData('ltPropDiscrete',this.getData('ltPropScaleInterval'))
					if( !rangeHandler ) {
						if(!this.getData('ltPropValue'))
							{
								this.setData('ltPropValue',this.getData('ltPropContent')[0])
								this.setData('ltPropSelectedValue1', this.getData('ltPropValue'));	
							}	
					} else {
						var minVal = this.getData( 'ltPropMinValue' ), maxVal = this.getData( 'ltPropMaxValue' );
						if( !minVal || ltPropContent.indexOf( minVal ) == -1 || ( ltPropContent.indexOf( minVal ) > ltPropContent.indexOf( maxVal ) ) ) {
							 this.setData( 'ltPropMinValue', ltPropContent[ 0 ] );
						} 
						if( !maxVal || ltPropContent.indexOf( maxVal ) == -1 || ( ltPropContent.indexOf( minVal ) > ltPropContent.indexOf( maxVal ) ) ) {
							 this.setData( 'ltPropMaxValue', ltPropContent[ ltPropContent.length - 1 ] );
						} 
						this.setData('ltPropSelectedValue1', this.getData('ltPropMinValue'));
						this.setData('ltPropSelectedValue2', this.getData('ltPropMaxValue'));
					}	
				}	
			var array = []
			var scale = []
			if(!this.getData('ltPropYield'))	
				{
					var dirFlag = direction.indexOf('Horizontal') != -1 ? true : false, left = "top:", scaleint = parseFloat( this.getData( 'ltPropScaleInterval' ) );
					if(dirFlag){
						left = "left:"
					}


					if( scaleint && !isNaN( scaleint ) )
						{
	
							var temp = parseFloat(this.getData('ltPropMin')), scaleText = this.getData( 'ltPropScaleUnit' );
							for(var i=0;temp<=parseFloat(this.getData('ltPropMax'));i++)
								{
									array.push(left + (((temp-parseFloat(this.getData('ltPropMin')))/(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin'))))*100)+'%');
									if(this.getData('ltPropContent').length)
										{
											scale.push(ltPropContent[i] + scaleText)
										}
									else	
										{
											scale.push(temp + scaleText);
										}	
									temp+=parseFloat(scaleint);
								}
							var maxVal = ltPropContent.length ? ltPropContent[ltPropContent.length-1] : this.getData('ltPropMax');
							if(scale[scale.length-1]!=maxVal)
								{
									array.push(left + (100) + '%');
									if(ltPropContent.length)
										{
											scale.push(ltPropContent[ltPropContent.length - 1] + scaleText)
										}
									else	
										{
											scale.push(this.getData('ltPropMax') + scaleText);	
										}
								}	
						}
					else
						{
							array.push( left + 0 + '%');
							array.push( left + 100 + '%');
							scale=this.MaxMinSet.call(this);
							this.setData('scaleVal',scale);			
						}
			}
			this.setData('scaleVal', scale);
			this.setData('divLength', array);	
		},

		colorSetObs : function(arg){
			this.colorSet.call(this, arg);
		}.observes('ltPropFillColor','ltPropNonFillColor'),

		colorSet : function (arg) {
			if((!arg && this.getData('ltPropFillColor')) || (arg && arg.item == "ltPropFillColor"))
		    	{
		    		$L('div.lyteSliderFill', this.$node).e[0].style.backgroundColor=this.getData('ltPropFillColor');
		    	}
		    if((!arg &&this.getData('ltPropNonFillColor')) || (arg && arg.item == "ltPropNonFillColor"))
		    	{
		    		$L('div.lyteRangeSlider', this.$node).e[0].style.backgroundColor=this.getData('ltPropNonFillColor');
		    	}
		},

		didConnectWrkObs : function(){
			if(this.getData('preventObs')){
				return;
			}
			this.setData('preventObs', true);
			this.didConnectWrk.apply(this, arguments);
			this.setData('preventObs', false);
		}.observes('ltPropScaleInterval','ltPropValue','ltPropMin','ltPropMax','ltPropMinValue','ltPropMaxValue','ltPropContent','ltPropHandler','ltPropRangeHandler'),

		didConnectWrk : function () {
			var lyterangeFlag,handlers,nodeName,lyteRangeSlider= $L('div.lyteRangeSlider', this.$node).e[0], lyteSlide= $L('div.lyteSlide', this.$node).e[0];
			var handlers = $L('div.lyteSliderHandler', this.$node).e, rangeHandler = this.getData('ltPropRangeHandler'), direction = this.getData('ltPropDirection');
			var thisClientRect = this.$node.getBoundingClientRect(), handlersClientRect = handlers[0].getBoundingClientRect(), offParent = this.$node.offsetParent, objj = {};
			var width = "width", handlerWidth = "handlerWidth", left = "left", left1, left2, actWidth = {}, offsetWidth = 'offsetWidth', node;
			if( direction.indexOf('Horizontal') == -1) {
				width = "height"; handlerWidth = "handlerHeight", left = "top", offsetWidth = 'offsetHeight';
			}
			if( offParent == null ) {
				objj.width = parseFloat(this.getData('ltPropWidth'));
				objj.height = parseFloat(this.getData('ltPropHeight'));
				objj.handlerWidth = objj.handlerHeight = 12;
			} else {
				objj.width = thisClientRect.width;
				objj.height = thisClientRect.height;
				objj.handlerWidth = handlersClientRect.width;
				objj.handlerHeight = handlersClientRect.height;
			}
		      var lyteSliderFill= $L('div.lyteSliderFill', this.$node).e[0];
		      if(this.getData('ltPropContent').length)
					{
						var index1,index2,index = this.getData('ltPropContent').indexOf(this.getData('ltPropValue'));
						node= $L('div.lyteSliderHandler', this.$node).e;
						index = index > -1 ? index : 0 ;
						if(rangeHandler)
							{
								index1 = this.getData( 'ltPropContent' ).indexOf( this.getData( 'ltPropMinValue' ) );
								index1 = index1 != -1 ? index1 : 0;
								index2 = this.getData( 'ltPropContent' ).indexOf( this.getData( 'ltPropMaxValue' ) );
								index2 = index2 != -1 ? index2 : this.getData( 'ltPropContent' ).length - 1;
							}
						if(rangeHandler)
							{
								left1 = this.rangeInitialSet.call(this, offsetWidth, index1)
								left2 = this.rangeInitialSet.call(this, offsetWidth, index2)
								actWidth = this.rangeSliderFill(left1, left2, objj[handlerWidth])
							}
						else	
							{
								left1 = this.rangeInitialSet.call(this, offsetWidth, index)
								actWidth.width =  index / ( this.getData( 'ltPropContent' ).length - 1 ) * objj[ width ] ;
							}	
					}
				else if(!rangeHandler)
					{
						left1 = this.initialValueSet.call(this, objj[width], objj[handlerWidth] , parseFloat(this.getData('ltPropValue')))
						actWidth.width = ( ( parseFloat( this.getData( 'ltPropValue' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) ) / ( parseFloat( this.getData( 'ltPropMax' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) ) * objj[width] );
					}
				else
					{
						left1 = this.initialValueSet.call(this, objj[width], objj[handlerWidth], parseFloat( this.getData( 'ltPropMinValue' ) ) )
						left2 = this.initialValueSet.call(this, objj[width], objj[handlerWidth], parseFloat( this.getData( 'ltPropMaxValue' ) ) )
						actWidth = this.rangeSliderFill(left1, left2, objj[handlerWidth])
					}
			handlers[ 0 ].style[ left ] = left1 + 'px';
			lyteSliderFill.style[ width ] = actWidth.width + 'px';
			if( handlers[ 1 ] ) {
				handlers[ 1 ].style[ left ] = left2 + 'px';
				lyteSliderFill.style[ left ] = actWidth.left + 'px';
			}		
		},  

		directionObsObs : function(){
			this.directionObs.call(this);
		}.observes('ltPropDirection'),

		directionObs : function(){
			if(this.getData('preventObs')){
				return;
			}
			$L.fastdom.mutate(function(){
				var lyteSliderHandler = $L('.lyteSliderHandler', this.$node).e[0];
				lyteSliderHandler.style.removeProperty('left');
				lyteSliderHandler.style.removeProperty('top');
				var lyteSliderFill = $L('.lyteSliderFill', this.$node).e[0];
				lyteSliderFill.style.removeProperty('width');
				lyteSliderFill.style.removeProperty('height');
				this.setData('preventObs', true);
				this.heightSet.call(this);
				// this.initialWork.call(this);
				$L.fastdom.measure( function() {
					this.didConnectWrk.call(this);
					this.setData('preventObs', false);
				}.bind( this ))
			}.bind(this))
		},

		MaxMinSet:function(){
				var scale=[], scaleText = this.getData( 'ltPropScaleUnit' );
				if(this.getData('ltPropContent').length)
					{
						scale.push(this.getData('ltPropContent')[0] + scaleText);
						scale.push(this.getData('ltPropContent')[this.getData('ltPropContent').length-1] + scaleText)
					}
				else	
					{
						scale.push(this.getData('ltPropMin') + scaleText);
						scale.push(this.getData('ltPropMax') + scaleText);
					}
				return scale;	
		},
		selectedVal:function(clientRect, nodeClientRect,ltPropHeight,node,left){
			var selectedVal, lyteSlide = $L('div.lyteSlide', this.$node).e[0];
			var slideClientRect = clientRect[ltPropHeight];
			if(node)
				{
					selectedVal = (((parseFloat(node.style[ left ]) + nodeClientRect[ltPropHeight]/2)/slideClientRect)*(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))+parseFloat(this.getData('ltPropMin'))).toFixed(2);
				}
			else	
				{
					selectedVal = (( parseFloat( $L('div.lyteSliderFill',this.$node).e[0].style[ ltPropHeight ] ) / slideClientRect)*(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))+parseFloat(this.getData('ltPropMin'))).toFixed(2);
		  		}
		  	if(this.getData('ltPropContent').length)
		  		{
		  			numb = parseFloat(selectedVal)/parseFloat(this.getData('ltPropScaleInterval'));
		  			if(selectedVal>100)
		  				{
		  					selectedVal=this.getData('ltPropContent')[this.getData('ltPropContent').length - 1];
		  				}
		  			else
		  				{
		  					selectedVal=this.getData('ltPropContent')[parseInt(parseFloat(numb).toFixed(0))];
		  				}
		  		}
		  	return selectedVal;	
		},
		onSelect:function(flag){
			if(this.getMethods('onChange')||this.getMethods('onSelect'))
				{
					if(!this.getData('ltPropRangeHandler'))
						{
							if(this.getMethods('onChange'))	
								{
									this.executeMethod('onChange',this.getData('ltPropSelectedValue1'), this.$node)	
								}
							if(this.getMethods('onSelect') && flag)	
								{
									this.executeMethod('onSelect',this.getData('ltPropSelectedValue1'), this.$node)	
								}
						}
					else
						{
							if(this.getMethods('onChange'))	
								{
									this.executeMethod('onChange', this.getData('ltPropSelectedValue1'), this.getData('ltPropSelectedValue2'), this.$node);	
								}
							if(this.getMethods('onSelect') && flag)	
								{
									this.executeMethod('onSelect', this.getData('ltPropSelectedValue1'), this.getData('ltPropSelectedValue2'), this.$node);	
								}
						}
				}			
			},
		scroll:function(widthVal,offWidth){
				var discrete=parseFloat(this.getData('ltPropDiscrete'));
				var flag=false,flag1=false,flag2=false;
				if(widthVal>=parseFloat(this.getData('ltPropMax'))-(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))%discrete)
					{
						discrete=(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))%discrete;
						flag1=true;
						flag=true;
					}
				else if(widthVal-parseFloat(this.getData('ltPropDiscrete'))/2<(parseFloat(this.getData('ltPropMin'))))
					{
						flag=true;
						flag2=true;
					}
				if(flag)									
					{
						if(widthVal>parseFloat(this.getData('ltPropMax'))-discrete/2)
							{
								if(flag1)
									{
										widthVal=parseFloat(this.getData('ltPropMax'))
									}
								else
									{
										widthVal=widthVal-(widthVal-parseFloat(this.getData('ltPropMin')))%discrete+discrete;
									}
							}
						else
							{
								discrete=parseFloat(this.getData('ltPropDiscrete'))
								if(flag2)
									{
										widthVal=parseFloat(this.getData('ltPropMin'))
									}
								else
									{
										widthVal=widthVal-(widthVal-parseFloat(this.getData('ltPropMin')))%discrete;
									}
							}
					}
				else
					{
						if((widthVal-parseFloat(this.getData('ltPropMin')))%discrete>=parseFloat(this.getData('ltPropDiscrete'))/2)
							{
								widthVal=widthVal-(widthVal-parseFloat(this.getData('ltPropMin')))%discrete+discrete;
							}
						else
							{
								widthVal=widthVal-(widthVal-parseFloat(this.getData('ltPropMin')))%discrete;
							}
					}		
				width=((widthVal-parseFloat(this.getData('ltPropMin')))/(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))*offWidth)
				return width;
		},	
		ScrollCheck:function(node,left1,width1,clientX1,offsetWidth1,ltPropWidth1,offsetLeft1,event){
			var step, flag = true, lyteHandler2, lyteHandler1, lyteRangeSlider, lyteSlide = $L( 'div.lyteSlide', this.$node ).e[ 0 ], handler1Client, handler2Client;
			var rangeHandler = this.getData( 'ltPropRangeHandler' ), sliderFill = $L('div.lyteSliderFill', this.$node).e[0];
			if( !rangeHandler )
				{	
					width = event[clientX1]- sliderFill.getBoundingClientRect()[left1];
				}
			else
				{
				    lyteHandler2 = $L('div.lyteHandler2', this.$node).e[0],lyteHandler1= $L('div.lyteHandler1', this.$node).e[0], lyteRangeSlider=$L('div.lyteRangeSlider', this.$node).e[0];
				    handler1Client = lyteHandler1.getBoundingClientRect(), handler2Client = lyteHandler2.getBoundingClientRect();
					if(( handler2Client[ left1 ] - handler1Client[ left1 ] ) <= 0)	
						{
							if(this._elem)
								{
									if( this._elem.classList.contains( 'lyteHandler1' ) )
										{
											if( event[ clientX1 ] < ( handler1Client[ left1 ] + handler1Client[ width1 ] ) && ( handler2Client[ left1 ] - handler1Client[ left1 ] ) == 0 )
												{
													flag = true;
												}
											else
												{	
													if(event.type == 'mousemove')
														{
														  flag = false
														}
												}	
										}
									else if(this._elem.classList.contains('lyteHandler2'))
										{
											if( event[ clientX1 ] > ( handler2Client[ left1 ] ) && ( handler2Client[ left1 ] - handler1Client[ left1 ] ) == 0 )
												{   
													flag=true;
												}
											else
												{
													if(event.type=='mousemove')
														{
															flag=false
														}
												}	
										}
								}		
							else
								{
									if(event.type=='mousemove')
										{
											flag=false
										}
								}	
						}	
					else
						{
							step = this.getData('ltPropDiscrete') ? parseFloat( this.getData( 'ltPropDiscrete' ) ) : 0;
						}	 
				width = event[ clientX1 ] - lyteRangeSlider.getBoundingClientRect()[ left1 ];	
				}
			if( this.getData( 'ltPropContent' ).length && event.type == 'click' )
				{
					if( rangeHandler )
						{
							if( parseInt( handler2Client[ left1 ] - handler1Client[ left1 ] ) < 1 / ( this.getData( 'ltPropContent' ).length - 1 ) * this.$node[ ltPropWidth1 ] && event[ clientX ] < ( handler2Client[ left1 ] + handler2Client[ width1 ]) && event[ clientX ] > ( handler1Client[ left1 ] + handler1Client[ width1 ] ) )
								{
									flag = false
								}
						}
				}		
			var discrete=parseFloat(this.getData('ltPropDiscrete')), lyteSliderHandler= $L('div.lyteSliderHandler', this.$node).e[0];
			var nodeClientRect = node.getBoundingClientRect(), slideClientRect = lyteSlide.getBoundingClientRect()
			if(this.getData('ltPropDiscrete'))
				{	
					widthVal=((width/slideClientRect[width1])*(parseFloat(this.getData('ltPropMax'))-parseFloat(this.getData('ltPropMin')))+parseFloat(this.getData('ltPropMin')))
					width=this.scroll.call(this,widthVal, slideClientRect[width1]);		
				}
				width=width < slideClientRect[width1] ? width : slideClientRect[width1];
				width=width>0?width:0;	
				left=(width-nodeClientRect[width1]/2);
				left=left>(slideClientRect[width1] -lyteSliderHandler[offsetWidth1]/2) ? slideClientRect[width1] - lyteSliderHandler[offsetWidth1]/2:left;
				left=left>-nodeClientRect[width1]/2?left:-nodeClientRect[width1]/2;
			// $L.fastdom.measure(function(){
				if( rangeHandler )
					{
						if(node.classList.contains('lyteHandler1'))
							{	
								if(lyteHandler2[offsetLeft1]<left)
									{
										flag=false
									}
							}
						else
							{
								if(lyteHandler1[offsetLeft1]>left)
									{
										flag=false
									}
							}	
					}
				// $L.fastdom.measure(function(){
					// selected node need to be focused for keyboard events
					node.focus()
				// });
					if(flag)
						{
							if( !rangeHandler )
								{
									sliderFill.style[width1]=width+'px';
								}
							else
								{
									var leftx, lefty;
									if(node.classList.contains( 'lyteHandler1' )) {
										lefty = parseInt( lyteHandler2.style[ left1 ] )
										var co = this.minMaxCheck( slideClientRect, handler1Client, width1 )
										left = Math.min( Math.max( left, co[ 0 ] ), lefty - co[ 1 ] );
										leftx = left;
									} else {
										leftx = parseInt( lyteHandler1.style[ left1 ] )
										var co = this.minMaxCheck( slideClientRect, handler1Client, width1, true );
										left = Math.max( Math.min( left, co[ 0 ] ), leftx + co[ 1 ]);
										lefty = left;
									}
									var acWid = this.rangeSliderFill.call(this, leftx, lefty, handler1Client [ width1 ]);
									sliderFill.style[ left1 ] = acWid.left + 'px';
									sliderFill.style[ width1 ] = acWid.width + 'px';

								}
							node.style[ left1 ] = left + 'px';	
						}
					$L.fastdom.measure(function(){	
						this.selectedValFind.call(this, slideClientRect, nodeClientRect)	
					}.bind(this));
			event.stopPropagation();
			event.preventDefault();
		},

		minMaxCheck : function( slideClientRect, handler1Client, width1, flag ){
			var diffVal = this.getData( 'ltPropMinDiff' ) || 0, conv = diffVal * slideClientRect[ width1 ] / ( parseFloat( this.getData( 'ltPropMax' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) );
			if( !flag ) {
				left1 = conv - ( handler1Client[ width1 ] / 2 )
			} else {
				left1 = slideClientRect[ width1 ] - conv - ( handler1Client[ width1 ] / 2 )
			}
			return [ left1, conv ]
		},

		selectedValFind : function(clientRect, nodeClientRect){
			// $L.fastdom.measure(function(){
				this.setData('preventObs', true)
				if(!this.getData('ltPropRangeHandler'))
					{
						if(this.getData('ltPropDirection').indexOf('Horizontal')==-1)
							{
								this.setData('ltPropValue',this.selectedVal.call(this, clientRect, nodeClientRect,'height').toString());
							}
						else
							{
								this.setData('ltPropValue',this.selectedVal.call(this, clientRect, nodeClientRect,'width').toString());
							}
						this.setData('ltPropSelectedValue1',this.getData('ltPropValue'));	
					}
				else
					{
						if(this.getData('ltPropDirection').indexOf('Horizontal')==-1)
							{
								this.setData('ltPropMinValue',this.selectedVal.call(this, clientRect, nodeClientRect, 'height', $L('div.lyteHandler1', this.$node).e[0], 'top').toString());
								this.setData('ltPropMaxValue',this.selectedVal.call(this, clientRect, nodeClientRect, 'height', $L('div.lyteHandler2', this.$node).e[0],'top').toString());
							}
						else
							{
								this.setData('ltPropMinValue', this.selectedVal.call(this, clientRect, nodeClientRect, 'width', $L('div.lyteHandler1', this.$node).e[0],'left').toString());
								this.setData('ltPropMaxValue',this.selectedVal.call(this, clientRect, nodeClientRect, 'width', $L('div.lyteHandler2', this.$node).e[0],'left').toString());
							}
						this.setData('ltPropSelectedValue1',this.getData('ltPropMinValue'));
						this.setData('ltPropSelectedValue2',this.getData('ltPropMaxValue'));	
					}	
				this.setData('preventObs', false)
			// }.bind(this))
		},

		initialValueSet : function(width, handlerWidth, value){
			var max = parseFloat( this.getData( 'ltPropMax' ) ), min = parseFloat( this.getData( 'ltPropMin' ) );
			return ( ( ( value - min ) / ( max - min ) * ( width ) ) - ( handlerWidth ) / 2 )
		},
		rangeSliderFill:function(left1, left2, handlerWidth){
			return {width : left2 - left1, left : left1 + handlerWidth / 2 }
		},
		keyCheck:function(event, node,width1,left1,offsetWidth,ltPropWidth){
			// while keydown action
			var flag=true, lyteSliderFill = $L('div.lyteSliderFill', this.$node).e[0];
			var nodeClientRect = node.getBoundingClientRect(), left, actWidth = {}, rangeHandler = this.getData('ltPropRangeHandler');
			var thisRect = this.$node.getBoundingClientRect(), fact = 1, handlers = $L('div.lyteSliderHandler', this.$node).e;
			var direction = this.getData('ltPropDirection').indexOf('Horizontal') != -1;
			var step = parseFloat(this.getData('ltPropStep'));
			if( !step ) {
				step = parseFloat( this.getData( 'ltPropMax' ) ) * .1;
			}
			if( event.keyCode == 37 && direction || event.keyCode == 38 && !direction ) {
				fact = -1
			}

			left = parseFloat( node.style[ left1 ] ) + ( step / ( parseFloat( this.getData( 'ltPropMax' ) ) - parseFloat( this.getData( 'ltPropMin' ) ) ) * thisRect[ width1 ] * fact );
			left  = Math.min( Math.max( -nodeClientRect[ width1 ] / 2, left), thisRect[ width1 ] -nodeClientRect[ width1 ] / 2 )
			if( !rangeHandler ) {
				actWidth.width  =  left + nodeClientRect[ width1 ] / 2 ;
			} else {
				var leftx, lefty;
				if(node == handlers[0]){
					lefty = parseInt( handlers[ 1 ].style[ left1 ] )
					var co = this.minMaxCheck( thisRect, nodeClientRect, width1 )
					left = Math.min( Math.max( left, co[ 0 ] ), lefty - co[ 1 ] );
					leftx = left;
				} else {
					leftx = parseInt( handlers[ 0 ].style[ left1 ] )
					var co = this.minMaxCheck( thisRect, nodeClientRect, width1, true );
					left = Math.max( Math.min( left, co[ 0 ] ), leftx + co[ 1 ]);
					lefty = left;
				}
				if( leftx > lefty ) {
					var currLeft = parseInt( handlers[ 0 ].style[ left1 ] );
					if( currLeft == lefty ) {
						return
					} else {
						if( event.keyCode == 37 || event.keyCode == 38 ) {
							lefty = left = leftx;
						} else if( event.keyCode == 39 || event.keyCode == 40 ) {
							leftx = left = lefty;
						}
					}
				}
				actWidth = this.rangeSliderFill.call(this, leftx, lefty, nodeClientRect[width1]);
			}
			node.style[ left1 ] = left + 'px';
			lyteSliderFill.style[ width1 ] = actWidth.width + 'px';
			if(rangeHandler) {
				lyteSliderFill.style[ left1 ] = actWidth.left + 'px';
			}
			$L.fastdom.measure(function(){
				this.selectedValFind.call(this, thisRect, nodeClientRect)
			}.bind(this))
		},
		mousemove : function(event){
			if(!this._flag ) {
				this._flag = true;
			}
			var left, width, clientX, offsetWidth, offsetWidth, ltPropWidth
			if( this.getData( 'ltPropDirection' ).indexOf( 'Horizontal' ) != -1 )
				{
					left = 'left', width = 'width', clientX = 'clientX', offsetWidth = 'offsetWidth', offsetWidth = 'offsetWidth', ltPropWidth = 'ltPropWidth', offsetLeft = 'offsetLeft';
				}
			else
				{
					left = 'top', width = 'height', clientX = 'clientY', offsetWidth = 'offsetHeight', offsetWidth = 'offsetHeight', ltPropWidth = 'ltPropHeight', offsetLeft = 'offsetTop';
				}
				this.ScrollCheck.call( this, this._elem, left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
				$L.fastdom.measure(function(){
					if( this.getMethods( 'onChange' ) )	{
						this.onSelect.call( this );	
					}
			}.bind(this))			
		},
		eventListener:function(event, elem){
			var xPos = event.clientX, lyteRangeSlider = $L( 'div.lyteRangeSlider', this.$node ).e[ 0 ];
			var clientRect = lyteRangeSlider.getBoundingClientRect()
			if( xPos > clientRect.left ) {
					width = xPos - clientRect.left - parseFloat( clientRect.width - parseFloat( clientRect.width / 2 ) );
					if( width > 0 ) {
							event.preventDefault();
						}
				}
			else {
					event.preventDefault();
				}
			var yPos = event.clientY;
			if( yPos >= clientRect.top ) {
					height = yPos - clientRect.top - parseFloat( clientRect.height - parseFloat( clientRect.height / 2 ) );
					if( height > 0 ) {
						event.preventDefault();
					}
				}
			else {
					event.preventDefault();
				}
			this._mousemove = this.mousemove.bind(this);
			this._mouseup = this.mouseup.bind(this);
			this._elem = elem;	
			document.addEventListener('mousemove', this._mousemove,true);
			document.addEventListener('mouseup', this._mouseup, true);
		}, 
		rangeInitialSet:function(offsetWidth,index){
			return ( index / ( this.getData( 'ltPropContent' ).length - 1 ) * this.$node[ offsetWidth ] - $L( 'div.lyteSliderHandler', this.$node ).e[ 0 ][ offsetWidth ] / 2 );
		},
		didConnect:function(){			  
		    this.directionObs.call(this)
		    this.valueSelected.call(this);
		    $L.fastdom.mutate(function(){
    			if(this.getMethods('afterRender')){
	             	this.executeMethod('afterRender', this.$node);
	         	}
		    }.bind(this))	
		},
		valueSelected : function(){
			if(this.getData('ltPropRangeHandler'))
				{
					this.setData('ltPropSelectedValue1', this.getData('ltPropMinValue'));
					this.setData('ltPropSelectedValue2', this.getData('ltPropMaxValue'));
				}
			else
				{
					this.setData('ltPropSelectedValue1', this.getData('ltPropValue'));
				}	
		},
		mouseup : function(event){
			var handler=$L('div.lyteRangeSlider', this.$node).e[0];
			document.removeEventListener('mousemove',this._mousemove,true);
			document.removeEventListener('mouseup', this._mouseup, true);
			delete this._mousemove;
			delete this._elem;
		},

		data:function(){
			return {
				divLength:Lyte.attr("array",{"default":[]}),
				scaleVal:Lyte.attr("array",{"default":[]}),
				ltPropMin:Lyte.attr("string",{"default":'0'}),
				ltPropMax:Lyte.attr("string",{"default":''}),
				ltPropScaleInterval:Lyte.attr("string",{"default":''}),
				ltPropStep:Lyte.attr("string",{"default":''}),
				ltPropHandler:Lyte.attr("string",{"default":'lyteArrow'}),
				ltPropDirection:Lyte.attr("string",{"default":'lyteHorizontal'}),
				ltPropWidth:Lyte.attr("string",{"default":''}),
				ltPropFillColor:Lyte.attr("string",{"default":''}),
				ltPropNonFillColor:Lyte.attr("string",{"default":''}),
				ltPropHeight:Lyte.attr("string",{"default":''}),
				ltPropValue:Lyte.attr("string",{"default":''}),
				ltPropDiscrete:Lyte.attr("string",{"default":''}),
				ltPropContent:Lyte.attr("array",{"default":[]}),
				ltPropRangeHandler:Lyte.attr("boolean",{"default": false}),
				ltPropMinValue:Lyte.attr("string",{"default":''}),
				ltPropMaxValue:Lyte.attr("string",{"default":''}),
				ltPropDisabled:Lyte.attr("boolean",{"default": false}),
				ltPropSelectedValue1 : Lyte.attr('string', {default : ''}),
				ltPropSelectedValue2 : Lyte.attr('string', {default : ''}),
				ltPropYield : Lyte.attr('boolean', {default : false}),
				ltPropTooltipStyle : Lyte.attr('string', { default : ''}),
				ltPropTooltip : Lyte.attr( 'boolean', { default : true}),
				ltPropScaleUnit : Lyte.attr( 'string' , { default : '' } ),
				ltPropTooltipClass : Lyte.attr('string', { default : ''}),
				ltPropTooltipConfig : Lyte.attr('object'),
				ltPropMinDiff : Lyte.attr( 'number', { default : 0 } ),

				//system data
				preventObs : Lyte.attr('boolean', { default : false})
			}
		},
		actions:{
			"click":function(event){
					var left = 'left', width = "width", clientX = 'clientX', offsetWidth = 'offsetWidth', ltPropWidth = 'ltPropWidth', offsetLeft = 'offsetLeft';
					if(this.getData('ltPropDirection').indexOf('Horizontal')==-1)
						{
							left = 'top', width = "height", clientX = 'clientY', offsetWidth = 'offsetHeight', ltPropWidth = 'ltPropHeight', offsetLeft = 'offsetTop'
						}
					if(!this.getData('ltPropRangeHandler'))
						{
							this.ScrollCheck.call(this, $L('div.lyteSliderHandler', this.$node).e[0], left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
						}
					else
						{
							var YPos= event[clientX];
							var node1= $L('div.lyteHandler1', this.$node).e[0]
							var node2= $L('div.lyteHandler2', this.$node).e[0]
							var node1client = node1.getBoundingClientRect(), node2client = node2.getBoundingClientRect();
							if( Math.abs(node1client[left] - node2client[left]) > 0 )
								{
									if(node1client[ left ] + node1client[ width ] + Math.abs(node1client[ left ] - node2client[ left ]) / 2 < YPos)
										{
											this.ScrollCheck.call(this,node2,left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
										}
									else if(node1client[ left ] + node1client[ width ] + Math.abs(node1client[ left ] - node2client[ left ]) / 2 != YPos)
										{
											this.ScrollCheck.call(this,node1,left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
										}	
								}
							else if(node1client[ left ] == node2client[ left ])		
								{	
									if(YPos<node1client[ left ])	
										{
											this.ScrollCheck.call(this,node1,left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
										}
									else
										{
											this.ScrollCheck.call(this,node2,left, width, clientX, offsetWidth, ltPropWidth, offsetLeft, event);
										}	
								}
						}
					$L.fastdom.measure(function(){
						this.onSelect.call(this, true);	
					}.bind(this))
					event.stopPropagation();
					event.stopImmediatePropagation();
					event.preventDefault();
			},
			"keydown":function(event){
					if([ 37, 38, 39, 40].indexOf( event.keyCode ) == -1){
						return
					}
					if(this.getData('ltPropDiscrete'))
						{
							this.setData('ltPropStep',this.getData('ltPropDiscrete'));
						}
					var node = event.target, direction = this.getData('ltPropDirection');
					var width = 'width', left = "left", offsetWidth = "offsetWidth", ltPropWidth = "ltPropWidth";
					if( direction.indexOf( 'Horizontal' ) == -1 )
						{
							width = 'height', left = "top", offsetWidth = "offsetHeight", ltPropWidth = "ltPropHeight";	
						}	
					if(!this.getData('ltPropRangeHandler'))
						{
							this.keyCheck.call(this, event, $L('div.lyteSliderHandler', this.$node).e[0], width, left, offsetWidth, ltPropWidth)
						}
					else
						{
							this.keyCheck.call(this,event, node, width, left, offsetWidth, ltPropWidth)	
						}

					if(((event.keyCode==37||event.keyCode==39) && direction.indexOf('Horizontal') != -1)||((event.keyCode==38||event.keyCode==40) && direction.indexOf('Horizontal') == -1))
						{
							$L.fastdom.measure(function(){
								this.onSelect.call(this,true);
							}.bind(this))
							event.stopPropagation();
							event.stopImmediatePropagation();
							event.preventDefault();
						}
			},

			"mousedown" : function( evt , elem) {
				this.eventListener.call(this, evt, elem)
			}
		}
	});

Lyte.Component.register('lyte-step',{
_template:"<template tag-name=\"lyte-step\">\t<div onclick=\"{{action('divClick', event, this)}}\">\t\t<template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\">\t\t\t\t\t<lyte-step-structure class=\"{{ltPropClass}}\" onclick=\"{{action('divClick', event, this)}}\">\t\t\t\t\t\t<template is=\"for\" items=\"{{ltPropData}}\" item=\"array\" index=\"indexVal\"><template is=\"if\" value=\"{{expHandlers(lyteUiIsObject(array),'==',false)}}\"><template case=\"true\"><template is=\"if\" value=\"{{expHandlers(ltPropClass,'==','lyteStageOne')}}\"><template case=\"true\">\t\t\t\t \t\t\t\t\t\t\t  <lyte-step-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick', event, this, array)}}\"> \t  <lyte-step-body> {{array}} </lyte-step-body> \t\t\t\t \t\t\t\t\t\t\t\t\t<lyte-step-head>{{indexVal}}</lyte-step-head>\t\t\t\t \t\t\t\t\t\t\t\t</lyte-step-item>\t\t\t\t \t\t\t\t\t\t\t</template><template case=\"false\"> \t\t\t\t\t\t\t\t\t\t\t  <lyte-step-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick', event, this, array)}}\"> \t <lyte-step-body> {{array}} </lyte-step-body>\t\t\t\t\t\t\t\t\t\t\t\t</lyte-step-item>\t\t\t\t\t\t\t\t\t\t </template></template></template><template case=\"false\"><template is=\"if\" value=\"{{expHandlers(ltPropClass,'==','lyteStageOne')}}\"><template case=\"true\">\t\t\t\t\t\t\t\t\t\t\t\t<lyte-step-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick', event, this, array)}}\"> \t\t\t\t\t\t\t\t\t\t\t\t\t\t<lyte-step-body> {{array[ltPropLabel]}} </lyte-step-body> \t\t\t\t\t\t\t\t\t\t\t\t\t<lyte-step-head>{{array[ltPropOption]}}</lyte-step-head>\t\t\t\t\t\t\t\t\t\t\t\t</lyte-step-item>\t\t\t\t\t\t\t\t\t\t\t</template><template case=\"false\"> \t\t\t\t\t\t\t\t\t\t\t   <lyte-step-item sporder=\"{{indexVal}}\" onclick=\"{{action('onclick', event, this, array)}}\"> \t\t\t\t\t\t\t\t\t\t\t\t   \t    <lyte-step-body> {{array[ltPropLabel]}} </lyte-step-body>\t\t\t\t\t\t\t\t\t\t\t   </lyte-step-item>\t\t\t\t\t\t\t\t\t\t  </template></template></template></template></template>\t\t\t\t\t</lyte-step-structure>\t\t\t\t\t</template><template case=\"false\">\t\t\t\t\t<lyte-yield yield-name=\"yield\"></lyte-yield>\t\t\t </template></template>\t\t</div>\t\t</template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"text","position":[1,3,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"text","position":[1,3,0]},{"type":"componentDynamic","position":[1,3]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1,1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}}]},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropClass","ltPropData","ltPropSelected","ltPropSkip","ltPropActiveClass","ltPropCompletedClass","ltPropWarningClass","ltPropKeepMarked","ltPropYield","ltPropLabel","ltPropOption"],
    init : function(){
        if(this.getMethods('beforeRender'))
            {
                this.executeMethod('beforeRender', this.$node);
            }
    },
    didConnect : function (){
        var elements = $L('lyte-step-item', this.$node).e
        if(elements.length)
            {
                this.ArrayContentChange.call(this);
            }
           this.$node.next = function (state) {
                this.goto(parseInt(this.component.getData('ltPropSelected')) + 1, state, true) 
            },
            this.$node.previous = function (state) {
                this.goto((parseInt(this.component.getData('ltPropSelected')) - 1), state, true) 
            },
           this.$node.goto = function (number, state, flag) {
                    if(this.component.getData('ltPropSkip') || flag)
                        {
                            var elements = $L('lyte-step-item', this).e, ltPropSelected = this.component.getData('ltPropSelected'), ltPropWarningClass =  this.component.getData('ltPropWarningClass');
                            var selectedElement = elements[ltPropSelected], ltPropCompletedClass =  this.component.getData('ltPropCompletedClass'), ltPropActiveClass = this.component.getData('ltPropActiveClass')
                            if(number >= -1 &&  $L('lyte-step-item', this).e.length)
                                {
                                    if(state == 'incomplete')
                                        {
                                            selectedElement.classList.add(ltPropWarningClass)
                                        }
                                    else
                                        {
                                            selectedElement.classList.add(ltPropCompletedClass)
                                        }   
                                    selectedElement.classList.remove(ltPropActiveClass)
                                    if(number == $L('lyte-step-item', this).e.length)
                                        {
                                            number--;
                                        }
                                      else if(number == -1)
                                        {
                                            number++;
                                        }  
                                    elements[number].classList.add(ltPropActiveClass);
                                    if(number == ltPropSelected)
                                        {
                                            selectedElement.classList.remove(ltPropWarningClass);
                                            selectedElement.classList.remove(ltPropCompletedClass);
                                        }
                                    else      
                                        {
                                            this.component.setData('ltPropSelected', number);
                                        }          
                                }
                        }
                }
          this.breadcrumbClass.call(this);  
          if(this.getMethods('afterRender'))
            {
                this.executeMethod('afterRender', this.$node);
            }    
     },

     selectedElementFindObs : function(){
        $L.fastdom.measure(function(){
            this.selectedElementFind.call(this);
        }.bind(this))
     }.observes('ltPropSelected'),

    selectedElementFind : function (){
        var ltPropSelected = parseInt(this.getData('ltPropSelected')), ltPropActiveClass = this.getData('ltPropActiveClass'), elements = $L('lyte-step-item', this.$node).e, ltPropComplete = this.getData('ltPropCompletedClass'), ltPropWarningClass = this.getData('ltPropWarningClass');
        if(elements.length)
            {
                var length = this.getData('ltPropKeepMarked') ? ltPropSelected : (elements.length -1);
                $L('lyte-step-item', this.$node).removeClass(ltPropActiveClass)
                elements[ltPropSelected].classList.add(ltPropActiveClass)
                elements[ltPropSelected].classList.remove(ltPropWarningClass)
                elements[ltPropSelected].classList.remove(ltPropComplete)
                for(var i = 0; i <= length; i++)
                    {
                        if(i < ltPropSelected)
                            {
                                if(!elements[i].classList.contains(ltPropWarningClass))
                                    {
                                        elements[i].classList.add(ltPropComplete)
                                    }
                            }
                        else if(i > ltPropSelected)
                           {
                                elements[i].classList.remove(ltPropWarningClass)
                                elements[i].classList.remove(ltPropComplete)
                           } 
                            
                    }
            }
    },

    ArrayContentChangeObs : function(){
        this.ArrayContentChange.call(this);
    }.observes('ltPropData.[]'),

    ArrayContentChange : function (){
        if(this.getData('ltPropSelected') == undefined)      
            {
                this.setData('ltPropSelected',0)
            }
        else
            {
                this.selectedElementFind.call(this);
            } 
    },

    breadcrumbClassObs : function(){
        this.breadcrumbClass.call(this);
    }.observes('ltPropClass'),

    breadcrumbClass : function(){
        if(this.getData('ltPropYield'))
            {
                $L('lyte-step-structure', this.$node).e[0].classList.add(this.getData('ltPropClass'));
            }
    },
    data : function(){
        return {
            //  user data
            ltPropClass : Lyte.attr("string",{"default":'lyteStepSlash'}),
            ltPropData : Lyte.attr("array",{"default":[]}),
            ltPropSelected : Lyte.attr("number",{"default":0}),
            ltPropSkip : Lyte.attr("boolean",{"default": true}),
            ltPropActiveClass : Lyte.attr("string",{"default":'lyteActive'}),
            ltPropCompletedClass :Lyte.attr("string",{"default": 'lyteCompleted'}),
            ltPropWarningClass : Lyte.attr("string",{"default":'lyteWarning'}),
            ltPropKeepMarked : Lyte.attr("boolean",{"default": false}),
            ltPropYield : Lyte.attr("boolean",{"default": false}),
            ltPropLabel : Lyte.attr('string', {'default': ''}),
            ltPropOption : Lyte.attr('string', {'default': ''})
        }
    },
    actions : {
        'onclick' : function (event, Component, data){
            if((event.ctrlKey == true || event.metaKey == true || event.which == 2) && event.target.href != undefined && event.target.href.indexOf('javascript:') != -1 && event.target.target == '_blank'){return false;}
            if(this.getMethods('onClick'))
                {
                   this.executeMethod('onClick', Component, this.$node, event, data);
                   event.stopPropagation();  
                }
        },
        divClick : function(event, div){
            if((event.ctrlKey == true || event.metaKey == true || event.which == 2) && event.target.href != undefined && event.target.href.indexOf('javascript:') != -1 && event.target.target == '_blank'){return false;}
            if(this.getMethods('onClick') && this.getData('ltPropYield'))
                {
                    var node = event.target;
                    while(node != div)
                        {
                            if(node.tagName == 'LYTE-STEP-ITEM')
                                {
                                    this.executeMethod('onClick', node, this.$node, event, node.getAttribute('data-value'))
                                    break;
                                }
                              else
                                {
                                    node =  node.parentElement;
                                }  
                        }
                }
        }
    }       
});
Lyte.Component.register( 'lyte-svg', {
_template:"<template tag-name=\"lyte-svg\">\t<svg class=\"{{ltPropClass}}\" viewBox=\"{{ltPropViewBox}}\">\t\t<use id=\"{{ltPropId}}\" href=\"{{lyteUiSetURL(ltPropPath,flag)}}\"></use>\t</svg></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"attr","position":[1,1]}],
_observedAttributes :["ltPropViewBox","ltPropClass","ltPropPath","ltPropId","flag"],
	data: function() {
		return {
			ltPropViewBox: Lyte.attr( 'string', { 'default': '' } ),
			ltPropClass: Lyte.attr( 'string', { 'default': '' } ),
			ltPropPath: Lyte.attr( 'string' ),
			ltPropId: Lyte.attr( 'string', { 'default': '' } ),
			flag: Lyte.attr( 'boolean', { default: false } )
		}		
	},

	didConnect: function() {
		this.setData( 'flag', true );
	}
} );
Lyte.Component.register('lyte-table',{
_template:"<template tag-name=\"lyte-table\">\t<div class=\"lyteTableScroll\">\t\t<template is=\"if\" value=\"{{expHandlers(ltPropYield,'==',false)}}\"><template case=\"true\">\t\t<lyte-table-structure id=\"{{ltPropId}}\" class=\"{{ltPropClass}}\">\t\t   <template is=\"if\" value=\"{{ltPropHeaderLabelKey}}\"><template case=\"true\">\t\t\t   <lyte-colgroup>\t\t\t\t   <template is=\"for\" items=\"{{ltPropHeader}}\" item=\"list\" index=\"indexVal\">\t\t\t\t\t\t\t<lyte-col></lyte-col>\t\t\t\t\t</template> \t\t\t\t</lyte-colgroup>\t\t\t\t\t<lyte-thead>\t\t\t\t\t<lyte-tr>\t\t\t\t\t   <template is=\"if\" value=\"{{ltPropHeader.length}}\"><template case=\"true\"><template is=\"for\" items=\"{{ltPropHeader}}\" item=\"list\" index=\"indexVal\">\t\t\t\t\t\t<lyte-th id=\"{{list.id}}\" class=\"{{list.class}}\" index=\"{{indexVal}}\" resize=\"{{list.resize}}\" fixed=\"{{list.fixed}}\" icon=\"{{list.icon}}\">\t\t\t\t\t\t\t{{unescape(list[ltPropHeaderLabelKey])}}\t\t\t\t\t\t</lyte-th>\t\t\t\t\t\t\t</template></template></template>\t\t\t\t\t\t</lyte-tr>\t\t\t\t</lyte-thead>\t\t\t</template></template>\t\t\t\t<lyte-tbody>\t\t\t\t<template is=\"if\" value=\"{{ltPropInfiniteScroll}}\"><template case=\"true\">\t\t\t\t\t<template is=\"for\" items=\"{{ltPropData}}\" item=\"list\" index=\"indexVal\">\t\t\t\t\t\t\t <lyte-tr id=\"{{list.body.id}}\" class=\"{{list.body.class}}\">\t\t\t\t\t\t\t<template is=\"for\" items=\"{{ltPropHeader}}\" item=\"header\">\t\t\t\t\t\t\t\t<lyte-td>\t\t\t\t\t\t\t\t\t<div style=\"height: {{ltPropCellHeight}}\">\t\t\t\t\t\t\t\t\t\t{{unescape(lyteUiGetValue(list.body,header[ltPropBodyLabelKey]))}}\t\t\t\t\t\t\t\t\t</div>\t\t\t\t\t\t\t\t</lyte-td>\t\t\t\t\t\t\t</template>\t\t\t\t\t \t</lyte-tr>\t\t\t\t\t</template>\t\t\t\t</template><template case=\"false\">\t\t\t\t<template is=\"for\" items=\"{{ltPropContent}}\" item=\"list\" index=\"indexVal\">\t\t\t\t\t\t <lyte-tr id=\"{{list.id}}\" class=\"{{list.class}}\">\t\t\t\t\t\t<template is=\"for\" items=\"{{ltPropHeader}}\" item=\"header\">\t\t\t\t\t\t\t<lyte-td>{{unescape(lyteUiGetValue(list,header[ltPropBodyLabelKey]))}}</lyte-td>\t\t\t\t\t\t</template>\t\t\t\t \t</lyte-tr>\t\t\t\t</template>\t\t\t\t</template></template>\t\t    </lyte-tbody> \t\t    <template is=\"if\" value=\"{{expHandlers(ltPropResize.vertical,'||',ltPropResize.horizontal)}}\"><template case=\"true\">\t\t    \t<lyte-table-resize onmousedown=\"{{action('tableResize', event, this)}}\"></lyte-table-resize>\t\t    \t<template is=\"if\" value=\"{{ltPropResize.vertical}}\"><template case=\"true\">\t\t    \t\t<lyte-table-vertical-resize onmousedown=\"{{action('tableResize', event, this)}}\"></lyte-table-vertical-resize>\t\t    \t</template></template><template is=\"if\" value=\"{{ltPropResize.horizontal}}\"><template case=\"true\">\t\t    \t\t<lyte-table-horizontal-resize onmousedown=\"{{action('tableResize', event, this)}}\"></lyte-table-horizontal-resize>\t\t    \t</template></template></template></template>\t\t</lyte-table-structure>\t</template><template case=\"false\"><template is=\"if\" value=\"{{ltPropInfiniteScroll}}\"><template case=\"true\">\t\t<lyte-yield yield-name=\"yield\" lt-prop-data=\"{{ltPropData}}\"></lyte-yield>\t</template><template case=\"false\">\t <lyte-yield yield-name=\"yield\"></lyte-yield>\t </template></template></template></template></div></template>",
_dynamicNodes : [{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"if","position":[1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3,1,1]},{"type":"if","position":[3,1,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"for","position":[0],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"text","position":[1,1]},{"type":"componentDynamic","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[3,1]},{"type":"componentDynamic","position":[3]}]}},"default":{}},{"type":"attr","position":[1,3,1]},{"type":"if","position":[1,3,1],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"attr","position":[1,1],"attr":{"style":{"name":"style","helperInfo":{"name":"concat","args":["'height: '","ltPropCellHeight"]}}}},{"type":"text","position":[1,1,1]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]}]},"false":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1]},{"type":"for","position":[1,1],"dynamicNodes":[{"type":"text","position":[1,0]},{"type":"componentDynamic","position":[1]}]},{"type":"componentDynamic","position":[1]}]}]}},"default":{}},{"type":"componentDynamic","position":[1,3]},{"type":"attr","position":[1,5]},{"type":"if","position":[1,5],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]},{"type":"attr","position":[3]},{"type":"if","position":[3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"attr","position":[4]},{"type":"if","position":[4],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"componentDynamic","position":[1]}]}},"default":{}}]}},"default":{}},{"type":"componentDynamic","position":[1]}]},"false":{"dynamicNodes":[{"type":"attr","position":[0]},{"type":"if","position":[0],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"insertYield","position":[1]}]},"false":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}]}},"default":{}}],
_observedAttributes :["ltPropContent","ltPropHeader","ltPropId","ltPropClass","ltPropBorder","ltPropHeaderLabelKey","ltPropBodyLabelKey","ltPropWidth","ltPropHeight","ltPropResize","ltPropFixedColumnClass","ltPropYield","ltPropScroll","ltPropColumnSortable","ltPropScrollbarOption","ltPropData","ltPropInfiniteScroll","ltPropCellHeight","ltPropCellWidth","ltPropContentLength","ltPropPreventScrollbar","columns","nonFixedColumn","minWidth1","minWidth2","secondaryData","boundary","rowHeights","dualResize"],
	init : function(){
		this._browser = navigator.userAgent.match(/rv:11/) || navigator.userAgent.match('Edge') || ( navigator.userAgent.match('Safari') && !navigator.userAgent.match('Chrome') )
		if(this.getMethods('beforeRender'))
            {
                this.executeMethod('beforeRender', this.$node);
            }
        this.$node.scrollTable = function( x, y ){
			if( !this.scrollDiv ) {
				this.scrollDiv = $L('div.lyteTableScroll', this.$node).e[0]
			}
			if( x != undefined ) {
				this.scrollDiv.scrollTop = y;
			}
			if( y != undefined ) {
				this.scrollDiv.scrollLeft = x;
			}
		}.bind( this )

		if( !document._tableResize ) {
			document._tableResize = true;
			window.addEventListener( 'resize', resizeTable, true )
		}

		this.$node.toggleRows = function( val ){
			$L.fastdom.measure( function(){
				var preventRows = $L( 'lyte-tbody lyte-tr.lytePreventInfiniteScroll' );
				if( preventRows.e.length ) {
					if( val ) {
						preventRows.removeClass( 'lyteHidden' )
					} else {
						preventRows.addClass( 'lyteHidden' )
					}
				}
			}.bind( this ) )
		}.bind( this )    
	},

	didDestroy : function(){
		if( $L( 'lyte-table[lyte-rendered]' ).e.length == 0 &&  document._tableResize ) {
			window.removeEventListener( 'resize', resizeTable, true )
			delete document._tableResize
		}
	},

	initProcess1 : function( arg ) {
		if( this._prevent ) {
			return
		}
		if( this.getData( 'ltPropInfiniteScroll' ) ) {
			var table = $L( 'lyte-table-structure', this.$node ).e[ 0 ],
			ltPropContent = this.getData('ltPropContent'), len  = this.getData( 'ltPropContentLength' ) || ltPropContent.length,
			ltPropData = [];
			if( ltPropContent.length == 0 ) {
				return;
			}
			if( table ) {
				table.style.height =  'auto';
			}
			for( var i = 0; i < len; i++ ) {
				ltPropData[ i ] = { body : ltPropContent[ i ], checked : false }
			}
			this.setData( 'ltPropData', ltPropData )
			if( arg && this._dummy ) {
				this._dummy.style.height = 0;
				this._dummy.style.transform = "translateY(0px)";
			}

			if( arg && this._dummy1 ) {
				// this._dummy1.style.height = 0;
				this._dummy1.style.transform = "translateY(0px)";
			}
			delete this._stopScroll;
			if( arg && this.scrollDiv ) {
				this.scrollDiv.scrollTop = 0;
				this.scrollDiv.scrollLeft = 0;
			}
			this._top = 0;
			this._bottom = Math.max( len - 1, 0 ) 
			this._boundary = { top : 0, bottom : len - 1 }
		}
	}.observes( 'ltPropContent' ).on( 'init' ),


	didConnect : function (){
		var ltPropInfiniteScroll = this.getData('ltPropInfiniteScroll'), secData = this.getData('secondaryData');	
		var ltPropResize = this.getData('ltPropResize')
		if(this.getData('ltPropYield') && (ltPropResize.vertical || ltPropResize.horizontal))
			{
				this.resizeComponentAppend.call(this);
			}
		else if(this.getData('ltPropYield')){
			var resize = $L('lyte-table-resize', this.$node).e[0];
			if(resize){
				resize.parentElement.removeChild(resize);
			}
		}
		try{
			var scrollDiv = $L('div.lyteTableScroll', this.$node).e[0];
			this.scrollDiv = scrollDiv;
			scrollDiv.comp = this;
			scrollDiv.addEventListener('scroll', this.scroll, true);
			if( !this.data.ltPropPreventScrollbar ){
				$L(scrollDiv).scroll(this.getData('ltPropScrollbarOption'));
				var scrollbar = $L('.lyteScrollContainer.lyteScrollContainerY', this.$node).e[0];
				var header = $L('lyte-th', this.$node).e[0], hgt;
				$L.fastdom.measure(function(){
					// while applying scroll plugin vertical scrollbar needs some offset for enabling the virtual of only body part is scrolling. If it is zero we have to set height of the header as offset
					if(header && scrollbar && scrollbar.offsetTop == 0)
						{
							hgt = header.getBoundingClientRect().height;
							$L.fastdom.mutate(function(){
								scrollbar.style.top = hgt + 'px';
							}.bind(this))
						}
					$L.fastdom.mutate(function(){
						if(this.getMethods('afterRender'))
				            {
				                this.executeMethod('afterRender', this.$node);
				            }
					}.bind(this))	
				}.bind(this))
			}	
		}catch(err){
		}
		if(ltPropInfiniteScroll) {
				this.$node.classList.add( 'infinitescroll' )
				scrollDiv._infiniteScroll = true;
				this.$node.setValue = function(ret){
					if( this._stopScroll ){
						this.appendAddData1.call(this, ret)
					}
				}.bind(this)
			}
	},

	// width calculation for positioning
	columnWidth : function(fixedColumn, i, j){
		var width = 0;
		if(!j)
			{
				j = 0
			}
		for(; j < i; j++)
			{
				width += fixedColumn[j].property.width;
			}
		return width;	
	},

	heightCalc : function(rows, upper, hgtLimit){
		var hgt = 0, j = upper;
		for(;j > 0; j--)
			{
				hgt += rows[j];
				if(hgtLimit < hgt)
					{
						break;
					}
			}
		return [hgt, j];	
	},

	topElem : function( elem ){
		if( window.isIE11Lyte || window.isEdgeLyte ) {
			var ret = elem.querySelector( 'lyte-td' );
			if( ret ) {
				return ret.getBoundingClientRect()
			} 
			return {}

		} else {
			return elem.getBoundingClientRect()
		}
	},

	cellSet : function( elem, value ) {
		if( window.isIE11Lyte || window.isEdgeLyte ) {
			var cells = $L( 'lyte-td', elem ).e;
			if( !value && cells.length ) {
				return cells[ 0 ].style.transform
			}
			for( var i = 0; i < cells.length; i++ ) {
				cells[ i ].style.transform = value;
			}
		} else {
			if( !value ){
				return elem.style.transform
			}
			elem.style.transform = value
		}
	},

	scrollTable : function( event, obj ) {
		// fastdom has been removed here due to delay causes error in calculation of data in ie edge safari
			var b = event.yScroll, ltPropData = this.getData( 'ltPropData' ), ltPropContent = this.getData( 'ltPropContent' ), scrollDiv = this.scrollDiv, divClientRect = obj.tbodyClient, tableClient = obj.$nodeClient, table = $L(' lyte-table-structure ', this.$node).e[ 0 ];
			var head = $L( 'lyte-th', this.$node ).e[ 0 ], neglected = obj.neglected, compNeg = obj.compNeg;
			head = head ? head.property.height : 0;
			var topElem = obj.topElem, top1 = obj.topElemClient;

			if( table.style.height.indexOf( 'px' ) == -1 ) {
				table.style.height = divClientRect.height + 'px';
				this._rowHgt = top1.height;
				this._step = divClientRect.height - this._rowHgt * neglected.length;
			}
			if( !this._dummy ) {
				var tbody = $L( 'lyte-tbody ', this.$node ).e[0]
				var dummy = document.createElement( 'lyte-tr' );
				dummy.classList.add( 'dummy' );
				tbody.appendChild( dummy )
				dummy.setAttribute( 'style', 'transform:translateY(0px);height:0px' )
				this._dummy = dummy;
				if( this._browser ) {
					var dummy1 = document.createElement( 'div' );
					dummy1.classList.add( 'dummy' );
					this.scrollDiv.appendChild( dummy1 )
					dummy1.setAttribute( 'style', 'transform:translateY(0px);height:5px' )
					this._dummy1 = dummy1;
				}
			}
			if( b == undefined && !scrollDiv.classList.contains( 'eventBinded' ) ) {
				var prevScroll = parseFloat( this._dummy.style.transform.match( /[\d|.]+/ig )[ 0 ] ),
				currScroll = scrollDiv.scrollTop
				if( currScroll > prevScroll ) {
					b = 1
				} else {
					b = -1
				}
			}
			if( b > 0 ) {
				if( parseFloat( tableClient.top + head ) >= parseFloat( top1.bottom ) ) {
						if( this._boundary.bottom <= ltPropContent.length - 2 ) {
							var diff = Math.max( parseInt( ( tableClient.top + head - top1.bottom ) / this._rowHgt ), 1 );
							if( this._boundary.bottom + diff > ltPropContent.length - 1 ) {
								diff = ltPropContent.length - 1 - this._boundary.bottom
							}
							for( var i = 0; i < diff; i++ ) {
								this._boundary.bottom += 1;
								if( i >= diff - ltPropData.length ) {
									Lyte.Component.set(ltPropData[ this._top ], 'body', ltPropContent[ this._boundary.bottom ])
									topElem.dataOrder = this._boundary.bottom
								}
								this._boundary.top = this._boundary.bottom - ltPropData.length;
								if( this.cellSet( topElem ) ) {
									this.regex( topElem )
								} else {
								 this.cellSet( topElem, "translateY(" + ( this._step ) +'px)')
								}
								this._dummy.style.transform = 'translateY(' + ( parseFloat( this._dummy.style.transform.match( /[\d|.]+/ig )[ 0 ] ) + this._rowHgt ) + 'px)'
								this._dummy.style.height = Math.max( parseFloat( this._dummy.style.height ) - this._rowHgt, 0 ) + 'px';
								if( this._browser ){
									this._dummy1.style.transform = 'translateY(' + ( parseFloat( this._dummy1.style.transform.match( /[\d|.]+/ig )[ 0 ] ) + this._rowHgt ) + 'px)'
								}
								this._bottom = this._top;
								this._top = ( this._top + 1 ) % ltPropData.length;
								if( this._boundary.bottom >= ltPropContent.length ) {
									this._boundary.bottom = ltPropContent.length - 1;
									this._top = ( this._top + 1 ) % ltPropData.length;
									break
								}
								topElem = $L( 'lyte-tbody lyte-tr:nth-of-type(' + ( ( this._top + 1 + compNeg.length ) ) + ')', this.$node ).e[ 0 ]
							}
						} else {
							this.scrollEndMethod1();
						}
				} 

			} else if( b < 0 ) {
				var bottmElem = obj.bottmElem,  bottom =  obj.bottmElemClient;
					 if( tableClient.bottom <= bottom.top ) {
						var mat  = this.cellSet( bottmElem ).match( /[\d|.]+/ig );
						if( !mat || ( mat && mat[ 0 ] == '0' )) {
							return
						}
						var diff = parseInt( Math.max( parseFloat( ( bottom.top - tableClient.bottom )/ this._rowHgt ), 1) ),
						minDiff = Math.max( diff - 1 - this._boundary.top, 0 )
						for( var i = diff - 1; i >= 0; i-- ) {
							if( i <= ltPropData.length - 1 + minDiff ) {
								Lyte.Component.set(ltPropData[ this._bottom ], 'body', ltPropContent[ this._boundary.top ])
								bottmElem.dataOrder = this._boundary.top
							}
							this._boundary.top -= 1;
							this._boundary.bottom = this._boundary.top + ltPropData.length - 1;
							if( this.cellSet( bottmElem ) ) {
								this.regex( bottmElem, true )
							}
 							this._dummy.style.height = ( parseFloat( this._dummy.style.height ) + this._rowHgt ) + 'px';
							this._dummy.style.transform = 'translateY(' + ( parseFloat( this._dummy.style.transform.match( /[\d|.]+/ig )[ 0 ] ) - this._rowHgt ) + 'px)'
							if( this._browser ){
								// this._dummy1.style.height = Math.max( parseFloat( this._dummy1.style.height ) - this._rowHgt, 0 ) + 'px';
								this._dummy1.style.transform = 'translateY(' + ( parseFloat( this._dummy1.style.transform.match( /[\d|.]+/ig )[ 0 ] ) - this._rowHgt ) + 'px)'
							}
							this._top = this._bottom;
							this._bottom = ( ltPropData.length + this._bottom - 1 ) % ltPropData.length;
							if( this._boundary.top == -1 ) {
								this._boundary.top = 0;
								this._boundary.bottom = this._boundary.top + ltPropData.length - 1;
								break
							}
							bottmElem = $L( 'lyte-tbody lyte-tr:nth-of-type(' + ( ( this._bottom + 1 + compNeg.length + ( window.isIE11Lyte ? 1 : 0 ) ) ) + ')', this.$node ).e[ 0 ]
						}
					}
			}
	},

	regex : function( elem, flag ){
		if( window.isIE11Lyte || window.isEdgeLyte ) {
			var cells = $L( 'lyte-td', elem ).e;
			for( var i = 0; i < cells.length; i++ ) {
				this.regex1( cells[ i ], flag )
			}
		} else {
			this.regex1( elem, flag )
		}
	},

	regex1 : function(elem, flag){
		if( flag ) {
			elem.style.transform = elem.style.transform.replace( /[\d|.]+/ig, function(){ return Math.max( parseFloat( arguments[ 0 ] ) - this._step, 0 ).toFixed( 3 ) }.bind( this ) )
		} else {
			elem.style.transform = elem.style.transform.replace( /[\d|.]+/ig, function(){ return ( parseFloat( arguments[ 0 ] ) + this._step ).toFixed( 3 ) }.bind( this ) )
		}
	},

	scrollEndMethod1 : function( ) {
		if( this._stopScroll ) {
			return
		}
		this._stopScroll = true;
		if( this.getMethods( 'scrollEnd' ) ) {
			this.appendAddData1( this.executeMethod( 'scrollEnd' ) )
		}
	},

	appendAddData1 : function( ret ){
		if( ret )
			{
				if( ret.then ) {
					Promise.resolve( ret ).then( function( arg ) {
						if( arg ){
							this.apd1.call( this, arg );
						}
					}.bind( this ), function() {
							
					}.bind( this ) );
				} else {
					this.apd1.call( this, ret )
				}
			}	
	},

	apd1 : function( ret ){
		var ltPropContent = this.getData( 'ltPropContent' ), ltPropData = this.getData( 'ltPropData' )
		this._prevent = true
		if(ret.constructor == Array)
			{
				Lyte.arrayUtils( ltPropContent, 'concat', ret );
			}
		else if(ret.constructor == Object)
			{
				Lyte.arrayUtils( ltPropContent, 'push', ret );
			}
		delete this._prevent;	
		delete this._stopScroll;
	},

	scroll : function (event) {
		// cant use fastdom because of jerk in ie edge safari browser
		if( !event._byPlugin && this.scrollDiv && this.scrollDiv.classList.contains( 'eventBinded' ) ){
			return
		}
			var component =  this.comp,
			headerList = $L('lyte-th', component.$node).e,
			// scrollleft and top are required for process like fixing columns and infinite scroll. If scroll is dispatched by plugin event object contains these properties or it is calculated
			obj = {};
			obj.$nodeClient = this.parentElement.getBoundingClientRect();
			obj.scrollDivClient = this.getBoundingClientRect();
			obj.neglected =  $L( 'lyte-tbody lyte-tr.lytePreventInfiniteScroll:not(.lyteHidden)', this ).e
			obj.compNeg = $L( 'lyte-tbody lyte-tr.lytePreventInfiniteScroll', this.$node ).e
			obj.scrollWidth = this.scrollWidth;
			if( this.comp._top != undefined ) {
				obj.topElem = $L( 'lyte-tbody lyte-tr:not(.dummy)', this ).e[ this.comp._top + obj.compNeg.length ]
				obj.topElemClient = obj.topElem ? this.comp.topElem( obj.topElem ) : {};
				obj.bottmElem = $L( 'lyte-tbody lyte-tr:nth-of-type(' + ( ( this.comp._bottom + 1 + obj.compNeg.length + ( window.isIE11Lyte ? 1 : 0 )) ) + ')', this ).e[ 0 ];
				obj.bottmElemClient = obj.bottmElem ? this.comp.topElem( obj.bottmElem ) : {}
				obj.tbody = $L( 'lyte-tbody', this ).e[ 0 ];
				obj.tbodyClient = obj.tbody ? obj.tbody.getBoundingClientRect() : {};
			}

			for(var k = 0; k < headerList.length; k++)
				{
					// for fixing columns each column dimensions are required
					headerList[k].property = headerList[k].getBoundingClientRect();
					headerList[k].order = k
				}
			this._scrollLeft = event.scrollLeft != undefined ? event.scrollLeft : this.scrollLeft;
			this._scrollTop = event.scrollTop != undefined ? event.scrollTop : this.scrollTop;
			var direction = this._direction;
			component.scrollCheck.call(this, event, obj);
			if(this._scrollLeft == 0 && direction != 'rtl' && component.getData('ltPropInfiniteScroll'))
				{
					var ary = component.getData('columns');
					Lyte.arrayUtils(ary, 'remove', 0, ary.length);
					var fixedd = $L('.lyteTableFixed', this).e
					if(fixedd.length)
						{
							for(var i = 0; i < fixedd.length; i++)
								{
									fixedd[i].style.left = '0px';
									fixedd[i].classList.remove('lyteTableFixed');
								}
						}
				}
			if( component.getData( 'ltPropInfiniteScroll' ) ) {
				component.scrollTable.call( component, event, obj )
			}	
			delete this._scrollLeft; delete this._scrollTop;
	},

	// fixed column checks and removals
	scrollCheck : function(event, obj ){
		var tablee = $L('lyte-table-structure',this).e[0], scrollDiv = this,
		scrollTop = this._scrollTop, scrollLeft = this._scrollLeft,
		scrollDir = this.parentElement.component.getData('ltPropScroll'),
		direction = this._direction;
		// for vertical scroll
		if(scrollTop != this.prevScollTop && scrollDir.vertical)
			{
					var colsNos = $L('lyte-th', this);
					if( colsNos.e.length ) {
						colsNos.addClass('tableRowFixed')
						for(var i = 0; i < colsNos.e.length; i++){
							colsNos.e[i].style.top = (scrollTop) + 'px';
						}
						if(!scrollTop){
							colsNos.removeClass('tableRowFixed');
						}
					}
			}
		// for horizontal scroll	
		if(scrollLeft != this.prevScollLeft && scrollDir.horizontal)
			{	
				var component = this.parentElement.component, table = $L('lyte-table-structure', this).e[0], columns = component.getData('columns');
				var headerList = $L('lyte-th', component.$node).e, fixedColumn = $L('lyte-th.lyteFixedColumn', component.$node).e, ltPropFixedColumnClass = component.getData('ltPropFixedColumnClass')
					// fastdom removed due to jerk in ie edge chrome browser
					// $L.fastdom.mutate(function(){
						for(var i = columns.length; i < fixedColumn.length; i++)
							{
								if(((fixedColumn[i].property.right  + component.columnWidth.call(component, fixedColumn, i) > (obj.scrollDivClient.right)) && direction == 'rtl') || ((fixedColumn[i].property.left < (obj.scrollDivClient.left + component.columnWidth.call(component, fixedColumn, i))) && direction != 'rtl'))
									{
										var width = fixedColumn[i].property.width
										var order = fixedColumn[i].order
										if(order + 1 < headerList.length)
											{
												fixedColumn[i].classList.add('lyteTableFixed')
												columns.push(fixedColumn[i])
												$L('lyte-tbody lyte-td:nth-of-type(' + (order + 1) + ')', component.$node).addClass('lyteTableFixed')
												if(ltPropFixedColumnClass)
													{	
														$L('lyte-tbody lyte-td:nth-of-type(' + (order + 1) + ')', component.$node).addClass(ltPropFixedColumnClass)
													}
											}
									}
							}	
						for(var n = columns.length - 1; n >= 0; n--)
							{
								j = columns.length - 1;
								if(((((headerList[columns[j].order + 1].property.right  + columns[j].property.width + component.columnWidth.call(component, columns, columns.length - 1)) < (obj.scrollDivClient.right)) || (headerList[columns[j].order + 1].property.right + 2 < columns[j].property.left)) && direction == 'rtl') || ((headerList[columns[j].order + 1].property.left >= (obj.scrollDivClient.left + columns[j].property.width + component.columnWidth.call(component, columns, columns.length - 1))) && (columns[j].property.left >= (obj.scrollDivClient.left + component.columnWidth.call(component, fixedColumn, columns.length - 1))) && direction != 'rtl'))
								  {
										$L('lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')', component.$node).removeClass('lyteTableFixed')
										var innerElem = $L('lyte-th-data', headerList[columns[j].order]).e[0]
										headerList[columns[j].order].classList.remove('lyteTableFixed')
										if(ltPropFixedColumnClass)
											{	
												innerElem.parentElement.classList.remove(ltPropFixedColumnClass)
												$L('lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')', component.$node).removeClass(ltPropFixedColumnClass)
											}
										columns[j].style.removeProperty('left');
										var currCols = $L('lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')', component.$node).e;
										for(var z = 0; z < currCols.length; z++)
											{
												currCols[z].style.removeProperty('left');
											}
										Lyte.arrayUtils(columns, 'removeAt', j)
									}
								else
									{
										break;
									}		
							}	
						for(var j = 0; j < columns.length; j++)
							{
								//positioning on scroll
								var left, cells = $L('lyte-tbody lyte-td:nth-of-type(' + (columns[j].order + 1) + ')', component.$node).e
								if(j == 0)
							    	{
							    		if(direction == 'rtl')
							    			{
							    				if(navigator.userAgent.toLowerCase().indexOf('firefox') != -1 || (navigator.userAgent.toLowerCase().indexOf('safari') != -1 && !(navigator.userAgent.toLowerCase().indexOf('chrome') != -1) && !(navigator.userAgent.toLowerCase().indexOf('chromium') != -1)))
							    					{
							    						left = scrollLeft - (component.columnWidth.call(component, headerList, columns[j].order, 0))
							    					}
							    				else if(navigator.userAgent.toLowerCase().indexOf('edge') != -1 || navigator.userAgent.toLowerCase().indexOf('trident') != -1 || navigator.userAgent.toLowerCase().indexOf('msie') != -1)
							    					{
							    						left = -scrollLeft - (component.columnWidth.call(component, headerList, columns[j].order, 0))
							    					}	
							    				else
							    					{
							    						left = scrollLeft - 1 - (obj.scrollWidth) + obj.scrollDivClient.width + (component.columnWidth.call(component, headerList, columns[j].order, 0))
							    					}	
							    			}
							    		else
							    			{
							    				left = scrollLeft - (component.columnWidth.call(component, headerList, columns[j].order, 0))
							    			}
							    	}
							    else
							    	{
							    		if(direction == 'rtl')
							    			{
							    				if(navigator.userAgent.toLowerCase().indexOf('firefox') != -1 || (navigator.userAgent.toLowerCase().indexOf('safari') != -1 && !(navigator.userAgent.toLowerCase().indexOf('chrome') != -1) && !(navigator.userAgent.toLowerCase().indexOf('chromium') != -1)))
							    					{
							    						left = parseInt(columns[j - 1].style.left) + component.columnWidth.call(component, headerList, columns[j].order, columns[j-1].order + 1)
							    					}
							    				else
							    					{	
							    						left = parseInt(columns[j - 1].style.left) + component.columnWidth.call(component, headerList, columns[j].order, columns[j-1].order + 1);
							    					}
							    			}
							    		else
							    			{
							    				left = parseInt(columns[j - 1].style.left) - component.columnWidth.call(component, headerList, columns[j].order, columns[j-1].order + 1)
							    			}
							    	}	
								for(var x = 0; x < cells.length; x++)
							    	{
							    		cells[x].style.left = left + 'px';
							    	}
					    		 columns[j].style.left = left + 'px';
							}
					// }.bind(this))
				// }.bind(this))
			  }
		this.prevScollLeft = scrollLeft;
		this.prevScollTop = scrollTop; 
	},
	// border 

	borderChangeObs : function(){
		this.borderChange.call(this);
	}.observes('ltPropBorder').on('didConnect'),

    borderChange : function() {
		if(this.getData('ltPropBorder'))
			{
				this.$node.classList.add('border');
			}
		else
			{
				this.$node.classList.remove('border');
			}
	},

	widthObsObs : function(){
		this.widthObs.call(this);
	}.observes('ltPropWidth').on('didConnect'), 

	widthObs : function(){
		$L('lyte-table-structure',this.$node).e[0].style.width = this.getData('ltPropWidth');
	},

	heightObsObs : function(){
		this.heightObs.call(this);
	}.observes('ltPropHeight').on('didConnect'),

	heightObs : function(){
		$L('lyte-table-structure',this.$node).e[0].style.height = this.getData('ltPropHeight');
	}, 

	sortableObs : function(){
		this.sortable.call(this);
	}.observes('ltPropColumnSortable').on('didConnect'),

	sortable : function(){
		var row = $L('lyte-thead', this.$node).e[0];
		if(row)
			{
				if(this.getData('ltPropColumnSortable'))
					{
						this.colSort = this.sortableColumns.bind(this)
						row.addEventListener('mousedown', this.colSort);
					}
				else
					{
						row.removeEventListener('mousedown', this.colSort);
					}	
			}
	},

	composePath : function(event){
		var arr = [], node = event.target;
		while(node.tagName != 'HTML')
			{
				arr.push(node);
				node = node.parentElement;
			}
		return arr;	
	},

	sortableColumns : function(event){
		var target = this.closestFind.call(this, event.path ? event.path : this.composePath.call(this, event), 'lyte-th:not(.lyteTableFixed)');
		if(target && this.$node.contains(target))
			{
				var ret;
				if( this.getMethods( 'onBeforeSelect' ) ) {
					ret = this.executeMethod( 'onBeforeSelect', target, event, this.$node )
				}
				if( ret != false ) {
					this.mousemove = this.sortableMouseMove.bind(this);
					this.offLeft = event.clientX - target.getBoundingClientRect().left;
					this.colHead = target;
					this._thisBccr = this.$node.getBoundingClientRect()
					target.classList.add( 'sortSelect' )
					document.documentElement.addEventListener('mousemove',this.mousemove);
					this.mouseup = this.sortableMouseup.bind(this);
					document.documentElement.addEventListener('mouseup',this.mouseup);
					this.flag = true;
					event.preventDefault();
					if( this.getMethods( 'onSelect' ) ) {
						this.executeMethod( 'onSelect', target, event, this.$node )
					}
				}
			}
	},

	horiScroll : function( dummyDiv ){
		if( ( parseFloat( dummyDiv.style.left ) + parseFloat( dummyDiv.style.width ) ) >= this._thisBccr.right ) {
			this._scrollDir = '+ve'
			this.scrollDiv.scrollLeft += 10
			this._reqId = window.requestAnimationFrame( function(){
				this.horiScroll( dummyDiv )
			}.bind( this ) )
		} else if( parseFloat( dummyDiv.style.left ) <= this._thisBccr.left ) {
			this._scrollDir = '-ve'
			this.scrollDiv.scrollLeft -= 10
			this._reqId = window.requestAnimationFrame( function(){
				this.horiScroll( dummyDiv )
			}.bind( this ) )
		} else {
			window.cancelAnimationFrame( this._reqId );
			delete this._prevent; delete this._scrollDir;
		}
	},

	sortableMouseMove : function(event){
		if(this.flag && this._timeout == undefined )
			{
				var target = this.colHead;
				var clientRect = target.getBoundingClientRect();
				var div = document.createElement('div');
				div.classList.add('lyteTableSortHelper');
				div.innerHTML = this.colHead.innerText;
				var xscroll = window.pageXOffset || document.documentElement.scrollLeft
      			var yscroll = window.pageYOffset || document.documentElement.scrollTop  
				div.style.height = clientRect.height + 'px';
				div.style.width = clientRect.width + 'px';
				div.style.left = (xscroll + clientRect.left) + 'px';
				div.style.top = (yscroll + clientRect.top) + 'px';
				this._timeout = setTimeout( function(){
					document.body.appendChild(div);
					this.flag = false;
				}.bind( this ), 100 )
			}
		var dummyDiv = $L('div.lyteTableSortHelper').e[0];
		if(dummyDiv)
			{
				var newLeft = Math.max( Math.min( (event.clientX - this.offLeft), this._thisBccr.right - parseFloat( dummyDiv.style.width ) ), this._thisBccr.left );
				if( ( newLeft > parseFloat( dummyDiv.style.left ) && this._scrollDir == '-ve' ) || ( newLeft < parseFloat( dummyDiv.style.left ) && this._scrollDir == '+ve' ) ){
					window.cancelAnimationFrame( this._reqId );
					delete this._prevent;delete this._scrollDir
				}
				if( this._prevent ) {
					return
				}
				dummyDiv.style.left = newLeft + 'px';
				this._prevent = true
				this.horiScroll( dummyDiv )
				if( this.getMethods( 'onDrag' ) ) {
					this.executeMethod( 'onDrag', this.colHead, dummyDiv, event, this.$node )
				}
			}
		event.preventDefault();
		event.stopPropagation();	
	},

	sortableMouseup : function(event){
		if(!this.flag)
			{
				var dummyDiv = $L('div.lyteTableSortHelper').e[0], clientRect = dummyDiv.getBoundingClientRect(), x = clientRect.left + clientRect.width/2 + 2, y = clientRect.top + clientRect.height/2;
				var adjCol = this.closestFind.call(this, document.elementsFromPoint ? document.elementsFromPoint(x, y) : this.elementsFromPointCal.call(this, x, y), 'lyte-th:not(.lyteTableFixed)');
				if(adjCol != this.colHead && adjCol)
					{
						var Heads = $L('lyte-th', this.colHead.parentElement).e
						var colOrder = Array.prototype.indexOf.call(Heads, this.colHead);
						var adjOrder = Array.prototype.indexOf.call(Heads, adjCol);
						var ltPropHeader = this.getData('ltPropHeader'), ret;
						if( this.getMethods( 'onBeforeDrop' ) ) {
							ret = this.executeMethod( 'onBeforeDrop', this.colHead, adjCol, colOrder, adjOrder, ltPropHeader, event, this.$node )
						}
						if( ret != false ) {
							if(!ltPropHeader.length)
								{
									this.colHead.parentElement.insertBefore(this.colHead, adjOrder > colOrder ? adjCol.nextSibling : adjCol);
									var colGrp = $L('lyte-tbody lyte-td:nth-of-type(' + (colOrder + 1) +')', this.$node).e;
									var AdjColGrp = $L('lyte-tbody lyte-td:nth-of-type(' + (adjOrder + 1) +')', this.$node).e;
									for(var i = 0; i < colGrp.length; i++)
										{
											LyteComponent.insertBefore( colGrp[i], adjOrder > colOrder ? AdjColGrp[i].nextSibling : AdjColGrp[i] );
										}
								}
							else
								{
									var flag = adjOrder > colOrder ? true : false;
									var temp = Lyte.arrayUtils(ltPropHeader, 'removeAt',colOrder), newOrder = Array.prototype.indexOf.call($L('lyte-th', adjCol.parentElement).e, adjCol);
									Lyte.arrayUtils(ltPropHeader,'insertAt', colOrder < adjOrder ? (newOrder + 1) : newOrder, temp);
									var newCol = $L('lyte-th', adjCol.parentElement).e[colOrder < adjOrder ? (newOrder + 1) : newOrder];
									if(adjCol.classList.contains('tableRowFixed'))
										{
											newCol.classList.add('tableRowFixed');
											newCol.style.top = adjCol.style.top;
										}	
								}
							if( this.getMethods( 'onDrop' ) ) {
								this.executeMethod( 'onDrop', this.colHead, adjCol, colOrder, adjOrder, ltPropHeader, event, this.$node )
							}	
						}
					}
				document.body.removeChild(dummyDiv);
			} else {
				clearTimeout( this._timeout )
			}
		document.documentElement.removeEventListener('mouseup',this.mouseup);
		document.documentElement.removeEventListener('mousemove',this.mousemove);
		this.colHead.classList.remove( 'sortSelect' )
		window.cancelAnimationFrame( this._reqId )
		delete this.mouseup;
		delete this.mousemove;	
		delete this.offLeft;
		delete this.colHead;
		delete this.flag;
		delete this._timeout;
		delete this._thisBccr;
		delete this._reqId; delete this._prevent;delete this._scrollDir
		event.preventDefault();
		event.stopPropagation();
		event.stopImmediatePropagation();
	},

	elementsFromPointCal : function(x, y){
		var arr = [], element = document.elementFromPoint(x, y);
		while(element != document && element != document.documentElement && element != document.body && element != this.$node)
			{
				element.style.pointerEvents = 'none';
				arr.push(element);
				element = document.elementFromPoint(x, y);
			}
		for(var i = 0; i < arr.length; i++)
			{
				arr[i].style.pointerEvents = 'initial';
			}
		return arr;		
	},

	resizeComponentAppendObs : function(){
		this.resizeComponentAppend.call(this);
	}.observes('ltPropResize'),

	resizeComponentAppend : function(){
		if(this.getData('ltPropYield'))
			{
				var ltPropResize = this.getData('ltPropResize');
				if(ltPropResize.vertical || ltPropResize.horizontal)
					{
						var comp = document.createElement('lyte-table-resize')
						$L('lyte-table-structure', this.$node).e[0].appendChild(comp)
						comp.addEventListener('mousedown',function(event){this.$node.constructor._actions.tableResize.call(this, event)}.bind(this));
					}
				if(ltPropResize.vertical)
					{
						var comp = document.createElement('lyte-table-vertical-resize')
						$L('lyte-table-structure', this.$node).e[0].appendChild(comp)
						comp.addEventListener('mousedown',function(event){this.$node.constructor._actions.tableResize.call(this, event)}.bind(this))
					}
				else
					{
						var comp = $L('lyte-table-vertical-resize', this.$node).e[0];
						if(comp)
							{
								comp.parentElement.removeChild(comp);
							}
					}	
				if(ltPropResize.horizontal)
					{
						var comp = document.createElement('lyte-table-horizontal-resize')
						$L('lyte-table-structure', this.$node).e[0].appendChild(comp)
						comp.addEventListener('mousedown',function(event){this.$node.constructor._actions.tableResize.call(this, event)}.bind(this))
					}
				else
					{
						var comp = $L('lyte-table-horizontal-resize', this.$node).e[0];
						if(comp)
							{
								comp.parentElement.removeChild(comp);
							}
					}	
			}
	},

	data : function(){
		return {
			//user data
			ltPropContent:Lyte.attr("array",{"default":[]}),
			ltPropHeader:Lyte.attr("array",{"default":[]}),
			ltPropId:Lyte.attr("string",{"default":''}),
			ltPropClass:Lyte.attr("string",{"default":''}),
			ltPropBorder:Lyte.attr("boolean",{"default":false}),
			ltPropHeaderLabelKey : Lyte.attr("string",{"default":''}),
			ltPropBodyLabelKey : Lyte.attr("string",{"default":''}),
			ltPropWidth : Lyte.attr('string',{'default' : '100%'}),
			ltPropHeight : Lyte.attr('string',{'default' : '100%'}),
			ltPropResize : Lyte.attr('object',{'default' : {}}),
			ltPropFixedColumnClass : Lyte.attr('string',{'default':''}),
			ltPropYield : Lyte.attr('boolean',{'default':false}),
			ltPropScroll : Lyte.attr('object', {'default' : {horizontal : true , vertical : true}}),
			ltPropColumnSortable : Lyte.attr('boolean', {'default' : false}),
			ltPropScrollbarOption : Lyte.attr('object', {'default' : {}}),

			// scroll table test data
			ltPropData : Lyte.attr( "array", { "default" : [ ] } ),
			ltPropInfiniteScroll : Lyte.attr('boolean', {'default' : false}),
			ltPropCellHeight : Lyte.attr( 'string', { default : '20px' } ),
			ltPropCellWidth : Lyte.attr( 'string', { default : 'auto' } ),
			ltPropContentLength : Lyte.attr( 'number'),
			ltPropPreventScrollbar : Lyte.attr( 'boolean', { default : false } ),

			// system data
			columns : Lyte.attr('array',{'default' : []}),
			nonFixedColumn : Lyte.attr('array',{'default' : []}),
			minWidth1 : Lyte.attr('string',{'default' : ''}),
			minWidth2 : Lyte.attr('string',{'default' : ''}),
			secondaryData : Lyte.attr('array',{'default' : []}),
			boundary : Lyte.attr('object', {'default' : {}}),
			rowHeights : Lyte.attr('array', {'default' : []}),
			dualResize : Lyte.attr( 'boolean', { default : false } )
		}
	},
	actions:{
	     //  resize initialization 	
 	     'tableResize' : function(event){
 	     		$L.fastdom.measure(function(){
 	     			var resizeComponent = event.target.parentElement, Component = this, prevSibling = resizeComponent.previousElementSibling;
	 	    		document.Component = this; this.resizeComponent = resizeComponent, this.targetElem = event.target;
	 	    		if(( ( $L('lyte-th:last-of-type',resizeComponent.parentElement).e[0] != resizeComponent || this.data.dualResize ) && resizeComponent.tagName == 'LYTE-TH')|| resizeComponent.tagName != 'LYTE-TH')
	 	    			{
	 	    				resizeComponent.offLeft = resizeComponent.getBoundingClientRect().width + resizeComponent.getBoundingClientRect().left
			 	    		resizeComponent.offTop = event.clientY
			 	    		document.addEventListener('mouseup',this.mouseup)
			 	    		document.addEventListener('mousemove',this.resizeFunc)
			 	    		if(resizeComponent.tagName == 'LYTE-TH')
				 	    		{
				 	    			resizeComponent.classList.add( 'resizeSelect' )
				 	    			this.$node.classList.add( 'resizing' )
				 	    			var headerList = $L('lyte-th', this.$node).e;
		 	    					var arr = [], tabWid, dummyWid, dummyWid1, flag = resizeComponent.nextElementSibling;
		 	    					$L.fastdom.measure(function(){
		 	    						for(var i = 0; i < headerList.length; i++)
			 	    						{	
			 	    							if(!headerList[i].style.width || resizeComponent == headerList[ i ])
			 	    								{
			 	    									arr.push(headerList[i].offsetWidth)
			 	    								}
			 	    							else{
			 	    								arr.push(null);
			 	    							}	
			 	    						}
			 	    					if( this.data.dualResize ) {
			 	    						this.oriTab = this.$node.querySelector( 'lyte-table-structure' )
			 	    						tabWid = this.oriTab.getBoundingClientRect().width
			 	    					}
			 	    					$L.fastdom.mutate(function(){
			 	    						for(var i = 0; i < headerList.length; i++)
				 	    						{	
				 	    							if(arr[i])
				 	    								{
				 	    									headerList[i].style.width = arr[i] + 'px';
				 	    								}	
				 	    						}
				 	    					if( flag ){	
				 	    						dummyWid  = flag.style.width;
				 	    					}
				 	    					dummyWid1 = resizeComponent.style.width;
				 	    					$L.fastdom.measure(function(){
				 	    						if( flag ) {
				 	    							flag.style.removeProperty('width')
				 	    						}
					 	    					this.minWidth.call(this, resizeComponent, 'minWidth1')
					 	    					if( flag ){
					 	    						flag.style.width = dummyWid
					 	    					}
					 	    					if( !this.data.dualResize ) {
								 	    			resizeComponent.style.removeProperty('width')
						 	    					this.minWidth.call(this, flag, 'minWidth2')
						 	    					resizeComponent.style.width = dummyWid1;
						 	    				}
						 	    				$L.fastdom.mutate(function(){	
							 	    				if( this.data.dualResize ) {
						 	    						this.oriTab.style.width = tabWid + 'px';
						 	    					}
						 	    				}.bind(this))	
				 	    					}.bind(this))
			 	    					}.bind(this))
		 	    					}.bind(this))
				 	    		} else {
				 	    			var innTab = this.$node.querySelector( 'lyte-table-structure' );
			 	    				innTab.style.width = innTab.getBoundingClientRect().width + 'px';
				 	    		}
				 	    }
 	     		}.bind(this))
			 	 event.preventDefault();
      			 event.stopPropagation();
      			 event.stopImmediatePropagation();
 	    	 }
	},
	//min - width calculation
	minWidth : function(resizeComponent, arg){
		// for find original min width of a cell its width is set to its minumum width and width calculated 
		var minWidth = window.getComputedStyle(resizeComponent, null).getPropertyValue('min-width'),
		width  = resizeComponent.style.width
		resizeComponent.style.width = minWidth == '0px' ? '50px' : minWidth;
		minWidth = resizeComponent.offsetWidth + 'px'
		resizeComponent.style.width = width
		this.setData(arg, minWidth)		
	},

	resetScrollbar : function(evt){
		$L.fastdom.measure( function(){
			thisBccr = this.$node.getBoundingClientRect(), tabBccr = this.$node.querySelector( 'lyte-table-structure' ).getBoundingClientRect()
			if( this.scrollDiv.resetScrollbar ) {
				this.scrollDiv.resetScrollbar()
			}
			$L.fastdom.mutate( function(){
				var div = $L( '.lyteScrollContainer.lyteScrollContainerY', this.$node ).e[ 0 ], divX = $L( '.lyteScrollContainer.lyteScrollContainerX', this.$node ).e[ 0 ];
				if( div ) {
					if( thisBccr.right - tabBccr.right > 0 ) {
						div.style.right = ( thisBccr.right - tabBccr.right ) + 'px'
					} else {
						div.style.removeProperty( 'right' )
					}
				}

				if( divX ) {
					if( thisBccr.right - tabBccr.right > 0 ) {
						divX.style.width = ( tabBccr.width / thisBccr.width * 100 ) + '%'
					} else {
						divX.style.removeProperty( 'width' )
					}
				}
			}.bind( this ))
		}.bind( this ))
	},

	// resize finishing
	mouseup : function(event){
		var component = document.Component, resizeComponent = component.resizeComponent, thisBccr, tabBccr;
		component.resetScrollbar.call( component );
		$L.fastdom.mutate( function(){
			resizeComponent.classList.remove( 'resizeSelect' )
			component.$node.classList.remove( 'resizing' )
			document.removeEventListener('mouseup', component.mouseup)
			document.removeEventListener('mousemove', component.resizeFunc)
			delete document.Component; delete component.oriTab;
			if( component.getMethods( 'onResizeEnd' ) ) {
				$L.fastdom.mutate( function(){
					component.executeMethod( 'onResizeEnd', resizeComponent, component.$node )
				} )
			}
		})
		event.stopPropagation()
	},
	// resizing
	resizeFunc : function(event){
		var component = document.Component, resizeComponent = component.resizeComponent, ltPropResize = component.getData('ltPropResize'),offset = event.clientX - resizeComponent.offLeft,
		width2 = parseInt( resizeComponent.style.width );
		if((ltPropResize.horizontal || resizeComponent.tagName == 'LYTE-TH' ) && offset) 
			{
				var width = offset + width2 , tableWidth = component.getData('tableWidth');
				if(resizeComponent.tagName == 'LYTE-TH')
					{
						if(width > Math.ceil(parseFloat(component.getData('minWidth1'))))	
							{	
								var next = resizeComponent.nextElementSibling, width1 = next.getBoundingClientRect().width - offset
								if( !component.data.dualResize &&  width1 >  Math.ceil(parseFloat(component.getData('minWidth2'))))	
									{
								    	next.style.width = (width1) + 'px'
										resizeComponent.style.width = (width) + 'px'
									} else if( component.data.dualResize ) {
										component.oriTab.style.width = ( parseInt( component.oriTab.style.width ) + offset ) + 'px'
										resizeComponent.style.width = (width) + 'px';
									}
							}	
				    }
			    else if(resizeComponent.tagName != 'LYTE-TH' && (component.targetElem.tagName == 'LYTE-TABLE-HORIZONTAL-RESIZE' || component.targetElem.tagName == 'LYTE-TABLE-RESIZE'))
					{
						var elem = resizeComponent.parentElement;
						if(elem.tagName == 'LYTE-YIELD')
							{
								elem = elem.parentElement;
							}
						resizeComponent.style.width = (width) + 'px'
						component.$node.style.width = resizeComponent.style.width;
					}
				resizeComponent.offLeft = event.clientX
				delete resizeComponent.width;
			}
		if(ltPropResize.vertical && resizeComponent.tagName != 'LYTE-TH' && (component.targetElem.tagName == 'LYTE-TABLE-VERTICAL-RESIZE' || component.targetElem.tagName == 'LYTE-TABLE-RESIZE'))	
			{
				resizeComponent.style.height = (event.clientY + resizeComponent.getBoundingClientRect().height - resizeComponent.offTop) + 'px'
				resizeComponent.offTop = event.clientY
			}
		event.preventDefault(); 
		event.stopPropagation();
	},

	arrayFrom : function(nodeList){
	 	var arrayList = [];
	 	for(var i = 0; i < nodeList.length; i++)
	 		{
	 			arrayList.push(nodeList[i]);
	 		}
	 	return arrayList.slice();	
	 },

	closestFind : function(path, query){
			var elements = this.arrayFrom.call(this, document.querySelectorAll(query));
			for(var i = 0; i < path.length; i++)
				{
					if(Array.prototype.indexOf.call(elements, path[i]) != -1)
						{
							return path[i];
						}
				}
			return null;	
		}

});
Lyte.createCustomElement("lyte-th", {
	static : {
		 "observedAttributes" : {
			get : function() {
				return ['fixed', 'resize', 'icon'];
			}
		}
	},
	"attributeChangedCallback" : function(attr, oldVal, newVal) {
		if (attr == 'fixed') {
      	var scrollingDiv = this;
      	 while(scrollingDiv.tagName != 'DIV')
	      	{
	      		scrollingDiv = scrollingDiv.parentElement;
	      	}  
        if (newVal == 'enable') {
          this.classList.add('lyteFixedColumn');
        } else {
          this.classList.remove('lyteFixedColumn');
        }
      } else if (attr == 'resize') {
        if (newVal == 'enable') {
          var tabHead = document.createElement('lyte-tablehead-resize');
          tabHead.addEventListener('mousedown', this.resize);
          this.appendChild(tabHead);
        } else {
          var tabHead = this.querySelector('lyte-tablehead-resize');
          if (tabHead) {
            this.removeChild(tabHead);
          }
        }
      } else if(attr == 'icon'){
      	if(newVal == 'disable'){
      		this.classList.add('lytePreventIcon');
      	} else {
      		this.classList.remove('lytePreventIcon');
      	}
      }
	},
	resize : function(event){
		  var resizeComponent = event.target.parentElement, table = event.target;
	      while(table.tagName != 'LYTE-TABLE')
	      	{
	      		table = table.parentElement;
	      	}    
	      table.constructor._actions.tableResize.call(table.component, event);
	}
});

function resizeTable( evt ) {
	var tables = $L( 'lyte-table[lyte-rendered]' ).e;
	for( var i = 0; i < tables.length; i++ ) {
		var comp = tables[ i ].component;
		comp.resetScrollbar.call( comp, evt )
	}
}


/*
    Notes :
        1. Added ltPropHeight property to set the height of the tab.
*/

Lyte.Component.register("lyte-tabs", {
_template:"<template tag-name=\"lyte-tabs\">\t<template is=\"if\" value=\"{{ltPropYield}}\"><template case=\"true\">\t\t<lyte-yield yield-name=\"tabYield\"></lyte-yield>\t</template></template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"if","position":[1],"cases":{"true":{"dynamicNodes":[{"type":"insertYield","position":[1]}]}},"default":{}}],
_observedAttributes :["ltPropYield","ltPropHover","ltPropActiveClass","ltPropPosition","ltPropOpenTabOn","ltPropNewContent","ltPropCloseIcon","prevTarget","ltPropHeight"],
    init : function(){
        this.$node.addTab = function(newTab){
            this.component.constructTabs(this,newTab);
        };
        this.$node.deleteTab = function(tabId){
            this.component.deleteTabContent(tabId);
        };
        this.$node.openTab = function(tabId){
            this.component.openTabContent(tabId);
        };
    },

    data : function(){
        return {
            "ltPropYield" : Lyte.attr("boolean",{"default":true}),
            "ltPropHover" : Lyte.attr("string",{"default":"lyteTabHover"}),
            "ltPropActiveClass" : Lyte.attr("string",{"default":"lyteTabActive"}),
            "ltPropPosition" : Lyte.attr("object",{"default":{'pos' : 'top', 'align' : 'left'}}),
            "ltPropOpenTabOn" : Lyte.attr("string",{"default":"click"}),
            "ltPropNewContent" : Lyte.attr("array",{"default":[]}),
            "ltPropCloseIcon" : Lyte.attr("boolean",{"default":false}),
            // "ltPropChangedHeader" : Lyte.attr("boolean",{"default":false}),
            "prevTarget" : Lyte.attr("object",{"default":null}),
            "ltPropHeight" : Lyte.attr("string",{"default":"400px"})
        }       
    },

    initialFunc : function(){
        
        //Checking whether the lyte-tabs is having any content or not by counting its child element for avoiding unnecessary error
        if(this.$node.childElementCount > 1 || this.$node.children[0].tagName === "LYTE-TAB"){

            //Checking the format provided by user for lyte-tabs
            /* **-- NOT REQUIRED NOW --**   --   If the format is Format 2 then convert it to format 1 
            if(this.$node.firstElementChild.tagName === "LYTE-TAB"){
                var node = this.$node.cloneNode(true);
                this.$node.innerHTML = "";
                this.$node.append(document.createElement('lyte-tab-head'));
                this.$node.append(document.createElement('lyte-tab-body'));
                var childNodes = node.querySelectorAll('lyte-tab');
                for(var v=0; v<childNodes.length ; v++){
                    this.constructTabs(this.$node,childNodes[v]);
                }
            }
            **-- NOT REQUIRED NOW --** */
            var head = this.$node.querySelector('lyte-tab-head');
            $L(head).addClass('lyteTabNav');
            var position = this.getData("ltPropPosition");
            var labels = this.getHeader(head.children);
            var contents = this.getContent(this.$node.querySelector('lyte-tab-body').children);
            var active = this.getData('ltPropActiveClass');
            var pos;
            this.setPosition(position);
            if(position.pos === "bottom"){
                $L.fastdom.measure(function() {
                    var navHeight = this.$node.querySelector('.lyteTabNav').getBoundingClientRect().height;
                    var thisHeight = this.$node.clientHeight;
                    $L.fastdom.mutate(function() {
                        this.$node.querySelector('.lyteTabNav').style.top = (thisHeight - navHeight) + "px";
                    },this);
                },this);
            }
            // debugger
            if(this.getData('ltPropCloseIcon')){
                this.createCloseIcon(this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title'));
            }
            
            var clickFn = function(event){this.showTab(event)};
            var mouseoverFn = function(event){this.mouseOver(event)};
            var mouseoutFn = function(event){this.mouseOut(event)};

            //Binds the events to tab-head
            head.addEventListener('click',clickFn.bind(this),true);
            head.addEventListener('mouseover',mouseoverFn.bind(this),true);
            head.addEventListener('mouseout',mouseoutFn.bind(this),true);

            //To open a tab content
            for(var i=0;i<labels.length;i++){
                if($L(labels[i]).hasClass(active)){
                    pos = i;
                }
            }
            for(var i=0;i<contents.length;i++){
                if(pos && pos === i){
                    // contents[i].classList.add('lyteTabShow');
                    this.executeOnBeforeOpen(labels[pos].getAttribute('lt-prop-id'),null);
                    $L(contents[i]).addClass('lyteTabShow');
                    this.executeOnOpen(labels[pos].getAttribute('lt-prop-id'),null);
                }
                else{
                    // contents[i].classList.add('lyteTabHide');
                    $L(contents[i]).addClass('lyteTabHide');
                }
            }
            if(!pos){
                pos=0;
                this.executeOnBeforeOpen(labels[0].getAttribute('lt-prop-id'),null);
                labels[0].classList.add(active);
                $L(contents[0]).removeClass('lyteTabHide');
                $L(contents[0]).addClass('lyteTabShow');
                this.executeOnOpen(labels[0].getAttribute('lt-prop-id'));
            }
            this.setData('prevTarget',labels[pos]);

            $L.fastdom.measure(function() {    //Sets the height and width of the tab label and content based on the given values and positions.
                var cs = window.getComputedStyle(this.$node);
                var borderDimensionY = ((cs.borderTop ? parseFloat(cs.borderTop) : 0) +
                                     (cs.borderBottom ? parseFloat(cs.borderBottom) : 0));
                var navHeight = this.$node.querySelector('.lyteTabNav').getBoundingClientRect().height;
                var thisHeight = parseInt(this.getData('ltPropHeight')) - borderDimensionY;
                $L.fastdom.mutate(function() {
                    if(position.pos === "left" || position.pos === "right"){
                        this.$node.querySelector('.lyteTabNav').style.height = thisHeight + "px";
                        this.$node.querySelector('lyte-tab-body').style.height = thisHeight + "px";
                    }
                    if(position.pos === "top" || position.pos === "bottom"){
                        this.$node.querySelector('lyte-tab-body').style.height = (thisHeight - navHeight) + "px";
                    }
                    this.makeAlignment(this.getData("ltPropPosition"));
                },this);
            },this);
            
            this.customizeTitleTab(position.pos);
        }
        else{
            console.error("No content detected");
        }
        
    }.observes('ltPropPosition').on('didConnect'),

    showTab : function(event){
        var target = event.target;
        while(target.parentElement && target.tagName != 'LYTE-TAB-TITLE'){
            target = target.parentElement;
        }
        if(target.tagName == 'HTML'){
            return;
        }
        var id = target.getAttribute('lt-prop-id');

        //If user has clicked on the close icon
        if($L(event.target).hasClass('lyteTabCloseIcon')){
            this.deleteTabContent(id);
            this.makeAlignment(this.getData('ltPropPosition'));
            target = (this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title').length > 0) ? this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title')[0] : null;
            if(!target){
                this.setData('prevTarget',null);
                return
            }
            id = target.getAttribute('lt-prop-id');
        }
        // this.executeOnBeforeOpen(id,this.getData('prevTarget').getAttribute('lt-prop-id'));
        this.openTabContent(id);
        // this.executeOnOpen(id);
        this.setData('prevTarget',target);
    },

    mouseOver : function(event){
        // console.log("over");
        var target = event.target;
        // console.log(target);
        while(target.parentElement && target.tagName != 'LYTE-TAB-TITLE'){
            target = target.parentElement;
        }
        if(target.tagName == 'HTML'){
            return;
        }
        var hover = this.getData('ltPropHover');
        // event.currentTarget.classList.add(hover);
        $L(target).addClass(hover);
    },

    mouseOut : function(event){
        // console.log("out");
        var target = event.target;
        while(target.parentElement && target.tagName != 'LYTE-TAB-TITLE'){
            target = target.parentElement;
        }
        if(target.tagName == 'HTML'){
            return;
        }
        var hover = this.getData('ltPropHover');
        // event.currentTarget.classList.remove(hover);
        $L(target).removeClass(hover);
    },

    getContent : function(children){
        var contents = [];
        for(var i = 0; i<children.length; i++){
            if(children[i].tagName == "LYTE-TAB-CONTENT"){
                contents.push(children[i]);
            }
        }
        return contents;
    },
    getHeader : function(children){
        var headers = [];
        for(var i = 0; i<children.length; i++){
            if(children[i].tagName == "LYTE-TAB-TITLE"){
                headers.push(children[i]);
            }
        }
        return headers;
    },


    //Changes tabs in Format 2 to Format 1 structure
    //Also creates new tab if called from the addTab function
    constructTabs : function(parentEle,node){
        var title = "";
        var content = "";
        var id;
        var isObject = false;
        var titleEle = document.createElement('lyte-tab-title');
        var contentEle = document.createElement('lyte-tab-content');
        if(typeof node === "object" && node.tagName === "LYTE-TAB"){
            title = node.getAttribute("lt-prop-title");
            content = node.innerHTML;
            id = node.getAttribute("lt-prop-id");
        }
        else{
            title = node.title;
            content = node.content;
            id = node.id;
            isObject = true;
        }
        if(!id){
            id = this.generateId(title);
        }
        titleEle.innerHTML = title;
        contentEle.innerHTML = content;
        titleEle.setAttribute('lt-prop-id',id);
        contentEle.id = id;
        $L(contentEle).addClass('lyteTabHide');
        parentEle.querySelector('lyte-tab-head').append(titleEle);
        parentEle.querySelector('lyte-tab-body').append(contentEle);

        //Checks whether the format is changed or a new tab is added
        //If a new tab is added it will execute the code inside this if-block
        if(isObject){
            // var clickFn = function(event){this.showTab(event)};
            // var mouseoverFn = function(event){this.mouseOver(event)};
            // var mouseoutFn = function(event){this.mouseOut(event)};
            // titleEle.addEventListener('click',clickFn.bind(this));
            // titleEle.addEventListener('mouseover',mouseoverFn.bind(this));
            // titleEle.addEventListener('mouseout',mouseoutFn.bind(this));
            if(this.getData('ltPropCloseIcon')){
                this.createCloseIcon(new Array(titleEle));
            }
            this.makeAlignment(this.getData('ltPropPosition'));
        }
    },

    deleteTabContent : function(tabId){
        if(tabId){
            var content = this.$node.querySelector('#'+tabId);
            var headers = this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title');
            var isCustomized = false;
            for(var v=0 ; v<headers.length ;v++){
                if(headers[v].getAttribute('lt-prop-id') === tabId){
                    if($L(headers[v]).hasClass('lyteTabCustomTitleWidth')){
                        isCustomized = true;
                    }
                    this.$node.querySelector('lyte-tab-head').removeChild(headers[v]);
                    if(content){
                        this.$node.querySelector('lyte-tab-body').removeChild(content);
                    }
                    break;
                }
            }
            if(isCustomized){
                this.customizeTitleTab("afterDelete");
            }
        }
    },

    openTabContent : function(tabId){
        if(tabId){
            this.hideAll();
            var headers = this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title');
            var content = this.$node.querySelector('#'+tabId);
            for(var v=0 ; v<headers.length ;v++){
                if(headers[v].getAttribute('lt-prop-id') === tabId){
                    this.executeOnBeforeOpen(tabId,this.getData('prevTarget') ? this.getData('prevTarget').getAttribute('lt-prop-id') : null);
                    $L(headers[v]).addClass(this.getData('ltPropActiveClass'));
                    if(content){
                        $L(content).removeClass('lyteTabHide');
                        $L(content).addClass('lyteTabShow');
                    }
                    this.executeOnOpen(tabId);
                    break;
                }
            }
        }
    },

    createCloseIcon : function(headers){
        for(var v=0;v<headers.length;v++){
            var span = document.createElement('span');
            span.innerHTML = headers[v].innerHTML;
            // span.style.float = "left";
            headers[v].innerHTML = "";
            headers[v].appendChild(span);
            var closeSpan = document.createElement('span');
            closeSpan.classList.add('lyteTabCloseIcon');
            // closeSpan.style.marginTop = (headers[0].getBoundingClientRect().height - 9 - 2) / 2 + 'px';
            headers[v].appendChild(closeSpan);
        }
    },

    setPosition : function(position){
        switch(position.pos){
            case "left" : $L(this.$node).addClass('lyteTabDefaultLeft');/*this.setHeight("left");*/break;
            case "right" : $L(this.$node).addClass('lyteTabDefaultRight');/*this.setHeight("right");*/break;
            case "top" : $L(this.$node).addClass('lyteTabDefaultTop');/*this.setHeight("top");*/break;
            case "bottom" : $L(this.$node).addClass('lyteTabDefaultBottom');/*this.setHeight("bottom");*/break;
        }

    },

    setHeight : function(prop){
    	$L.fastdom.measure(function() {
    		var thisHeight = this.$node.clientHeight;
    		var navHeight = this.$node.querySelector('.lyteTabNav').getBoundingClientRect().height;
	        $L.fastdom.mutate(function() {
		        if(prop === "left" || prop === "right"){
		            this.$node.querySelector('.lyteTabNav').style.height = thisHeight + 'px';
		            this.$node.querySelector('lyte-tab-body').style.height = thisHeight + 'px';
		        }
		        else{
		            this.$node.querySelector('lyte-tab-body').style.height = (thisHeight - navHeight) + 'px';
		        }
		    },this);
	    },this);
    },

    hideAll : function(){
        var labels = this.getHeader(this.$node.querySelector('lyte-tab-head').children);
        var contents = this.getContent(this.$node.querySelector('lyte-tab-body').children);
        var active = this.getData('ltPropActiveClass');
        for(var i=0;i<labels.length;i++){
            if($L(labels[i]).hasClass(active)){
                $L(labels[i]).removeClass(active);
            }
        }
        for(var v=0;v<contents.length;v++){
            if($L(contents[v]).hasClass('lyteTabShow')){
                $L(contents[v]).removeClass('lyteTabShow');
                $L(contents[v]).addClass('lyteTabHide');
            }
            if(!$L(contents[v]).hasClass('lyteTabHide')){
                $L(contents[v]).addClass('lyteTabHide');
            }
        }
    },

    customizeTitleTab : function(prop){
    	$L.fastdom.measure(function() {
    		var compWidth = this.$node.querySelector('lyte-tab-head').getBoundingClientRect().width;
	        if(prop === "top" || prop === "bottom"){
	            var totalWidth = 0;
	            var width = 0;
	            var titles = this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title');
	            for(var i=0;i<titles.length;i++){
	                totalWidth = totalWidth + titles[i].getBoundingClientRect().width;
	            }
	            if(totalWidth > compWidth){
	                width = compWidth / titles.length;
	                $L.fastdom.mutate(function() {
		                for(var i=0;i<titles.length;i++){
		                    titles[i].style.width = width + "px";
		                    $L(titles[i]).addClass('lyteTabCustomTitleWidth');
		                }
	           		});
	            }

	        }
	        if(prop === "afterDelete"){
	            var titles = this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title');
	            var width = compWidth / titles.length;
	            $L.fastdom.mutate(function() {
		            for(var i=0;i<titles.length;i++){
		                titles[i].style.width = width + "px";
		            }
		        });
	        }
    	},this);
    },

    makeAlignment : function(position){
        var headers = this.$node.querySelector('lyte-tab-head').querySelectorAll('lyte-tab-title');
        if(headers.length > 0){
        	$L.fastdom.measure(function() {
        		var lastHeader = headers[headers.length - 1].getBoundingClientRect();
        		var firstHeader = headers[0].getBoundingClientRect();
        		var head = this.$node.querySelector('lyte-tab-head').getBoundingClientRect();

	            var headersWidth = lastHeader.right - firstHeader.left;
	            var headersHeight = lastHeader.bottom - firstHeader.top;
	            var compWidth = head.width;
	            var compHeight = head.height;
	            if(position.pos === "left" || position.pos === "right"){
	                if(headersHeight+1 < compHeight){
	                    var diff = compHeight - (headersHeight);
	                    $L.fastdom.mutate(function() {
		                    if(position.align === "center"){
		                        headers[0].style.marginTop = diff/2 + "px";
		                    }
		                    if(position.align === "bottom"){
		                        headers[0].style.marginTop = diff + "px";
	                    	}
	                	});
	                }
	            }
	            if(position.pos === "top" || position.pos === "bottom"){
	                if(headersWidth+1 < compWidth){
	                    var diff = compWidth - (headersWidth+1);
	                    $L.fastdom.mutate(function() {
		                    if(position.align === "center"){
		                        headers[0].style.marginLeft = diff/2 + "px";
		                    }
		                    else if(position.align === "right"){
		                        for(var i =0;i< headers.length;i++){
		                            headers[i].style.float = "right";
		                        }
		                    }
		                });
	                }
	            }
            },this);
        }
    },

    executeOnBeforeOpen : function(targetId,prevEleId){
        if(this.getMethods('onBeforeOpen')){
            this.executeMethod('onBeforeOpen',this.$node.querySelector("#"+targetId),this.$node.querySelector("#"+prevEleId));
        }
    },

    executeOnOpen : function(targetId){
        if(this.getMethods('onOpen')){
            this.executeMethod('onOpen',this.$node.querySelector("#"+targetId));
        }
    },

    generateId : function(text){
        while(text.indexOf(" ") !== -1){
            text = text.replace(" ","_");
        }
        return text;
    }
});

Lyte.Component.register('lyte-tooltip',{
_template:"<template tag-name=\"lyte-tooltip\">   </template>",
_dynamicNodes : [],
_observedAttributes :["ltPropId","ltPropClass","ltPropKeepAlive","eventListeners"],
  init : function(){
    if(this.getMethods('beforeRender'))
        {
            this.executeMethod('beforeRender', this.$node);
        }
  },
  
  data : function(){
    return {
      //user data
      ltPropId : Lyte.attr('string', {default : ''}),
      ltPropClass : Lyte.attr('string', {default : ''}),
      ltPropKeepAlive : Lyte.attr('boolean', {default : false}),
      // system data
      eventListeners : Lyte.attr('object', {default : {}})
    }
  },

  didConnect : function(){
      var tooltips = $L('lyte-tooltip').e
      this._clickHide = this.clickHide;
      if(tooltips.length > 1)
          {
            for(var mn = 0; mn < tooltips.length; mn++)
                {
                  if(!(tooltips[mn].getAttribute('lt-prop-class') || tooltips[mn].getAttribute('lt-prop-id')) && tooltips[mn] != this.$node)
                      {
                         tooltips[mn].parentElement.removeChild(tooltips[mn]);  
                      }
                }
          }
      var evt = this.mousemove.bind(this);
      this.setData('eventListeners.mousemove', evt);
      document.addEventListener('mousemove', evt, true);   
      window.addEventListener('scroll',this.tooltipScroll , true); 
      this._mousedown = this.mousedown.bind( this );
      this._mouseup = this.mouseup.bind( this );
      this._keydown = this.keydown.bind( this );
      document.addEventListener( 'keydown', this._keydown, true);
      document.addEventListener( 'mousedown', this._mousedown, true );
      if(this.getMethods('afterRender'))
            {
                this.executeMethod('afterRender', this.$node);
            }

  },

  tooltipScroll : function(event){
    if($L('span.lyteTooltip:not(.lyteTooltipHidden)').e.length) {
        $L( 'span.lyteTooltip:not(.lyteTooltipHidden)' ).addClass( 'lyteTooltipHidden' )
    }
  },

  mousedown : function(event){
      this._mousedownFlag = true;
      if( event.target.classList.contains( 'lyteSliderHandler' ) ){
        delete  this.prevTooltipNode;
        this._slider = true;
      }
      this.closeAllTooltip();
      document.addEventListener( 'mouseup', this._mouseup, true)
  },

  mouseup : function( event ) {
    delete this._mousedownFlag;
    document.removeEventListener('mouseup', this._mouseup, true);
    if( this._slider ){
      delete this._slider;
      if( event.target.classList.contains( 'lyteSliderHandler' ) ){
        this.mousemove({ target : event.target});
      }
    }
  },

  keydown : function( evt ) {
     delete  this.prevTooltipNode;
     this.closeAllTooltip();
  },

  tooltipOpenCallback : function( arg1, arg2 ) {
      if( arg1.onTooltipShow ) {
          arg1.onTooltipShow.apply(this, arguments)     
      }
      if(this.getMethods( 'onTooltipShow' ) ) {
          this.executeMethod( 'onTooltipShow', arg1, arg2, arg1.tooltip );
      }
  },

  tooltipCloseCallback : function( arg1 ) {
      if( arg1.onTooltipHide ) {
          arg1.onTooltipHide.apply(this, arguments)     
      }
     if(this.getMethods( 'onTooltipHide' ) ) {
          this.executeMethod( 'onTooltipHide', arg1 );
      }
  },

  didDestroy : function(){
        window.removeEventListener('scroll',this.tooltipScroll , true);
        document.removeEventListener('mousemove', this.getData('eventListeners').mousemove, true);
        document.removeEventListener('mouseup', this._mouseup, true);
        document.removeEventListener( 'keydown', this._keydown, true );
        var exsttools = $L( 'span.lyteTooltip').e;
        for( var i = 0; i < exsttools.length; i++ ) {
          delete exsttools[i].nodeName1.tooltipSpan;
          delete exsttools[i].nodeName1.tooltip;
          document.body.removeChild(exsttools[i]);
        }
  },

  propertySetting : function(nodeName1){
      var config = nodeName1.getAttribute('lt-prop-tooltip-config');
      if( config )
          {
                var config = JSON.parse( config );
                for(var key in config)
                  {
                     nodeName1.tooltip.config[key] = config[key];
                  }
          }
  },

  createTooltip : function(event, span, flag){
      if(flag){
             this.followcursor.call(this, event, span)
          }
       else{
             this.nonFollowcursor.call(this, event, span)
          }
      if(!this.getData('ltPropKeepAlive'))      
          {
            if((span.nodeName1.tooltip.config.keeptooltip != true && span.nodeName1.tooltip.config.keeptooltip != 'true'))
                 {
                    span.nodeName1.tooltip.maxdisp = setTimeout(function(){
                    if(document.body.contains(span))
                      {
                         if( this.prevTooltipNode == span.nodeName1 ) {
                            delete this.prevTooltipNode;
                         }
                         var node = span.nodeName1;
                         delete span.nodeName1.tooltipSpan;
                         delete span.nodeName1.tooltip;
                         document.body.removeChild(span);
                        this.tooltipCloseCallback( node );
                      }
                    }.bind( this ), span.nodeName1.tooltip.config.maxdisplaytime);
                }
          }
  },

  followcursor : function(event, span){
    // here tooltip changes its position on every mousemov. so fastdom can't  be used here
      if(document.body.contains(span))
          {
            // span.innerText = span.nodeName1.tooltip.title; 
            if( !span._callbackHandled ) {
                this.tooltipOpenCallback( span.nodeName1, span );
                span._callbackHandled = true;
            } 
            // $L.fastdom.measure(function(){
                  // calculating page off set
                  var xscroll = window.pageXOffset || document.documentElement.scrollLeft
                  var yscroll = window.pageYOffset || document.documentElement.scrollTop  
                  span.classList.remove( 'lyteTooltipHidden' )
                  // $L.fastdom.mutate(function(){
                      span.style.left = event.clientX + xscroll +'px';
                      span.style.top =(event.clientY + yscroll + 5 + span.nodeName1.tooltip.config.margin) + 'px';
                  // })  
            // }.bind(this))
          }
  },

  nonFollowcursor : function(event, span, position, prevent){
    // $L.fastdom.mutate(function(){
        span.classList.remove( 'lyteTooltipHidden' )
        if( !span._callbackHandled ) {
                this.tooltipOpenCallback( span.nodeName1, span );
                span._callbackHandled = true;
            } 
        // span.className = 'lyteTooltip ' + span.nodeName1.tooltip.classname + (this.getData('ltPropClass') ? ' ' +  this.getData('ltPropClass') : '');
         $L.fastdom.measure(function(){
            if(!position)
              {
                position = span.nodeName1.tooltip.config.position;
              }
              // calculating page off set 
            var xscroll = window.pageXOffset || document.documentElement.scrollLeft
            var yscroll = window.pageYOffset || document.documentElement.scrollTop  
            var spanClientRect = span.getBoundingClientRect();
            var nodeClientRect = span.nodeName1.getBoundingClientRect();
            var left = nodeClientRect.left + xscroll;
            var topPos = nodeClientRect.top + yscroll;
            var margin = span.nodeName1.tooltip.config.margin;
            margin = margin > 20 ? 20 : margin;         
            var toolwid = span.offsetWidth;
            var divWidth = nodeClientRect.width;
            var wid = nodeClientRect.height;
            var appearance = span.nodeName1.tooltip.config.appearance;
            var innWidth = window.innerWidth, innHeight = window.innerHeight;
            switch(position.toLowerCase())
              {
                case 'right' :
                 {
                    if(appearance=="callout")
                        {
                            span.classList.add('lyteRight');
                            // need to calculate arrow height after adding class
                            left+= parseInt(window.getComputedStyle(span, ':after').getPropertyValue('border-left-width'));
                        }
                    var newLeft = (left+divWidth+margin)+'px';
                    span.style.top=(topPos+wid/2-span.offsetHeight/2)+'px';
                    if( ( innWidth + xscroll ) < (parseInt(newLeft) + spanClientRect.width))
                      {
                         span.classList.remove('lyteRight');
                         if( !prevent ){
                          this.nonFollowcursor.call(this,event, span,'left', true);
                        }
                      }
                    else{
                      span.style.left = newLeft;
                    }
                    break; 
                 }
                 case 'left' :
                   {
                      if(appearance=="callout")
                          {
                              span.classList.add('lyteLeft');
                              // need to calculate arrow height after adding class
                              left-= parseInt(window.getComputedStyle(span, ':before').getPropertyValue('border-left-width'));
                          }
                       var newLeft = (left-margin- toolwid )+'px';
                       span.style.top=(topPos+wid/2-span.offsetHeight/2)+'px';
                      if(parseInt(newLeft) < xscroll)
                        {
                          span.classList.remove('lyteLeft');
                           if( !prevent ){
                              this.nonFollowcursor.call(this,event, span,'right', true);
                            }
                        }
                      else{
                           span.style.left = newLeft;
                      }  
                      break;  
                   }
                case 'bottom' :
                  {
                    if(appearance=="callout")            
                        {
                            span.classList.add('lyteBottom');
                            // need to calculate arrow height after adding class
                            topPos+= parseInt(window.getComputedStyle(span, ':after').getPropertyValue('border-left-width'));
                        }
                    span.style.left=(left+divWidth/2- toolwid /2)+'px';
                    var newTop = (topPos+wid+margin)+'px';
                    if(( yscroll + innHeight ) < (parseInt( newTop ) + spanClientRect.height))
                       {
                          span.classList.remove('lyteBottom');
                           if( !prevent ){
                              this.nonFollowcursor.call(this,event, span,'top', true);
                            }
                       }
                    else{
                       span.style.top = newTop;
                    }      
                    break;  
                  }     
                case 'top' :
                  {
                    if(appearance=="callout")
                       {
                            span.classList.add('lyteTop');
                            // need to calculate arrow height after adding class
                            topPos-= parseInt(window.getComputedStyle(span, ':after').getPropertyValue('border-left-width'));
                       }
                    span.style.left=(left+divWidth/2- toolwid /2)+'px';
                    var newTop = (topPos-margin-span.clientHeight)+'px';
                    if(parseInt( newTop ) < yscroll)
                       {
                         span.classList.remove('lyteTop');
                          if( !prevent ){
                            this.nonFollowcursor.call(this,event, span,'bottom', true);
                          }
                       } 
                    else{
                        span.style.top = newTop;
                    }    
                    break;     
                  }
                 case 'bottomright' :
                  {
                    if(appearance=="callout")
                       {
                           span.classList.add('lyteBottomright');
                           // need to calculate arrow height after adding class
                           topPos+= parseInt(window.getComputedStyle(span, ':after').getPropertyValue('border-left-width'));
                       }
                    var newLeft =(left+divWidth*.75-0.2* toolwid )+'px';
                    var newTop =(topPos+wid+margin)+'px';
                    if(( innWidth + xscroll ) < (parseInt(newLeft)+ spanClientRect.width))
                        {
                          span.classList.remove('lyteBottomright');
                          if( !prevent ){
                            this.nonFollowcursor.call(this,event, span,'BottomLeft',true);
                          }
                          break;
                        }
                    else{
                        span.style.left = newLeft;
                    }     
                   if( ( innHeight + yscroll ) < (parseInt(newTop)+ spanClientRect.height)) 
                       {
                         span.classList.remove('lyteBottomright');
                         if( !prevent ){
                            this.nonFollowcursor.call(this,event, span,'topright', true);
                          }
                         break
                       }
                     else{
                        span.style.top = newTop;
                     }  
                    break; 
                  }
                case 'topright' :
                  {
                    if(appearance=="callout")
                       {
                            span.classList.add('lyteTopright');
                            // need to calculate arrow height after adding class
                            topPos-=parseInt(window.getComputedStyle(span, ':after').getPropertyValue('border-left-width'));
                       }
                    var newLeft =( left + divWidth * .75 - 0.2 * toolwid ) + 'px';
                    var newTop =(topPos-span.clientHeight-margin)+'px';
                     if( ( innWidth + xscroll ) < (parseInt(newLeft) + spanClientRect.width))
                         {
                           span.classList.remove('lyteTopright');
                           if( !prevent ){
                              this.nonFollowcursor.call(this,event, span,'topleft', true);
                            }
                           break;
                        }
                    else{
                        span.style.left = newLeft;
                    } 
                    if(parseInt(newTop)< yscroll)
                        {
                           span.classList.remove('lyteTopright');
                           if( !prevent ){
                              this.nonFollowcursor.call(this,event, span,'bottomright', true);
                            }
                           break
                       }
                     else{
                        span.style.top = newTop;
                     }  
                     break;      
                 }
                case 'bottomleft' :
                   {
                     if(appearance=="callout")
                        {
                            span.classList.add('lyteBottomleft');
                            // need to calculate arrow height after adding class
                            topPos+=parseInt(window.getComputedStyle(span, ':after').getPropertyValue('border-left-width'));
                        }
                     var newLeft =(left- toolwid *.8+0.25*divWidth)+'px';
                     var newTop =(topPos+wid+margin)+'px';
                     if(parseInt(newLeft) < xscroll)
                        {
                            span.classList.remove('lyteBottomleft');
                            if( !prevent ){
                                this.nonFollowcursor.call(this,event, span,'bottomright', true);
                            }
                            break;
                        }
                    else{
                        span.style.left = newLeft;
                    } 
                    if(( innHeight + yscroll ) < (parseInt(newTop) + spanClientRect.height))
                        {
                            span.classList.remove('lyteBottomleft');
                            if( !prevent ){
                              this.nonFollowcursor.call(this,event, span,'topleft', true);
                            }
                            break
                       }
                     else{
                        span.style.top = newTop;
                     } 
                     break; 
                    }
                 case 'topleft' :
                    {
                        if(appearance=="callout")
                          {
                              span.classList.add('lyteTopleft');
                              // need to calculate arrow height after adding class
                              topPos-= parseInt(window.getComputedStyle(span, ':after').getPropertyValue('border-left-width'));
                          }
                        var newLeft = (left -  toolwid  * .8 + 0.25 * divWidth)+'px';
                        var newTop = (topPos-parseInt(span.clientHeight)-margin)+'px';
                        if(parseInt(newLeft)< xscroll)
                          {
                              span.classList.remove('lyteTopleft');
                              if( !prevent ){
                                  this.nonFollowcursor.call(this,event, span,'topright', true);
                              }
                              break;
                          }
                        else{
                              span.style.left = newLeft;
                          } 
                        if(parseInt(newTop)< yscroll)
                          {   
                              span.classList.remove('lyteTopleft');
                              if( !prevent ){
                                  this.nonFollowcursor.call(this,event, span,'bottomleft', true);
                              }
                              break
                           }
                         else{
                            span.style.top = newTop;
                         }
                        break;    
                       }
                default:
                   {
                    var tooltop=0;
                    if(appearance=="callout")
                        {
                            span.classList.add('lyteBottom');
                            // need to calculate arrow height after adding class
                            tooltop = parseInt(window.getComputedStyle(span, ':after').getPropertyValue('border-left-width'));
                        }
                      var newLeft =(parseInt(event.clientX)- toolwid / 2) + 'px';
                      var newTop =(topPos+tooltop+wid+margin)+'px';
                      if(parseInt(newLeft)< xscroll)
                        {
                           span.style.left = '0px';
                        }
                      else{
                          span.style.left = newLeft;
                      } 
                     if(( innHeight + yscroll) < (parseInt( newTop ) + spanClientRect.height))
                       {
                          span.classList.remove('lyteBottom');
                          if( !prevent ){
                            this.nonFollowcursor.call(this,event, span,'top', true);
                          }
                       }
                     else{
                        span.style.top = newTop;
                     }
                   }
                }
          }.bind(this))
    // }.bind(this))
  },

closeAllTooltip : function(current){
    var tooltipsopen = $L('span.lyteTooltip').e;
    for(var i = 0; i < tooltipsopen.length; i++)
      {
        if(tooltipsopen[i].nodeName1 != current){
          if(document.body.contains(tooltipsopen[i])){
              tooltipsopen[i].nodeName1.tooltip.bodyTimeout = setTimeout(this.removeTooltip.bind( this ), tooltipsopen[i].nodeName1.tooltip.config.hidedelay, tooltipsopen[i], event);
            }
        }
      }
},  

removeTooltip : function(span, event){
         if(document.body.contains(span))
            {
               clearTimeout(span.nodeName1.tooltip.disptime);
               clearTimeout(span.nodeName1.tooltip.settime);
               if( this.prevTooltipNode == span.nodeName1 ) {
                  delete this.prevTooltipNode;
               }
               var node = span.nodeName1
               delete span.nodeName1.tooltipSpan;
               delete span.nodeName1.tooltip;
               document.body.removeChild(span)
               this.tooltipCloseCallback( node )
            }
},
  mousemove : function(event){
        if( this._mousedownFlag ) {
          return
        }
        var nodeName1 = event.target;
        while(nodeName1 && nodeName1.tagName != 'BODY' && nodeName1 != document && nodeName1.tagName != 'HTML' ){
            if(nodeName1.getAttribute('lt-prop-title'))
                {
                  if(nodeName1.getAttribute('title'))
                      {
                        nodeName1.removeAttribute('title')
                      }
                   if(!nodeName1.hasOwnProperty('tooltip'))   
                      {
                        nodeName1.tooltip = {};
                      }
                   nodeName1.tooltip.config = {position : '', appearance : 'callout', margin : 0, showdelay : 0, hidedelay : 0, maxdisplaytime : 5000, keeptooltip : false}
                   nodeName1.tooltip.title = nodeName1.getAttribute('lt-prop-title');
                   this.propertySetting.call(this, nodeName1);
                   if(this.prevTooltipNode != nodeName1 && !nodeName1.tooltip.tooltipSpan)
                      {
                          this.prevTooltipNode = nodeName1;
                          var span = document.createElement('span'), toolclass = nodeName1.getAttribute( 'lt-prop-tooltip-class' );
                          var ltPropId = this.getData('ltPropId'), ltPropClass = this.getData('ltPropClass');
                          if(ltPropId)
                              {
                                 span.setAttribute('id', ltPropId);
                              }
                          if(ltPropClass)
                              {
                                  span.classList.add(ltPropClass);
                              }    
                          span.classList.add('lyteTooltip');
                          span.classList.add('lyteTooltipHidden');
                          if(nodeName1.getAttribute('lt-prop-tooltip-style'))
                              {
                                span.setAttribute('style', nodeName1.getAttribute('lt-prop-tooltip-style'));
                                if(!span.style.borderColor)
                                    { 
                                        span.style.borderColor = span.style.backgroundColor;
                                    }
                              }
                          nodeName1.tooltip.classname = nodeName1.tagName + 'tooltip' + $L('span.lyteTooltip').e.length + nodeName1.tooltip.config.appearance + nodeName1.tooltip.config.position
                          span.classList.add(nodeName1.tooltip.classname);
                          document.body.appendChild(span);
                          nodeName1.tooltip.tooltipSpan = span;
                          span.nodeName1 = nodeName1;
                          if( toolclass ) {
                            var arr = toolclass.split(" ");
                            for( var i = 0; i < arr.length; i++ ) {
                                span.classList.add( arr[ i ] );
                            } 
                          }

                          nodeName1.tooltip.settime = setTimeout(this.createTooltip.bind(this), span.nodeName1.tooltip.config.showdelay,event, span,  span.nodeName1.tooltip.config.position == 'followcursor' ? true : false);
                          span.innerText = span.nodeName1.tooltip.title; 
                      } 
                    else if(nodeName1.tooltip.config.position == 'followcursor' && this.prevTooltipNode == nodeName1 && nodeName1.tooltip.tooltipSpan)
                      {
                          var span = nodeName1.tooltip.tooltipSpan;
                          clearTimeout(span.nodeName1.tooltip.maxdisp);
                          clearTimeout(span.nodeName1.tooltip.settime);
                          if(!span._callbackHandled){
                            span.nodeName1.tooltip.settime = setTimeout(this.createTooltip.bind(this), span.nodeName1.tooltip.config.showdelay,event, span, true);
                          } else {
                            this.followcursor.call(this, event, span)
                          }
                      }
                   else if(nodeName1.tooltip.tooltipSpan && nodeName1.tooltip.tooltipSpan.style.display == 'none')
                      {
                          nodeName1.tooltip.tooltipSpan.style.display = '';
                          clearTimeout(nodeName1.tooltip.maxdisp);
                          clearTimeout(nodeName1.tooltip.settime);
                          clearTimeout(nodeName1.tooltip.bodyTimeout);
                          nodeName1.tooltip.settime = setTimeout(this.createTooltip.bind(this), nodeName1.tooltip.config.showdelay,event, nodeName1.tooltip.tooltipSpan, nodeName1.tooltip.config.position == 'followcursor' ? true : false);
                      }   
                   else
                      {
                          this.prevTooltipNode = nodeName1;
                      } 
                   this.closeAllTooltip.call(this, nodeName1)    
                   break;       
                }
              else {
                nodeName1 = nodeName1.parentElement;
              }  
        }
      if(nodeName1 && nodeName1.tagName == 'BODY' && this.prevTooltipNode != nodeName1)
          {
              delete this.prevTooltipNode;
              this.closeAllTooltip.call(this)
          } 

  }

});

if(document.readyState == "complete" || document.readyState == "interactive"){
  if(!$L('lyte-tooltip').e.length){
        document.body.appendChild(document.createElement('lyte-tooltip'));
  }
}else{
  document.addEventListener('DOMContentLoaded',function(event){
    if(!$L('lyte-tooltip').e.length){
        document.body.appendChild(document.createElement('lyte-tooltip'));
  }
});
}
;

Lyte.Component.register("lyte-tree", {
_template:"<template tag-name=\"lyte-tree\">  <template is=\"for\" items=\"{{ltPropData}}\" item=\"item\" index=\"index\">    <lyte-tree-body data-value=\"{{lyteUiTreeHelp(tempVar, index)}}\">      <div class=\"mainContainer\">      <lyte-yield collapsed=\"{{if(item.collapsed, 'collapsed', '')}}\" yield-name=\"content\" list-value=\"{{item}}\" list-index=\"{{lyteUiTreeHelp(tempVar, index)}}\" class=\"{{lyteUiTreeChildHelp(item, 'noChildTree')}}\"></lyte-yield>        <template is=\"if\" value=\"{{expHandlers(expHandlers(expHandlers(item.children.length,'!==',0),'&amp;&amp;',expHandlers(item.children,'!==',undefined)),'&amp;&amp;',expHandlers(item.collapsed,'!'))}}\"><template case=\"true\">          <lyte-tree temp-var=\"{{lyteUiTreeHelp(tempVar, index)}}\" lt-prop-data=\"{{item.children}}\" id=\"{{ltPropId}}\" lt-prop-tree-lines=\"{{ltPropTreeLines}}\" lt-prop-yield=\"{{ltPropYield}}\" lt-prop-open-class=\"{{ltPropOpenClass}}\" lt-prop-close-class=\"{{ltPropCloseClass}}\" on-toggle=\"{{method('onToggle')}}\">            <template is=\"registerYield\" yield-name=\"content\" from-parent=\"\">             </template>          </lyte-tree>       </template></template>      </div>    </lyte-tree-body>  </template></template>",
_dynamicNodes : [{"type":"attr","position":[1]},{"type":"for","position":[1],"dynamicNodes":[{"type":"attr","position":[1]},{"type":"attr","position":[1,1,1]},{"type":"insertYield","position":[1,1,1]},{"type":"attr","position":[1,1,3]},{"type":"if","position":[1,1,3],"cases":{"true":{"dynamicNodes":[{"type":"attr","position":[1]},{"type":"registerYield","position":[1,1],"dynamicNodes":[]},{"type":"componentDynamic","position":[1]}]}},"default":{}},{"type":"componentDynamic","position":[1]}]}],
_observedAttributes :["ltPropData","ltPropOpenClass","ltPropCloseClass","ltPropNochildClass","treeHeight","tempVar"],
	data : function(){
		return {
			'ltPropData' : Lyte.attr('array' , {
				'default'  : []
			}),
			'ltPropOpenClass' : Lyte.attr('string' , {
				'default'  : ''
			}),
			'ltPropCloseClass' : Lyte.attr('string' , {
				'default'  : ''
			}),
			'ltPropNochildClass' : Lyte.attr('string' , {
				'default'  : ''
			}),
			'treeHeight' :  Lyte.attr('number' , {
				'default'  : 0
			}),
			tempVar : Lyte.attr('string', { default : ''})

		}
	} ,



	methods : {
		onToggle : function(){

		}
	}
});

Lyte.createCustomElement("lyte-tree-icon" , {
	connectedCallback : function(){
		if(!this.hasAttribute('lyte-custom-icon')){
			this.innerHTML = '<i class="arrow up"></i>';
		}
	} ,
	constructor : function(){
		var res;
		var classComponent = this._contextSwitchInfo.node._callee.component;
		var lyteTreeIcon = this;
		if(classComponent.getData('ltPropOpenClass').length > 0){
			lyteTreeIcon.className = classComponent.getData('ltPropOpenClass');
		}
		this.addEventListener( 'click', function(evt) {
				evt.preventDefault();
				var element, btn;
				element = btn = this;
				var n=1;
				var flag = 1;
				while(n==1){
					element = element.parentElement;
					if((element !== null)&&(element !== undefined)){
						if(element.nodeName === "LYTE-TREE-BODY"){
						break;
						}
					}
				}
				// console.log(element);
				if(element.nodeName === "LYTE-TREE-BODY"){
					var treeCont = element.querySelector('lyte-tree');
					if(treeCont){
						function trans(){
							this.style.display = "none";
							btn.style.pointerEvents = "auto";
							this.removeEventListener('transitionend' , trans);
							lyteTreeIcon.className = classComponent.getData('ltPropCloseClass');
						}
						function heightTrans(){
							this.style.height = "auto";
							btn.style.pointerEvents = "auto";
							this.removeEventListener('transitionend' , heightTrans);
						}
						if(element !== null){
							this.style.pointerEvents = "none";
							lyteTreeIcon.className = classComponent.getData('ltPropCloseClass');
							var thisBtn = treeCont.component;
							var display = window.getComputedStyle(treeCont).display;
							if(display === "none"){
								treeCont.style.display = "block";
								lyteTreeIcon.className = classComponent.getData('ltPropOpenClass');
								treeCont.addEventListener('transitionend' , heightTrans);
								setTimeout(function(){
									treeCont.style.height = thisBtn.getData('treeHeight') + "px";
									if(!this.hasAttribute('lyte-custom-icon')){
										btn.innerHTML = '<i class="arrow up"></i>';
									}
								}.bind(this), 20)
							} else {
								thisBtn.setData('treeHeight' , treeCont.getBoundingClientRect().height);
								treeCont.style.height = thisBtn.getData('treeHeight') + "px";
								treeCont.addEventListener('transitionend' , trans);
								setTimeout(function(){
									treeCont.style.height = "0px";
									if(!this.hasAttribute('lyte-custom-icon')){
										btn.innerHTML = '<i class="arrow down"></i>';
									}
								}.bind(this), 20)
							}
						}
					}
				}

				var clickedBtn = element.parentElement,retVal = true;
				if(clickedBtn && clickedBtn.component.getMethods('onToggle'))
							{
								res =	clickedBtn.component.executeMethod('onToggle', element, evt, clickedBtn);
							}
							// console.log( element, evt, clickedBtn);
						if(res !== undefined){
							if( res && res.then ) {
							Promise.resolve( res ).then( function( arg ) {
								var treeDt = clickedBtn.component.getData('ltPropData');
								var path = element.getAttribute('data-value').split("");
								if(path.length<2){
									var pathIndex = path[0];
									var x = treeDt[pathIndex];
									Lyte.objectUtils(x, 'add', 'collapsed', false);
								} else {
									var x = treeDt;
									for(var pathIndex = 1;pathIndex<path.length;pathIndex++){
										var x = treeDt[path[pathIndex]];
									}
									Lyte.objectUtils(x, 'add', 'collapsed', false)
								}
							}, function() {

							} );
						}	else {
							if(res){
								var treeDt = clickedBtn.component.getData('ltPropData');
								var path = element.getAttribute('data-value').split("");
								if(path.length<2){
									var pathIndex = path[0];
									var x = treeDt[pathIndex];
									Lyte.objectUtils(x, 'add', 'collapsed', false);
								} else {
									var x = treeDt;
									for(var pathIndex = 1;pathIndex<path.length;pathIndex++){
										var x = treeDt[path[pathIndex]];
									}
									Lyte.objectUtils(x, 'add', 'collapsed', false)
								}
							}
						}
					} else {
						var treeDt = clickedBtn.component.getData('ltPropData');
						var path = element.getAttribute('data-value').split("");
						if(path.length<2){
							var pathIndex = path[0];
							var x = treeDt[pathIndex];
							if(x !== undefined){
								Lyte.objectUtils(x, 'add', 'collapsed', false);
							}
						} else {
							var x = treeDt;
							for(var pathIndex = 1;pathIndex<path.length;pathIndex++){
								var x = treeDt[path[pathIndex]];
							}
							Lyte.objectUtils(x, 'add', 'collapsed', false)
						}
					}
		}.bind(this));
	},
	static : {
		 "observedAttributes" : {

		}
	}
});

Lyte.Component.register("lyte-wormhole",{
_template:"<template tag-name=\"lyte-wormhole\">\t<lyte-yield yield-name=\"lyte-content\"></lyte-yield>\t</template>",
_dynamicNodes : [{"type":"insertYield","position":[1]}],

	didConnect :function(){
		if(!this.appended){
			this.appended = true;
			this.throwEvent("wormholeDidConnect");
		}	
	}
});

/*
	Optimized by reading the values first and then writting
	Added - 27/07/2014 - documentation not done yet
		1. Added draggable + sortable compatibility - Drag any draggable element to sort it with a list of sortable elements and sort it with them
		2. Added helper options - can be string or any function
		3. Added connectToSortable options
		4. Added onBeforeStop callback - return false to exit
	Date - 28/08/2018
  	1. Added method to destroy draggable.

*/

(function( window ) {

	if($L){	
		manageDraggable = {
			init : false,
			isRestricted : function(restrict,element){
				restrict = restrict instanceof Array ? restrict : restrict.split(",");
				for(var i = 0; i<restrict.length; i++){
					var elements = document.querySelectorAll(restrict[i]);
					for(var j = 0; j < elements.length; j++){
						if(element.isEqualNode(elements[i])){
							return true;
						}
					}
				}
				return false;
			},

			destroy : function(element){
				if(element._draggableData){
					element._draggableData = null;
				}
				element.classList.remove('draggable-element');
			}

		};
		
		$L.prototype.draggable = function(object) {

			if(!manageDraggable.init){
				if (!Element.prototype.matches) {
				    Element.prototype.matches = 
				        Element.prototype.matchesSelector || 
				        Element.prototype.mozMatchesSelector ||
				        Element.prototype.msMatchesSelector || 
				        Element.prototype.oMatchesSelector || 
				        Element.prototype.webkitMatchesSelector ||
				        function(s) {
				            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
				                i = matches.length - 1;
				            while (i >= 0 && matches.item(i) !== this){
				            	--i;
				            	//gets the index of the matched item
				            }
				            return i > -1;            
				        };
				}
				manageDraggable.init = true;
			}

			if(typeof object === "string" && object === "destroy"){
				if(this.e.length){
					var elemArray = this.e;
					for(var i = 0; i<elemArray.length; i++){
						manageDraggable.destroy(elemArray[i]);
					}
				}
				else{
					manageDraggable.destroy(this.e);
				}
				return;
			}

			var data = object ? object : {};

			if(this.e.length){
				var elemArray = this.e;
				for(var i = 0; i<elemArray.length; i++){
					$L(elemArray[i]).draggable(Object.assign({},data));
				}
				return;
			}
			//Parent Element
			if(data.restrict && manageDraggable.isRestricted(data.restrict,this.e)){
				return;
			}
			data._element = this.e;
			$L(data._element).addClass('draggable-element');

			var _handleElement;
			var _initialPos = {};
			var _offset = [0,0];
			var _marginTop = 0;
			var _marginLeft = 0;
			var _mousePosition;
			var _placeholder;
			var _sortableElemClass;
			var _positionedPlceholder = false;
			var _requestId1;
			var _animationFrameFired1;
			var _elemBelow;
			var droppablePlace;
			var returnVal;
			var _mousePosition;
			var prevDimension = null;
			//Data initialization
			data.placeholder = data.placeholder ? data.placeholder : "lyteDraggablePlaceholder";
			data.containment = (data.containment === undefined) ? document : $L(data.containment).e;
			data.orientation = (data.orientation === undefined) ? "default" : data.orientation;
			data.handle = (data.handle === undefined) ? this.e : data.handle;
			data.restrict = data.restrict === undefined ? [] : data.restrict instanceof Array ? data.restrict : data.restrict.split(",");
			data.helper = data.helper ? data.helper : "original";
			data.connectToSortable = data.connectToSortable ? data.connectToSortable : null;
			data.cursorAt = data.cursorAt;
			data.disabled = data.disabled ? data.disabled : "lyteDraggableDisabledPlaceholder";
			

			

			function mouseDownEvent(event){
				// event.preventDefault();
				// console.log("calling mousedown from draggable");
				//Disable right click on the sortable elements to avoid unwanted behaviour
				if(event.which == 3){
					return;
				}
				var _handleElement = event.target.closest('.draggable-handle-element');
				if(_handleElement){
					var data = _handleElement._draggableData;
					var elem = data._element;
					var elemOffset = elem.getBoundingClientRect();
					var cs = window.getComputedStyle(elem);
					var width = elemOffset.width;
					var height = elemOffset.height;
					data._offParent = elem.offsetParent;
					data._parent = elem.parentElement;

					//Callback fired
					if(data.onStart){
						onStart(data);
					}

					_initialPos = {
						x : elem.offsetLeft,
						y : elem.offsetTop,
						pos : $L(elem).css('position')
					};
					if(event.type == "mousedown"){
						_offset = [
							event.clientX - elemOffset.left,
							event.clientY - elemOffset.top
						];
					}
					else if(event.type == "touchstart"){
						_offset = [
							event.touches[0].clientX - elemOffset.left,
							event.touches[0].clientY - elemOffset.top
						];

						//Binding touch events
						// $L(elem).bind("touchmove",data.__mousemove);
						// $L(elem).bind("touchend",data.__mouseup);
						elem.addEventListener('touchmove',data.__mousemove);
						elem.addEventListener('touchend',data.__mouseup);
					}
					
					if(cs.marginTop){
						_marginTop = cs.marginTop;
					}
					if(cs.marginLeft){
						_marginLeft = cs.marginLeft;
					}
					// var parent = elem.offsetParent;

					data._isDown = true;
					data._initialPos = _initialPos;
					data._offset = _offset;
					data._marginLeft = _marginLeft;
					data._marginTop = _marginTop;
					$L(_handleElement).addClass('selected-element');
					
					//Set the current element for manager to manage draggables and droppables
					if(typeof managerDD !== "undefined"){
						managerDD._current = data._element;
					}

					// $L(data.containment).bind("mousemove",mouseMoveEvent);
					// $L(data.containment).bind("mouseup",mouseUpEvent);
					document.addEventListener('mousemove',mouseMoveEvent);
					document.addEventListener('mouseup',mouseUpEvent);
				}
				// console.log(event.target, "selected");
			}

			var mouseMoveEvent = function(event){
				// console.log("calling mousemove from draggable");
				var target = event.target;
				while(target){
					if($L(target).hasClass("selected-element")){
						_handleElement = target;
						break;
					}
					target = target.parentElement;
				}
				if(_handleElement){
					// console.log(event.target, "moving");
					var data = _handleElement._draggableData;
					if(data && data._isDown){
						event.preventDefault();
						var elem = data._element;
						_offset = data._offset;
						_marginLeft = data._marginLeft;
						_marginTop = data._marginTop;
						orientation = data.orientation;
						var parent = data._offParent;
						var elemOffset = elem.getBoundingClientRect();
						var parentOffset = parent.getBoundingClientRect();

						if(!data._isMoved){
							var cs = window.getComputedStyle(elem);
				            var borderDimensionY = ((cs.borderTop ? parseFloat(cs.borderTop) : 0) +
				                                     (cs.borderBottom ? parseFloat(cs.borderBottom) : 0));
				            var borderDimensionX = ((cs.borderLeft ? parseFloat(cs.borderLeft) : 0) +
				                                     (cs.borderRight ? parseFloat(cs.borderRight) : 0));
							if(typeof data.helper == "string"){
								if(data.helper == "clone"){
									var helper = elem.cloneNode(true);
									LyteComponent.insertAfter(elem,helper);
									$L(elem).removeClass('selected-element');
									if(!($L(helper).hasClass('draggable-handle-element'))){
										$L(helper).addClass('draggable-handle-element');
									}
									helper._draggableData = Object.assign({},data);
									data = helper._draggableData;
									data._element = data.handle = helper;
									_handleElement = helper;
									elem = helper;
									elem.addEventListener("mousedown",mouseDownEvent);
									if(data.connectToSortable){
										data._prevTop = event.clientY;
									}
								}
							}
							else{
								var helper = data.helper(elem);
								if(helper){
									$L(elem).removeClass('selected-element');
									if(!($L(helper).hasClass('draggable-handle-element'))){
										$L(helper).addClass('draggable-handle-element');
									}
									helper._draggableData = Object.assign({},data);
									data = helper._draggableData;
									data._element = data.handle = helper;
									_handleElement = helper;
									elem = helper;
									elem.addEventListener("mousedown",mouseDownEvent);
									if(data.connectToSortable){
										data._prevTop = event.clientY;
									}
								}
							}
							if(typeof managerDD != "undefined"){
								managerDD._current = elem;
							}

							data = elem._draggableData || _handleElement._draggableData;
							
							//Create placeholder and append it to the DOM
							if(data.connectToSortable){
								_placeholder = elem.cloneNode(true);
								$L(_placeholder).removeClass('selected-element');
								$L(_placeholder).html("");
								$L(_placeholder).attr('id','lyteDraggableDummy');
								$L(_placeholder).addClass('lyteDraggablePlaceholder');
								if(cs.boxSizing == "border-box"){
									$L(_placeholder).width(elemOffset.width);
									$L(_placeholder).height(elemOffset.height);
								}
								else{
									$L(_placeholder).width(elemOffset.width - borderDimensionX);
									$L(_placeholder).height(elemOffset.height - borderDimensionY);
								}
								_placeholder.style.padding = "0px";
							}
							elem.style.top = elemOffset.top - parentOffset.top /*- parseInt(cellSpacing)*/ - parseInt(_marginTop) + 'px';
							elem.style.left = elemOffset.left - parentOffset.left - parseInt(_marginLeft) + 'px';
							elem.style.zIndex = 200000;
							if(cs.boxSizing == "border-box"){
								elem.style.width = elemOffset.width /*- borderDimensionX */+'px';
								elem.style.height = elemOffset.height /*- borderDimensionY*/ +'px';
							}
							else{
								elem.style.width = elemOffset.width - borderDimensionX +'px';
								elem.style.height = elemOffset.height - borderDimensionY +'px';
							}
							elem.style.position = "absolute";
						}

						if(event.type == "mousemove"){
							_mousePosition = {
								x : event.clientX,
								y : event.clientY
							};
							data._mousePosition = _mousePosition;
						}
						else if(event.type == "touchmove"){
							data._mousePosition = {
								x : event.touches[0].clientX,
								y : event.touches[0].clientY
							};
						}

						//Callback fired
						if(data.onDrag){
							returnVal = onDrag(data,_handleElement);
						}
						if(returnVal){
							if(orientation === "vertical"){
								elem.style.top = data._mousePosition.y - data._offset[1] - parentOffset.top - parseInt(_marginTop) + 'px';
							}
							else if(orientation === "horizontal"){
								elem.style.left = data._mousePosition.x - data._offset[0] - parentOffset.left - parseInt(_marginLeft) + 'px';
							}
							else if(orientation === "default"){
								if(data.cursorAt){
									elem.style.left = data._mousePosition.x - (data.cursorAt.left ? data.cursorAt.left : _offset[0]) - parentOffset.left - parseInt(_marginLeft) + 'px';
									elem.style.top = data._mousePosition.y - (data.cursorAt.top ? data.cursorAt.top : _offset[1]) - parentOffset.top - parseInt(_marginTop) + 'px';
								}
								else{
									elem.style.left = data._mousePosition.x - _offset[0] - parentOffset.left - parseInt(_marginLeft) + 'px';
									elem.style.top = data._mousePosition.y - _offset[1] - parentOffset.top - parseInt(_marginTop) + 'px';
								}
								
								elemOffset = elem.getBoundingClientRect();
								if(data.connectToSortable){
									var sortableData = $L(data.connectToSortable).e.length ? $L(data.connectToSortable).e[0]._sortableData : $L(data.connectToSortable).e._sortableData;
									_sortableElemClass = sortableData.sortableElemClass;
									if(_positionedPlceholder){
										var scrollDiv = findScrollDiv(_placeholder);
										var scrollDivOffset = scrollDiv ? scrollDiv.getBoundingClientRect() : null;
										if(scrollDiv && (elemOffset.left <= scrollDivOffset.right) && (elemOffset.right >= scrollDivOffset.left)){
											_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,scrollDivOffset));
											_animationFrameFired1 = true;
										}
									}
									//Find the below element over which the sortable element is being dragged
									elem.style.display = "none";
									_elemBelow = document.elementFromPoint(_mousePosition.x,_mousePosition.y);
									elem.style.display = "";
									

									if(!_elemBelow){
										return;
									}

									//Find the closest sortable element to sort with
									droppablePlace = _elemBelow.closest('.'+_sortableElemClass);
									if(document.getElementById('lyteDraggableDummy')){
										document.getElementById('lyteDraggableDummy').style.display = "";
									}

									if(droppablePlace/* && checkDroppable(droppablePlace,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition)*/){
										
										if($L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,data) && checkForIntersect(_elemBelow,_mousePosition)){
											// $L(_elemBelow).append(_placeholder);
											LyteComponent.appendChild(_elemBelow,_placeholder);
										}
										else{
											if(elem.getBoundingClientRect().top < droppablePlace.getBoundingClientRect().top){
												LyteComponent.insertBefore(droppablePlace,_placeholder);
											}
											else if(elem.getBoundingClientRect().bottom > droppablePlace.getBoundingClientRect().bottom){
												LyteComponent.insertAfter(droppablePlace,_placeholder);
											}
										}
										_positionedPlceholder = true;
									}
									else if(_elemBelow && $L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,data) && checkForIntersect(_elemBelow,_mousePosition)){
										// $L(_elemBelow).append(_placeholder);
										LyteComponent.appendChild(_elemBelow,_placeholder);
										_positionedPlceholder = true;
									}
									else{
										if(_elemBelow.id != "lyteDraggableDummy"){
											// console.log("placeholder set to false");
											if(document.getElementById('lyteDraggableDummy')){
												document.getElementById('lyteDraggableDummy').style.display = "none";
											}
											_positionedPlceholder = false;
										}
									}

									if(_positionedPlceholder){
										if(!data.onPlaceholder || checkValidDroppable(data,_placeholder)){
											if($L(_placeholder).hasClass(data.disabled)){
												$L(_placeholder).removeClass(data.disabled);
											}
											$L(_placeholder).addClass(data.placeholder);
										}
										else{
											if($L(_placeholder).hasClass(data.placeholder)){
												$L(_placeholder).removeClass(data.placeholder);
											}
											$L(_placeholder).addClass(data.disabled);
										}
									}
									
									// else{
									// 	console.log("checkParentDroppable",checkParentDroppable(_elemBelow,data._parentElem,_sortableElem,data.connectedWith));
									// 	console.log("checkForIntersect",checkForIntersect(_elemBelow,_mousePosition));
									// 	console.log("came here",_elemBelow);
									// }
									data._placeholder = _placeholder;
									data._positionedPlceholder = _positionedPlceholder;
								}
							}
						}
						
						//Check for any droppable element and if present execute its drag function
						if(typeof managerDD !== "undefined"){
							managerDD._drag(event);
						}
						data._isMoved = true;
					}
				}
			}

			var mouseUpEvent = function(event){
				// console.log("calling mouseup from draggable");
				// event.preventDefault();
				// _handleElement = event.target.closest('.selected-element') ? event.target.closest('.selected-element') : document.querySelector('.selected-element');
				var target = event.target;
				_handleElement = null;
				while(target){
					if($L(target).hasClass("selected-element")){
						_handleElement = target;
						break;
					}
					target = target.parentElement;
				}
				if(_handleElement){
					var data = _handleElement._draggableData;
					document.removeEventListener('mousemove',mouseMoveEvent);
					document.removeEventListener('mouseup',mouseUpEvent);
					_placeholder = data._placeholder;
					if(data && data._isDown){
						data._isDown = false;
						var elem = data._element;
						if(data._isMoved){
							var placed = false;
							data._isMoved = false;
							_initialPos = data._initialPos;
							_marginTop = parseInt(data._marginTop);
							_marginLeft = parseInt(data._marginLeft);
							
							var returnVal = true;
							if(data.onBeforeStop){
								returnVal = onBeforeStop(data);
							}
							if(!returnVal){
								if(data.helper == "clone"){
									elem.remove();
									if(document.getElementById('lyteDraggableDummy')){
										_placeholder.remove();
									}
									return;
								}
								if(_initialPos.pos === "absolute"){
									elem.style.left = _initialPos.x + "px";
									elem.style.top = _initialPos.y + "px";
								}
								else{
									elem.style.left = "";
									elem.style.top = "";
									elem.style.position = "";
								}
							}
							else{
								if(data.connectToSortable && data._positionedPlceholder){
									var sibling = (findPreviousElem(_placeholder) ? findPreviousElem(_placeholder) : findNextElem(_placeholder));
									var elementData = sibling ? sibling._sortableData : _placeholder.parentElement._sortableData;
									// $L(_placeholder).replace(_div);
									LyteComponent.replaceWith(_placeholder, elem);
									
									_placeholder = null;
									elem._sortableData = elementData;
									elem.removeEventListener('mousedown',mouseDownEvent);
									removeStyle(elem);
									placed = true;
								}
							}
							
							//Check for any droppable element & if present execute its drop function
							if(typeof managerDD !== "undefined"){
								managerDD._drop(event);
								managerDD._current = null;
							}

							//Callback fired
							if(data.onStop){
								returnVal = onStop(data, event);
							}

							if(!returnVal){
								if(data.helper == "clone" && !placed){
									elem.remove();
									if(document.getElementById('lyteDraggableDummy')){
										_placeholder.remove();
									}
									return;
								}
								if(_initialPos.pos === "absolute"){
									elem.style.left = _initialPos.x + "px";
									elem.style.top = _initialPos.y + "px";
								}
								else{
									elem.style.left = "";
									elem.style.top = "";
									elem.style.position = "";
								}
							}

						}
						elem.style.zIndex = "";
						$L(_handleElement).removeClass('selected-element');

						//Unbinding touch events
						if(event.type == "touchend"){
							elem.removeEventListener('touchmove',data.__mousemove);
							elem.removeEventListener('touchend',data.__mouseup);
						}
					}
					_handleElement = null;
					if(document.getElementById('lyteDraggableDummy')){
						_placeholder.remove();
					}
				}
			}

			/*---------------Callbacks Start--------------*/
			var onReady = function(data){
				data.onReady(data._element);
			}

			var onStart = function(data){
				data.onStart(data._element);
				// return ( returnVal === undefined) ? true : returnVal;
			}

			var onDrag = function(data, _handleElement){
				returnVal = data.onDrag(data._element,_handleElement);
				return (returnVal == undefined) ? true : returnVal;
			}

			var onBeforeStop = function(data){
				returnVal = data.onBeforeStop(data._element,data._placeholder,data._positionedPlceholder ? data._placeholder.parentElement : null);
				return (returnVal == undefined) ? true : returnVal;
			}

			var checkValidDroppable = function(data,placeholder){
				var returnVal = data.onPlaceholder(data._element,placeholder, data._element.parentElement, placeholder ? placeholder.parentElement : null);
				return (returnVal == undefined) ? true : returnVal;
			}

			var onStop = function(data,event){
				data._element.style.display = "none";
				_elemBelow = document.elementFromPoint(event.clientX, event.clientY);
				data._element.style.display = "";
				returnVal = data.onStop(data._element, data._positionedPlceholder ? data._element.parentElement : null, _elemBelow);
				return (returnVal === undefined) ? true : returnVal;
			}
			/*---------------Callbacks End--------------*/

			
			//Bind events
			data.__mousemove = mouseMoveEvent;
			data.__mouseup = mouseUpEvent;
			if(typeof data.handle !== "string" && data.handle.length){
				data.handle.forEach(function(item){
					ele = $L(item).e;
					ele._draggableData = data;
					$L(ele).addClass('draggable-handle-element');
					$L(ele).e.addEventListener('mousedown',mouseDownEvent);
					$L(ele).e.addEventListener('touchstart',mouseDownEvent);
					// $L(ele).bind("mousedown",mouseDownEvent);
					// $L(ele).bind("touchstart",mouseDownEvent);
				});
			}
			else{
				data.handle._draggableData = data; 
				$L(data.handle).addClass('draggable-handle-element');
				$L(data.handle).e.addEventListener('mousedown',mouseDownEvent);
				$L(data.handle).e.addEventListener('touchstart',mouseDownEvent);
				// $L(data.handle).bind("mousedown",mouseDownEvent);
				// $L(data.handle).bind("touchstart",mouseDownEvent);
			}
			

			//Callback fired
			if(data.onReady){
				onReady(data);
			}

			var checkParentDroppable = function(_elemBelow,data){
				if(_elemBelow.matches(data.connectToSortable)){
					return true;
				}
				return false;
			}

			var calculateHeight = function(element) {
				var cs = getComputedStyle(element);

				var paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);

				var borderY = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);

				// Element height minus padding and border
				elementHeight = element.offsetHeight - paddingY - borderY;
				return elementHeight;
			};

			var calculateWidth = function(element) {
				var cs = getComputedStyle(element);

				var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);

				var borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);

				// Element width minus padding and border
				elementWidth = element.offsetWidth - paddingX - borderX;
				return elementWidth;
			};

			var callForScrollY = function(){
				var scrollDiv = arguments[1];
				var parentOffset = arguments[2];
				var divOffset = arguments[0]._element.getBoundingClientRect();
				var topNBottom = arguments[3];
				
				if((divOffset.top <= parentOffset.top) && (scrollDiv.scrollTop > 0)){
					scrollDiv.scrollTop -= 10;
				}
				else if((divOffset.bottom >= parentOffset.bottom) && (scrollDiv.scrollTop <= (scrollDiv.scrollHeight - parentOffset.height))){
					scrollDiv.scrollTop += 10;
				}
				else{
					cancelAnimationFrame(_requestId1);
					_animationFrameFired1 = false;
					_requestId1 = null;
					return;
				}
				_requestId1 = requestAnimationFrame(callForScrollY.bind(this,arguments[0],scrollDiv,parentOffset,topNBottom));
				
			};

			var checkForIntersect = function(parentElem,mP){
				var cs = window.getComputedStyle(parentElem);
				var offset = parentElem.getBoundingClientRect();
				// console.log("cs",cs);
				// console.log("offset",offset);
				// console.log("_mousePosition",mP.x,mP.y);
				if(mP.x > (offset.left + parseFloat(cs.paddingLeft || 0)) && mP.x < (offset.right - parseFloat(cs.paddingRight || 0)) && mP.y > (offset.top + parseFloat(cs.paddingTop || 0)) && mP.y < (offset.bottom - parseFloat(cs.paddingBottom || 0))){
					return true;
				}
				return false; 
			};

			var checkForBetween = function(parentElem,mP,div){
				var childrens = parentElem.children;
				var templateTags = 0;
				var childElem = [];
				for(var i = 0;i<childrens.length;i++){
					if(childrens[i].tagName != "TEMPLATE" && childrens[i].id != "dummy"){
						childElem.push(childrens[i]);
					}
					else{
						templateTags++;
					}
				}
				if(templateTags == childrens.length){
					return true;
				}
				// else if(childElem.length > 0 && childElem[childElem.length - 1].isEqualNode(div)){
				// 	return true;
				// }
				else if(div.getBoundingClientRect().top > childElem[childElem.length - 1].getBoundingClientRect().bottom){
					return true;
				}
				return false;
			};

			var findPreviousElem = function(elem){
				while(elem.previousElementSibling){
					elem = elem.previousElementSibling;
					if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
						return elem;
					}
				}
				return null;
			};

			var findNextElem = function(elem){
				while(elem.nextElementSibling){
					elem = elem.nextElementSibling;
					if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
						return elem;
					}
				}
				return null;
			};

			var removeStyle = function(elem){
				elem.style.left = "";
				elem.style.top = "";
				elem.style.zIndex = "";
				elem.style.position = "";
				$L(elem).addClass("sortable-element",elem._sortableData.sortableElemClass);
				elem.classList.remove('draggable-handle-element','draggable-element');
			};

			var findScrollDiv = function(elem){
				var parent = elem.parentElement;
				while(elem.parentElement){
					elem = elem.parentElement;
					if(parent.scrollHeight > elem.clientHeight && !(elem.style.overflow && elem.style.overflow == 'hidden')){
						return elem;
					}
				}
				return null;
			};

		}
	}

})( window );
/*
	Optimized by reading the values first and then writting
	Date - 28/08/2018
  	1. Added method to destroy droppable.
*/

(function( window ) {

	if($L){	

		//This object synchronizes the draggable elements with the droppable elements
		//It contains the current object which is being dragged in the _current attribute
		//It also contains all the droppables available in the page inside the _droppables array attribute
		managerDD = {
			init : false,
			_current : null,
			_droppables : [],
			_checkAcceptable : function(draggable,acceptables){
				if(typeof acceptables !== "string"){
					if(acceptables.length === 0){
						return true;
					}
					else{
						for(var i = 0 ; i < acceptables.length ;i++){
							if(draggable.matches(acceptables[i])){
								return true;
							}
							// var elements = $L(acceptables[i]).e;
							// if(elements.length){
							// 	for(var j = 0; j<elements.length; j++){
							// 		if(draggable.isEqualNode(elements[j])){
							// 			return true;
							// 		}
							// 	}
							// }
							// else{
							// 	if(elements && elements.length == undefined){
							// 		if(draggable.isEqualNode(elements)){
							// 			return true;
							// 		}
							// 	}
							// }
						}
					}
				}
				return false;
			},

			_isOverAxis : function( x, reference, size ) {
				return ( x >= reference ) && ( x < ( reference + size ) );
			},
			_checkIntersects : function(event,draggable,droppable,toleranceMode){
			
				var draggableOffset = draggable.getBoundingClientRect(),
					droppableOffset = droppable.getBoundingClientRect(),
					x1 = draggableOffset.left,
					y1 = draggableOffset.top,
					x2 = x1 + draggableOffset.width,
					y2 = y1 + draggableOffset.height,
					l = droppableOffset.left,
					t = droppableOffset.top,
					r = l + droppableOffset.width,
					b = t + droppableOffset.height;

				//If draggable and droppable elements are not from same window -
				//Calculate from their dimensions w.r.t top level window.
				if(draggable.ownerDocument.defaultView != droppable.ownerDocument.defaultView){
					//For draggable
					var currentWin = draggable.ownerDocument.defaultView || draggable.ownerDocument.parentWindow;
					while(currentWin.frameElement){
						var frameElementOffset = currentWin.frameElement.getBoundingClientRect();
						x1 = x1 + frameElementOffset.left;
						x2 = x2 + frameElementOffset.left;
						y1 = y1 + frameElementOffset.top;
						y2 = y2 + frameElementOffset.top;
						currentWin = currentWin.parent;
					}
					//For droppable
					currentWin = droppable.ownerDocument.defaultView || droppable.ownerDocument.parentWindow;
					while(currentWin.frameElement){
						var frameElementOffset = currentWin.frameElement.getBoundingClientRect();
						l = l + frameElementOffset.left;
						r = r + frameElementOffset.left;
						t = t + frameElementOffset.top;
						b = b + frameElementOffset.top;
						currentWin = currentWin.parent;
					}
				}

				switch ( toleranceMode ) {
				case "fit":
					return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
				case "intersect":
					return ( l < x1 + ( draggableOffset.width / 2 ) && // Right Half
						x2 - ( draggableOffset.width / 2 ) < r && // Left Half
						t < y1 + ( draggableOffset.height / 2 ) && // Bottom Half
						y2 - ( draggableOffset.height / 2 ) < b ); // Top Half
				case "pointer":
					if(event.type == "mousemove"){
						return managerDD._isOverAxis( event.clientY, t, droppableOffset.height ) &&
						managerDD._isOverAxis( event.clientX, l, droppableOffset.width );
					}
					if(event.type == "touchmove"){
						return managerDD._isOverAxis( event.touches[0].clientY, t, droppableOffset.height ) &&
						managerDD._isOverAxis( event.touches[0].clientX, l, droppableOffset.width );
					}
				case "touch":
					return (
						( y1 >= t && y1 <= b ) || // Top edge touching
						( y2 >= t && y2 <= b ) || // Bottom edge touching
						( y1 < t && y2 > b ) // Surrounded vertically
					) && (
						( x1 >= l && x1 <= r ) || // Left edge touching
						( x2 >= l && x2 <= r ) || // Right edge touching
						( x1 < l && x2 > r ) // Surrounded horizontally
					);
				default:
					return false;
				}
			},
			_drag : function(event){
				
				var droppables = this._droppables;
				var draggable = this._current;
				for(var i=0; i< droppables.length ; i++){
					
					var data = droppables[i]._droppableData;

					//Checks if the droppable is disabled or not
					//Also checks whether the draggable can be accepted by the droppable
					//And the draggable and droppable are not same element
					if(!data.disabled && !(draggable.isEqualNode(droppables[i])) && managerDD._checkAcceptable(draggable,data.accept)){

						//Checks if the draggable intersects the droppable
						if(managerDD._checkIntersects(event,draggable,droppables[i],data.tolerance)){
							if(!data.entered && data.onEnter){
								data.onEnter(draggable,droppables[i]);
							}
							if(data.onDrag){
								data.onDrag(draggable,droppables[i]);
							}
							if(data.hoverClass && !$L(droppables[i]).hasClass(data.hoverClass)){
								if(data.activeClass && $L(droppables[i]).hasClass(data.activeClass)){
									$L(droppables[i]).removeClass(data.activeClass);
								}
								$L(droppables[i]).addClass(data.hoverClass)
							}
							if(!data.entered){
								data.entered = true;
							}
						}
						else{
							if(data.entered && data.onLeave){
								data.onLeave(draggable,droppables[i]);
							}
							if(data.hoverClass && $L(droppables[i]).hasClass(data.hoverClass)){
								$L(droppables[i]).removeClass(data.hoverClass);
							}
							if(data.activeClass && !$L(droppables[i]).hasClass(data.activeClass)){
								$L(droppables[i]).addClass(data.activeClass);
							}
							if(data.entered){
								data.entered = false;
							}
						}
					}
				}
			},
			_drop : function(event){
				var droppables = this._droppables;
				var draggable = this._current;
				for(var i=0; i< droppables.length ; i++){
					if(!(draggable.isEqualNode(droppables[i]))){
						var data = droppables[i]._droppableData;
						if(data.activeClass && $L(droppables[i]).hasClass(data.activeClass)){
							$L(droppables[i]).removeClass(data.activeClass);
						}
						if(data.hoverClass && $L(droppables[i]).hasClass(data.hoverClass)){
							$L(droppables[i]).removeClass(data.hoverClass);
						}
						if(!data.disabled && managerDD._checkAcceptable(draggable,data.accept)){
							if(managerDD._checkIntersects(event,draggable,droppables[i],data.tolerance)){
								if(data.onDrop){
									data.onDrop(draggable,droppables[i]);
								}
								break;
							}
						}
					}
				}
			},
			isRestricted : function(restrict,element){
				restrict = restrict instanceof Array ? restrict : restrict.split(",");
				for(var i = 0; i<restrict.length; i++){
					var elements = document.querySelectorAll(restrict[i]);
					for(var j = 0; j < elements.length; j++){
						if(element.isEqualNode(elements[i])){
							return true;
						}
					}
				}
				return false;
			},

			destroy : function(element){
				if(managerDD._droppables.indexOf(element) !== -1){
					managerDD._droppables.splice(managerDD._droppables.indexOf(element),1);
				}
				if (element._droppableData) {
					element._droppableData = null;
				}
				element.classList.remove('droppable-element');
			},

			sortDroppables : function(){
				var droppables = this._droppables,
				lastItem = droppables[droppables.length - 1],
				lastItemOffset = lastItem.getBoundingClientRect();
				for(var i = 0; i < droppables.length - 1; i++){
					var elemOffset = droppables[i].getBoundingClientRect();
					if(lastItemOffset.height < elemOffset.height && lastItemOffset.width < elemOffset.width){
						droppables.splice(droppables.indexOf(lastItem),1);
						droppables.splice(i,0,lastItem);
						return;
					}
				}
			}
		},


		//It initializes the droppable funcionality and stores it in the managerDD._droppables array 
		$L.prototype.droppable = function(object) {

			if(!managerDD.init){
				if (!Element.prototype.matches) {
				    Element.prototype.matches = 
				        Element.prototype.matchesSelector || 
				        Element.prototype.mozMatchesSelector ||
				        Element.prototype.msMatchesSelector || 
				        Element.prototype.oMatchesSelector || 
				        Element.prototype.webkitMatchesSelector ||
				        function(s) {
				            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
				                i = matches.length - 1;
				            while (i >= 0 && matches.item(i) !== this){
				            	--i;
				            	//gets the index of the matched item
				            }
				            return i > -1;            
				        };
				}
				managerDD.init = true;
			}

			if(typeof object === "string" && object === "destroy"){
				if(this.e.length){
					var elemArray = this.e;
					for(var i=0; i<elemArray.length; i++){
						managerDD.destroy(elemArray[i]);
					}
				}
				else{
					managerDD.destroy(this.e);
				}
				return;
			}

			var data = object ? object : {};

			if(this.e.length){
				var elemArray = this.e;
				for(var i = 0; i<elemArray.length; i++){
					$L(elemArray[i]).droppable(Object.assign({},data));
				}
				return;
			}

			if(data.restrict && managerDD.isRestricted(data.restrict, this.e)){
				return;
			}

			//Parent Element
			data._element = droppableEle = this.e;
			$L(data._element).addClass('droppable-element');
			data.entered = false;
			data.activeClass = data.activeClass ? data.activeClass : false; 
			data.accept = data.accept ? data.accept : [];
			data.disabled = (data.disabled === true) ? data.disabled : false;
			data.hoverClass = data.hoverClass ? data.hoverClass : false;
			data.tolerance = (data.tolerance === "fit" || data.tolerance === "intersect" || data.tolerance === "pointer" || data.tolerance === "touch") ? data.tolerance : "intersect";
			data.registerToParent = data.registerToParent;
			data.getDroppables
			droppableEle._droppableData = data;

			if(managerDD._droppables.indexOf(droppableEle) == -1){
				// managerDD._droppables.splice(managerDD._droppables.indexOf(droppableEle),1);
				managerDD._droppables.push(droppableEle);
				if(managerDD._droppables.length > 1 && data.sortDroppables){
					managerDD.sortDroppables();
				}
			}
			

			//Incase of nested iframes if user wants the droppables to be available to the parent window context
			if(data.registerToParent){
				var currentWin = window;
				while(currentWin.parent){
					currentWin = currentWin.parent;
					currentWin.managerDD._droppables.push(droppableEle);
					if(currentWin.managerDD._droppables.length > 1 && droppableEle._droppableData.sortDroppables){
						currentWin.managerDD.sortDroppables();
					}
					if(currentWin.parent == currentWin.top){
						break;
					}
				}
			}

			//Incase the user wants all the droppables fro its parent
			if(data.registerFromParent){
				var currentWin = window;
				var parentWindow = window;
				while(parentWindow.parent){
					parentWindow = parentWindow.parent;
					var droppables = parentWindow.managerDD._droppables;
					for(var i = 0; i<droppables.length ; i++){
						if(currentWin.managerDD._droppables.indexOf(droppables[i]) == -1){
							currentWin.managerDD._droppables.push(droppables[i]);
							if(currentWin.managerDD._droppables.length > 1 && droppableEle._droppableData.sortDroppables){
								currentWin.managerDD.sortDroppables();
							}
						}
					}
					if(parentWindow.parent == parentWindow.top){
						break;
					}
				}
			} 

			droppableEle = null;
			if(data.onReady){
				data.onReady(this.e);
			}

			
		}

	}

})( window );
(function(){

	if($L) {

		function returnElem(element){
			return $L('.lyteScrollBar', element).e[0];
		}

		function returnCorrectParent( element, checkList ){
			var elementChild = element.children;
			for( var i = 0; i < checkList.length; i++ ) {
				if( Array.prototype.indexOf.call( elementChild, checkList[ i ] ) != -1){
					return checkList[ i ]
				}
			}
		}

		function makeVisisble( divv, flag, event ){
			if( !divv ){
				return
			}
			event = event || {}
			if( flag ) {
				if( ( event.type != 'mouseenter' && event.type != 'resize' ) || this.parentElement._scrollData.showOn != 'scroll' ){
					divv.style.visibility = 'visible'
					divv.classList.add( 'visible' )
					setScrollPos(divv);
				}
				return true
			} else{
				divv.style.visibility = 'hidden'
				divv.classList.remove( 'visible' )
			}
			
		}

		function mousemove1( evt ){
			event.preventDefault()
			if( this._happened ){
				return
			}
			this._happened = true
			setTimeout( function(){
				if( !this.classList.contains( 'eventBinded' ) ) {
					mouseenter.call( this )
				}
				// this.removeEventListener( 'mousemove', mousemove1, true )
				this.removeEventListener( 'wheel', mousemove1, true )
				delete this._happened;
			}.bind( this ), 20)
		}

		function mouseenter(event){
         	this.parentElement.style.position = 'relative';
			var element = this;
			event = event || {}
			if( this._mouseleaveTimeout ){
				return
			}
			this._mouseenterTimeout = setTimeout( function(){
				delete this._mouseenterTimeout
				// dimensions and scroll levels of the element are calculated for enabling scrollbars
				element._direction = window.getComputedStyle(this).direction;
        		var clientRect = element.getBoundingClientRect(), flag = false;
        		var scrollWidth1 = element.scrollWidth;
        		var scrollHeight1 = element.scrollHeight;
        		flag = makeVisisble.call( this, returnCorrectParent( this.parentElement, $L('.lyteScrollContainer.lyteScrollContainerX', this.parentElement).e ), (scrollWidth1 - Math.round(parseInt(clientRect.width.toFixed(0)))) > 10, event )
        		flag = makeVisisble.call( this, returnCorrectParent( this.parentElement, $L('.lyteScrollContainer.lyteScrollContainerY', this.parentElement ).e ), (scrollHeight1 - Math.round(parseInt(clientRect.height.toFixed(0)))) > 10 || this._infiniteScroll, event )	|| flag
		        if(flag){
		        	element.addEventListener('wheel', wheelEvent);
		        	element.classList.add( 'eventBinded' )
		        	element.addEventListener('keydown', keydownFunc);
		        	element._tabindex = element.tabIndex;
		        	if(element.tabIndex == -1){
		        		element.tabIndex = 0;
		        	}
		        }
		        if( ( event.type != 'mouseenter' && event.type != 'resize' ) && this.parentElement._scrollData.showOn == 'scroll' ) {
		        	// setTimeout( function(){
		        		this._enableScroll = true
		        	// }.bind( this ), 16)
		        }
			}.bind( this ), event.constructor == Boolean ? 0 : 16 )
				
       }

       function  mouseleave(event){
	        	var element = returnElem(this);
       			clearTimeout( element._mouseenterTimeout );delete element._mouseenterTimeout;		
	        	event = event || {}
	        	if(event && event.type == 'mouseleave')
	        		{
	        			if(element.contains(event.relatedTarget)){
	        				return;
	        			}
	        		}
	        	if( event.timeout && document._scrollmousedown ) {
	        		return
	        	}	
        		if(( event.flag == undefined && !document._scrollmousedown ) || ( document._scrollmousedown && event.flag == false  ) || ( event.flag && this._scrollData.showOn == 'scroll' ) )	
	        		{
	        			clearTimeout( element._mouseleaveTimeout )
	        			element._mouseleaveTimeout = setTimeout( function(){
		        			var bars = $L( '.lyteScrollContainer', this );
		        			if( bars.e.length )
		        				{
		        					bars.css('visibility','hidden');
		        					bars.removeClass( 'visible' )
		        					if( event.flag == undefined || ( !event.flag && this._scrollData.showOn == 'scroll' ) || this._scrollData.showOn != 'scroll' ){
		        						element.removeEventListener('wheel', wheelEvent);
		        						element.removeEventListener('keydown', keydownFunc);
		        						element.classList.remove( 'eventBinded' )
		        						element.tabIndex = element._tabindex;
		        						delete element._tabindex;
		        					}
		        					delete element._enableScroll;delete element._scrollTimeout;
		        				}
		        			delete element._mouseleaveTimeout;	
		        		}.bind( this, event ), 100)	
	        		}
	     }

	     function infiniteWheel (event){
	     		var fact = 1;
	     		var a = event.deltaX;
			    var b = event.deltaY;
			    if( this.parentElement._scrollData.showOn == 'scroll' ){
			    	if( !this._enableScroll ){
			    		mouseenter.call( this )
			    		return
			    	}
			    	clearTimeout( this._scrollTimeout )	
			    	this._scrollTimeout = setTimeout(mouseleave.bind( this.parentElement ), 500, { flag : true, timeout : true } )
			    }
			    // clientRect need to be taken for positioning
				var divClientRect = this.getBoundingClientRect();
				var direction = this._direction;
				var factor = 1;
				this._scrollFlag = true
				if((navigator.userAgent.toLowerCase().indexOf('edge') != -1 && direction == 'rtl') || ((navigator.userAgent.toLowerCase().indexOf('trident') != -1 || navigator.userAgent.toLowerCase().indexOf('msie') != -1) && direction == 'rtl'))
					{
						factor = -1;
					}
				var scrollWid = this.scrollWidth, scrollHgt = this.scrollHeight, scrollLeft = this.scrollLeft, scrollTop = this.scrollTop;	
				if((divClientRect.height + scrollTop >= scrollHgt && b > 0) && this._scrollEnd /*&& (divClientRect.width + scrollLeft >= scrollWid)*/ && !this._infiniteScroll){
					delete this._scrollFlag
					return;
				}
				this.scrollLeft = parseInt(this.scrollLeft) + a * factor;
				if(this._infiniteScroll){
					if(b < 0){
						b = Math.abs(b) > 20 ? -20 : b;
					}else{
						b = b > 20 ? 20 : b;
					}
				}else{
					if(b < 0){
						b = Math.abs(b) > 100 ? -100 : b;
					}else{
						b = b > 100 ? 100 : b;
					}
				}
				this.scrollTop = parseInt(this.scrollTop) + (b);
				this._scrollLeft = this.scrollLeft;
				this._scrollTop = this.scrollTop;
				var scrollbars = $L('.lyteScrollContainer.visible', this.parentElement).e;
				var newScrollWid = scrollWid - scrollLeft + this.scrollLeft;
				var newScrollHgt = scrollHgt - scrollTop + this.scrollTop;
				this._scrollWidth = newScrollWid;
				this._scrollHeight = newScrollHgt;
				for(var i = 0; i < scrollbars.length; i++)
					{
						if( scrollbars[ i ].parentElement == this.parentElement ){
							setScrollPos(scrollbars[i]);
						}
					}		
				triggerScroll(a * factor, b, this)
	     }

	     function wheelEvent(event){
	     	if( this.classList.contains( 'lyteTableScroll' ) ) {
	     		var thead = $L( 'lyte-thead', this ).e[ 0 ];
	     		if( thead ) {
	     			var el = event.target;
	     			while( el != this ) {
	     				if( el.classList.contains( 'preventWheel' ) ) {
	     					break;
	     				}
	     				el = el.parentElement
	     			}
	     			if( el.classList.contains( 'preventWheel' ) ){
	     				return
	     			}
	     		}
	     	}
	     	if(this._infiniteScroll && (event.deltaY < 0 || !this._preventScroll) && !this._allow){
	     		clearTimeout(this._timeId)
		     	this._timeId = setTimeout(infiniteWheel.bind(this), 10, event)
	     	}else if(!this._infiniteScroll){
	     		setTimeout(infiniteWheel.bind(this), 16, event)
	     	}
	     	event.preventDefault();
		}

		function keydownFunc(evt){
			var keyCode = evt.keyCode, clientRect = this.getBoundingClientRect();
			if([37, 38, 39, 40].indexOf(keyCode) != -1){
				var step = this.parentElement._scrollData.keyStep, pos, x, y;
				if(keyCode == 37){
					this.scrollLeft -= step;
					x = -step; y = 0;
					pos = 'X';
				}else if(keyCode == 38){
					y = -step; x = 0;
					this.scrollTop -= step;
					pos = 'Y';
				}else if(keyCode == 39){
					x = step; y = 0;
					this.scrollLeft += step;
					pos = 'X';
				}else{
					y = step; x = 0;
					this.scrollTop += step;
					pos = 'Y';
				}
				setScrollPos( returnCorrectParent( this.parentElement, $L('.lyteScrollContainer.lyteScrollContainer'+ pos, this.parentElement).e ) )
				if(pos == 'Y'){
					if(!(this.scrollTop == 0 || parseInt(this.scrollTop + clientRect.height) >= this.scrollHeight - 2)){
						evt.preventDefault();
					}
				}else{
					if(!(this.scrollLeft == 0 || parseInt(this.scrollLeft + clientRect.width) >= this.scrollWidth - 2)){
						evt.preventDefault();
					}
				}
				triggerScroll(x, y, this);
			}
		}


		 function triggerScroll(a, b, comp){
		 	// $L.fastdom.measure( function(){
		 		var evt = new Event('scroll', {bubbles : true}), flag = true;
		 		// wheel event continuosly applied after reaching scroll end (it requires for table with infinite scroll so some basic needs are calculated same will be used in table column fixing)
		 		evt.scrollLeft = comp.scrollLeft; evt.scrollTop = comp.scrollTop; evt.scrollWidth = comp.scrollWidth, evt.scrollHeight = comp.scrollHeight, bccr = comp.getBoundingClientRect();
		 		if(evt.scrollLeft == comp._prevScrollLeft && evt.scrollTop == comp._prevScrollTop){
		 			if(!comp._infiniteScroll){
		 				if(!comp._scrollEnd){
		 					comp._scrollEnd = true;
		 				}else{
		 					flag = false;
		 				}
		 			}
		 			evt.scrollEnd = true;
		 		}else{
		 			if(comp._scrollEnd){
		 					delete comp._scrollEnd;
		 				}
		 		}
		 		if(!flag){
		 			return;
		 		}
		 		comp._prevScrollLeft = evt.scrollLeft; comp._prevScrollTop = evt.scrollTop;
		    	evt.xScroll = a;
		    	evt.yScroll = b;
		    	evt.flag = true
		    	if( evt.scrollLeft && evt.scrollLeft + bccr.width >= evt.scrollWidth ){
		    		evt.horiScrollEnd = true
		    	}
		    	if( evt.scrollTop && evt.scrollTop + bccr.height >= evt.scrollHeight ){
		    		evt.vertScrollEnd = true
		    	}
		    	if(flag){
		    		evt._byPlugin = true
		    		comp.dispatchEvent(evt);
		    	}
		    	clearTimeout( comp._timeout )
		    	comp._timeout = setTimeout( function(){
		    		delete comp._scrollFlag; delete comp._timeout
		    	}, 100 )
		    	
		 	// }.bind( this ) )
	    } 

	   function setScrollPos(outerDiv){
	    	var element = returnElem(outerDiv.parentElement), fact = 1;
			var scrollBar = $L('.lyteScrollDiv', outerDiv).e[0];
			var scrollHeight = 'scrollHeight', scrollTop = 'scrollTop', scrollLeft = 'scrollLeft', height = 'height',top1 = 'top', left = 'bottom', offsetHeight = 'clientHeight';
			var scrollHeight1, scrollTop1, height1, rect, offsetWidth, scrollWidth;
			$L.fastdom.measure(function(){
				var compStyleElem = element.getBoundingClientRect();
				if(scrollBar._direction)
					{
						var direction = element._direction;
						if(direction == 'rtl')
							{	
								fact = -1;
							}
						scrollHeight = 'scrollWidth', scrollTop = 'scrollLeft', scrollLeft = 'scrollTop', height = 'width',top1 = 'left', left = 'right', offsetHeight = 'clientWidth';
					}
				// element dimesions are measured here	
				rect = parseInt(compStyleElem[height])				
				scrollHeight1 = element[scrollHeight];
				scrollTop1 = Math.abs(element[scrollTop]);
				offsetWidth = compStyleElem.offsetWidth;
				scrollWidth = element.scrollWidth;
				height1 = rect - Math.round(parseInt(window.getComputedStyle(outerDiv).getPropertyValue(top1)));
				$L.fastdom.mutate(function(){
					// setting scroll bar height / width  && top / left depending upon scrolling
					scrollBar.style[height] = (rect / scrollHeight1 * 100) + '%';
					if(navigator.userAgent.toLowerCase().indexOf('chrome') != -1 && fact == -1)
						{
							scrollBar.style[top1] = -((scrollWidth - rect - scrollTop1)/scrollHeight1 * 100) + '%';
						}
					else if(fact == -1)
						{
							scrollBar.style[top1] = -(scrollTop1/scrollHeight1 * 100) + '%';
						}	
					else	
						{
							scrollBar.style[top1] = (scrollTop1/scrollHeight1 * height1) + 'px';
						}
				}.bind(this))
			}.bind(this))
	    }

	    function scrollFunc( evt ){
	    	if( this._scrollFlag || evt._byPlugin ) {
	    		return
	    	}
	    	clearTimeout( this._contTimeout )
	    	this._contTimeout = setTimeout( function(){
	    		mouseenter.call( this, true )
	    		delete this._contTimeout;
	    	}.bind( this ) , 10 )
	    }

		$L.prototype.removeScroll = function(){
			var elements = []
			if(this.e.length == undefined){
			 		elements.push(this.e);
			 }else{
		 		for(var i = 0; i < this.e.length; i++){
		 			elements.push(this.e[i])
		 		}
			}
			for(var j = 0; j < elements.length; j++){
				var wrapp = elements[j].parentElement;
				if(wrapp._scrollData){
					elements[j].removeEventListener('mouseenter', mouseenter);
					wrapp.removeEventListener('mouseleave', mouseleave);
					elements[j].removeEventListener('scroll', scrollFunc, true);
					var scrollDivs = $L('div.lyteScrollContainer', wrapp).e;
					for(var k = 0; k < scrollDivs.length; k++){
						if( scrollDivs[k].parentElement == wrapp ) {
							wrapp.removeChild(scrollDivs[k]);
						}
					}
					returnElem(wrapp).classList.remove('lyteScrollBar');
					delete wrapp._scrollData; delete elements[ j ]._scrollTimeout;
					delete elements[ j ].resetScrollbar;delete elements[ j ]._scrollFlag;
				}
			}
			elements = undefined;
		}

		$L.prototype.scroll = function(obj){
			obj = obj == undefined ? {} : obj;
			obj.keyStep = obj.keyStep ? obj.keyStep : 30;
			obj.showOn = obj.showOn ? obj.showOn : 'hover';
			var elements = []

			function appendSpan(className, element, wrapperDiv){
	        	var outerDiv = document.createElement('div');
				outerDiv.classList.add('lyteScrollContainer');
				if(obj.containerClass)
					{
						outerDiv.classList.add(obj.containerClass);
					}
				outerDiv.style.visibility = 'hidden'
				var innerDiv = document.createElement('div');
				innerDiv.classList.add('lyteScrollDiv');
				if(obj.handlerClass)
					{
						innerDiv.classList.add(obj.handlerClass);
					}
				outerDiv.appendChild(innerDiv);
				outerDiv.classList.add(className);
				if(className == 'lyteScrollContainerX')
					{
						innerDiv._direction = true;
						if(obj.horizontalContainerClass)
							{	
								outerDiv.classList.add(obj.horizontalContainerClass);
							}
						if(obj.horizontalHandlerClass)
							{
								innerDiv.classList.add(obj.horizontalHandlerClass);
							}	
					}
				else
					{
						if(obj.verticalContainerClass)
							{	
								outerDiv.classList.add(obj.verticalContainerClass);
							}
						if(obj.verticalHandlerClass)
							{
								innerDiv.classList.add(obj.verticalHandlerClass);
							}
					}
				wrapperDiv.appendChild(outerDiv);
				outerDiv.addEventListener('click', outerDivClick);
				innerDiv.addEventListener('mousedown', innerDivClick);
				outerDiv._wrapper = wrapperDiv;
				return outerDiv;
	        }

	        function outerDivClick(event){
				var parent = returnElem(this.parentElement);
				var child = this.children[0]; parent._scrollFlag = true
				if(!child.dontAllow)
					{
						$L.fastdom.measure(function(){
							var childBound = child.getBoundingClientRect(), val, thisBound = this.getBoundingClientRect(), parentBound = parent.getBoundingClientRect(), iniS = parent.scrollLeft, iniT = parent.scrollTop;
							var hgt = 'width', top1 = 'left', scrollTop = 'scrollLeft', scrollHeight = 'scrollWidth', maxScroll = 'maxScrollWidth', bottom = 'right', clientY = 'clientX';
							if(!child._direction){
								hgt = 'height', top1 = 'top', scrollTop = 'scrollTop', scrollHeight = 'scrollHeight', maxScroll = 'maxScrollHeight', bottom = 'bottom', clientY = 'clientY';
							}
							var prevHgt = parseInt(child.style[top1]), newHgt = Math.max( event[clientY] - thisBound[top1] - childBound[hgt] / 2, 0 );
							prevHgt = prevHgt == NaN ? 0 : prevHgt;
							$L.fastdom.mutate(function(){
								child.style[top1] = (newHgt) + 'px';
								if((childBound[bottom] -prevHgt + newHgt) > thisBound[bottom])
									{
										newHgt = thisBound[hgt] - childBound[hgt];
										child.style[top1] = newHgt + 'px';
									}
								val =  thisBound[ top1 ] + parseInt( child.style[ top1 ] )
								prevHgt = newHgt - prevHgt;	
								 if(parseInt(parent[scrollTop]) <= parseInt((parent[scrollHeight] - parentBound[hgt]).toFixed(0)))
									{
										parent[scrollTop] = parent[ scrollHeight ] * ( val - thisBound[ top1 ] ) / parentBound[ hgt ] - ( ( navigator.userAgent.toLowerCase().indexOf('chrome') == -1 && parent._direction == 'rtl' && this.classList.contains( 'lyteScrollContainerX' ) ) ? ( parent.scrollWidth - parentBound.width )  : 0 ) ;
									} 
								$L.fastdom.measure(function(){
									setScrollPos( this );
									setTimeout( triggerScroll, 16 , parent.scrollLeft - iniS, parent.scrollTop - iniT, parent )
								}.bind( this ))	
							}.bind( this ))
						}.bind( this ))
					}
				delete child.dontAllow;
			}

			function innerDivClick(event){
				if( !this.parentElement.classList.contains( 'visible' ) ){
					return
				}
				document.scrollMousemove = mousemove.bind(this);
				document._scrollPlugin = this;
				document.addEventListener('mousemove', document.scrollMousemove);
				document.addEventListener('mouseup', mouseup, true);
				var parent =  returnElem(this.parentElement.parentElement);
				var wrapperDiv = this.parentElement._wrapper;
				if(this._direction)
					{
						this._offsetLeft = this.offsetLeft;
						this._offLeft = event.clientX;
						this._prev = event.clientX;
						this.maxScrollWidth = parent.scrollWidth;
						this._iniScrollLeft = parent.scrollLeft;
						wrapperDiv.classList.add('lyteScrollingX');
					}
				else
					{
						this._offsetTop = this.offsetTop;
						this._offTop = event.clientY;
						this._prev = event.clientY;
						this.maxScrollHeight = parent.scrollHeight;
						this._iniScrollTop = parent.scrollTop;
						wrapperDiv.classList.add('lyteScrollingY');
					}
				event.preventDefault();
				event.stopPropagation();
				document._scrollmousedown = true;	
			}

			function mouseup(event){
				document.removeEventListener('mousemove', document.scrollMousemove);
				document._scrollPlugin.dontAllow = true;
				var comp = document._scrollPlugin.parentElement._wrapper;
				comp.classList.remove('lyteScrollingX');
				comp.classList.remove('lyteScrollingY');
				document.removeEventListener('mouseup', mouseup, true);
				event.preventDefault();
				event.stopPropagation();
				event.stopImmediatePropagation();
				if( comp._scrollData.showOn != 'always' ){
					mouseleave.call(comp, { flag : comp.contains( event.target ) });
				}
				var el = document._scrollPlugin;	
				delete el._offsetLeft; delete el._prev; delete el._offLeft; delete el._offTop; delete el._offsetTop; delete el.maxScrollWidth; delete el.maxScrollHeight; delete el._iniScrollTop; delete el._iniScrollLeft;	
				delete document._scrollmousedown;
				delete document._scrollPlugin;
				delete document.scrollMousemove;	

			}

			function mousemove(event){
				var parent = returnElem(this.parentElement.parentElement), scrollLevel1, scrollLevel2, newTop = 0;
				var hgt = 'width', top1 = 'left', scrollTop = 'scrollLeft', scrollHeight = 'scrollWidth', maxScroll = 'maxScrollWidth', topToSet, oldTop;
				var compStyle = parent._direction, thisParent = this.parentElement.getBoundingClientRect(), parentClientRect = parent.getBoundingClientRect(), clientRect = this.getBoundingClientRect();
				if(!this._direction){
					hgt = 'height', fact = 1, top1 = 'top', scrollTop = 'scrollTop', scrollHeight = 'scrollHeight', maxScroll = 'maxScrollHeight';
				}
				if(this._direction)
					{
						topToSet, oldTop = parseInt(this.style.left);
						oldTop = isNaN(oldTop) ? 0 : oldTop;
						scrollLevel1 = event.clientX - this._offLeft;
						if(navigator.userAgent.toLowerCase().indexOf('chrome') != -1 && compStyle == 'rtl')
							{
								if(parent.scrollLeft > 0 && parseInt(parent.scrollWidth - parentClientRect.width) > parent.scrollLeft)
									{
										topToSet = -(-clientRect.right + thisParent.right - scrollLevel1);
										this.style.left = topToSet + 'px';
									}else{
										topToSet = oldTop;
									}
								this._offLeft = event.clientX;	
							}
						else
							{
								topToSet = /*clientRect.left - thisParent.left*/ this._offsetLeft + scrollLevel1;	
								this.style.left = topToSet + 'px';
								scrollLevel1 = event.clientX - this._prev;
								this._prev = event.clientX	
							}						
					}
				else	
					{
						scrollLevel2 = event.clientY - this._offTop;
						// this._offTop = event.clientY;
						topToSet = /*clientRect.top - thisParent.top*/ this._offsetTop + scrollLevel2, oldTop = parseInt(this.style.top);
						oldTop = isNaN(oldTop) ? 0 : oldTop;
						scrollLevel2 = event.clientY - this._prev;
						this._prev = event.clientY
						this.style.top = topToSet + 'px';
					}
				 newTop = topToSet - oldTop;		
				 if(parseInt(parent[scrollTop]) <= parseInt(this[maxScroll] - parentClientRect[hgt]) || (scrollLevel1 == -1 && scrollLevel1 != undefined) || (scrollLevel2 == -1 && scrollLevel2 != undefined))
					{
						if(compStyle == 'rtl' && this.parentElement.classList.contains('lyteScrollContainerX'))
							{
								parent.scrollLeft += (scrollLevel1 = scrollLevel1 ? scrollLevel1 : 0);
							}
						else	
							{
								parent[scrollTop] = parent[scrollHeight] * (clientRect[top1] + newTop - thisParent[top1])/thisParent[hgt]
							}
					} 
				setScrollPos(this.parentElement);
				triggerScroll(scrollLevel1, scrollLevel2, parent);
				event.preventDefault();
				event.stopPropagation();
			}


			if(this.e.length == undefined){
			 		elements.push(this.e);
			 }else{
			 		for(var i = 0; i < this.e.length; i++)
			 			{
			 				elements.push(this.e[i])
			 			}
			}
			for(var j = 0; j < elements.length; j++)
				{
						var wrapperDiv = elements[j].parentElement, outerDiv, outerDiv1;
						wrapperDiv.style.position = 'relative';
						if(wrapperDiv._scrollData){
							$L(elements[j]).removeScroll();
						}
						elements[ j ].resetScrollbar = mouseenter.bind( elements[ j ] );
						wrapperDiv._scrollData = obj;
						if(!obj.preventVertical){
								outerDiv = appendSpan('lyteScrollContainerY', elements[j], wrapperDiv);
								if(obj.verticalPosition == 'left'){
										outerDiv.classList.add('left');
									}
							}
						if(!obj.preventHorizontal){
								outerDiv1 = appendSpan('lyteScrollContainerX', elements[j], wrapperDiv);
								if(obj.horizontalPosition == 'top'){
										outerDiv1.classList.add('top');
									}
							}
						elements[j].addEventListener('scroll', scrollFunc, true);
						elements[j].addEventListener('mouseenter', mouseenter);
						// elements[j].addEventListener('mousemove', mousemove1, true);
						elements[j].addEventListener('wheel', mousemove1, true);
						elements[j].classList.add('lyteScrollBar');
						if(navigator.userAgent.toLowerCase().indexOf('firefox') != -1){
								elements[j].scrollLeft = 0;
								elements[j].scrollTop = 0;
						  }	
						if( obj.showOn == 'hover' || obj.showOn == 'scroll' ) {
							wrapperDiv.addEventListener('mouseleave', mouseleave);
							$L.fastdom.mutate( mouseleave.bind(wrapperDiv) )  
						} else if( obj.showOn == 'always' ) {
							mouseenter.call( elements[j] )
						}
						outerDiv = undefined; outerDiv1 = undefined;
			   }
			elements = undefined;   
		}
	}

})();
(function(){
    if($L){
        $L.prototype.search = function(data){
            data = data ? data : {};
            if(!data.scope)
                {
                    console.error('scope is not given');
                    return;
                }
            var scope = typeof data.scope == 'string' ? ((/^#/g.test(data.scope.trim()) && !/\s/g.test(data.scope.trim()))? $L(data.scope).e : $L(data.scope).e[0]) : data.scope, timeout;    
            var element = this.e.length == undefined ? this.e : this.e[0];
            var searchList = [], targetList = [], searchComp = [];
            element._searchPluginData = data;

            element.setValue = function(value){
                element = this
                value = value != undefined ? value : '';
                element.tagName == 'LYTE-INPUT' ? element.ltProp({'value' : value}) : element.value = value;
                var evt = new Event('keyup');
                evt.keyCode = 8;
                element.dispatchEvent(evt);
            }

            var arrayFrom = function(nodeList){
              var arrayList = [];
              for(var i = 0; i < nodeList.length; i++)
                {
                  arrayList.push(nodeList[i]);
                }
              return arrayList.slice(); 
             };

            var pressFunc = function(event){
                var element = this
                var data = this._searchPluginData;
                var ret = findingList.call(this,event); 
                var searchList = ret[0]; 
                var targetList = ret[1];
                var searchComp = ret[2]; 
                var minLength = data.minLength ? data.minLength : 0;
                var method = data.method ? data.method : 'contains';
                var val = (element.tagName == 'LYTE-INPUT' ? $L('input', element).e[0].value : element.value);
                var visibleList = [], flag; 
                if(val.length >= minLength || event.keyCode == 8)
                  { 
                    if(val.length)
                        {
                          for(var i = 0; i < searchList.length; i++)
                             {
                               switch(method)
                                  {
                                    case 'contains' : {
                                        if(searchList[i].trim().toLowerCase().indexOf(val.toLowerCase()) >= 0)
                                            {
                                                visibleList.push(searchComp[i]);
                                            }
                                        break;    
                                     }
                                     case 'startsWith' : {
                                          if(searchList[i].trim().toLowerCase().startsWith(val.toLowerCase()))
                                              {
                                                visibleList.push(searchComp[i]);
                                             }
                                          break;
                                     }
                                     case 'endsWith' : {
                                          if(searchList[i].trim().toLowerCase().endsWith(val.toLowerCase()))
                                              {
                                                  visibleList.push(searchComp[i]);
                                             }
                                          break;
                                     }
                                  }   
                              }
                        }
                     else
                        {
                          visibleList = searchComp;
                        }   
                    if(data.hasOwnProperty('onSearch'))
                        {
                          flag = data.onSearch(visibleList);
                        }
                    if(flag != false)     
                         {
                             for(var i = 0; i < searchList.length; i++)
                                 {  
                                    switch(method)
                                      {
                                        case 'contains' : {
                                            if(searchList[i].trim().toLowerCase().indexOf(val.toLowerCase()) < 0)
                                                {
                                                   targetList[i].classList.add('lyteSearchHidden')
                                                }
                                              else
                                                {
                                                   targetList[i].classList.remove('lyteSearchHidden')
                                                }  
                                            break;    
                                         }
                                         case 'startsWith' : {
                                              if(!searchList[i].trim().toLowerCase().startsWith(val.toLowerCase()))
                                                  {
                                                      targetList[i].classList.add('lyteSearchHidden')
                                                   }
                                                 else
                                                  {
                                                     targetList[i].classList.remove('lyteSearchHidden')
                                                  }  
                                              break;
                                         }
                                         case 'endsWith' : {
                                              if(!searchList[i].trim().toLowerCase().endsWith(val.toLowerCase()))
                                                  {
                                                      targetList[i].classList.add('lyteSearchHidden')
                                                  }
                                                else
                                                   {
                                                      targetList[i].classList.remove('lyteSearchHidden')
                                                   }  
                                              break;
                                         }
                                      }      
                                 }  
                        }    
                }                 
            };

        var searchListFind = function(nodeName){
              var searchList = [];
              var target = [];
              for(var i = 0; i < nodeName.childElementCount; i++)
                {
                  while(nodeName.children[i].childElementCount)
                     {
                        returnedVal = searchListFind(nodeName.children[i]);
                        searchList = searchList.concat(returnedVal[0]);
                        target = target.concat(returnedVal[1]);
                        break;
                     }
                  if(!nodeName.children[i].childElementCount) 
                      {
                        searchList.push(nodeName.children[i].textContent);
                        target.push(nodeName.children[i]);
                      }
                }
              return [searchList,target];
         };

      var findingList = function(){
            var data = this._searchPluginData;
            var scope = typeof data.scope == 'string' ? document.querySelector(data.scope) : data.scope;
            var searchList = [], targetList = [], searchComp = [];
            if(data.search)   
                {
                    (/^#/g.test(data.search.trim()) && !/\s/g.test(data.search.trim())) ? searchComp.push($L(data.search, scope).e) : searchComp = searchComp.concat(arrayFrom($L(data.search, scope).e));
                    var target = data.target ? data.target : data.search;
                    for(var j = 0; j < searchComp.length; j++){
                        searchList.push(searchComp[j].textContent)
                    }
                    (/^#/g.test(target.trim()) && !/\s/g.test(target.trim())) ? targetList.push($L(target, scope).e) : targetList = targetList.concat(arrayFrom($L(target, scope).e));
                }
            else
                {
                    var callSearchList = searchListFind(scope)
                    searchList = callSearchList[0];
                    targetList = callSearchList[1];
                    searchComp = targetList.slice();
                } 
              return [searchList, targetList, searchComp];  
          };

        element.addEventListener('keyup', function(event){
                       if([37,13,38,39,40,91,27,16,18].indexOf(event.keyCode) > -1){ 
                        return
                      }
                      var element = this;
                      var data = element._searchPluginData;
                      clearTimeout(timeout);
                      timeout = setTimeout(function(){ 
                         pressFunc.call(this,event);
                       }.bind(this),100)
                    });           

        }

    }
})();

/**
 * Keyboards Supported
 * 1. US keyboard
 */
 /**
 Issues
 block it for mobiles
 ctrl+functional keys test it
 */
/**
 * Intializes the shortcut library
 * @param {object} window - window object
 * @param {document} document - document object
 */
(function(window,document){

	// Private Variables

	var _registeredKeys = {};
	var _timeoutID;
	var _currentPressed = []
	var _allPressed = []
	var _allPressedWithModifier = []
	var _currentPointer = {}
	var _funcId
	var _clickId
	var _specialKeys = {
		8 : 'backspace',
        9 : 'tab',
        13 : 'enter',
        16 : 'shift',
        17 : 'ctrl',
        18 : 'alt',
        20 : 'capslock',
        27 : 'esc',
		32 : 'space',
		33 : 'pageup',
		34 : 'pagedown',
		35 : 'end',
		36 : 'home',
		37 : 'left',
        38 : 'up',
        39 : 'right',
        40 : 'down',
        45 : 'insert',
		46 : 'delete',
		91 : 'meta',
		92 : 'meta', // windows key
		93 : 'meta',
		224 : 'meta'
	}

	var _otherSpecialKeys = {
		48 : ')',
		49 : '!',
		50 : '@',
		51 : '#',
		52 : '$',
		53 : '%',
		54 : '^',
		55 : '&',
		56 : '*',
		57 : '(',
		187 : 'plus',
		188 : '<',
		190 : '>',
		191 : '?',
		192 : '~',
		219 : '{',
		220 : '|',
		221 : '}',
		222 : '"'
	}

	/* English Languate/US Layout */
	var _conversionUS = {
		'_' : '-',
		'plus' : '=',
		'{' : '[',
		'}' : ']',
		'|' : '\\',
		':' : ';',
		'"' : '\'',
		'<' : ',',
		'>' : '.',
		'?' : '/',
		'~' : '`',
		'!' : '1',
		'@' : '2',
		'#' : '3',
		'$' : '4',
		'%' : '5',
		'^' : '6',
		'&' : '7',
		'*' : '8',
		'(' : '9',
		')' : '0'
	}

	
	// Private Methods

	/**
	 * Checks if the current key is a modifier
	 * @param {string} string - The string which contains the currently processed key
	 */

	function _checkIfModifier(string){
		string = string.toLowerCase()
		return string === "ctrl" || string === "command" || string === "alt" || string === "shift"
	}


	/**
	 * Checks if the character is a function key
	 * @param {string} character - The character that should be checked
	 */


	function _checkIfFunctionKey(character){
		for(var i = 1;i <= 12;i++){
			if(character.toLowerCase() === ('f' + i)){
				return true
			}
		}
		return false
	}


	/**
	 * Checks if the key is one of the modified keys by comparing it with the globally defined map
	 * @param {string} key - The key that should be checked for
	 */


	function _checkIfModifiedKey(key){
		if(_conversionUS[key]){
			return true
		}
		return false
	}

	/**
	 * Split keys in modifiers and normal keys
	 * @param {string} keys - The keys registered to shortcut
	 */

	function _preprocess(keys){
		var array = _getProperArray(keys)
		var modifier = []
		for(var i = 0;i < array.length;i++){
			if(_checkIfModifier(array[i])){
				array[i] = array[i] === 'command'?'meta':array[i]
				if(keys.indexOf('+') != -1){
					modifier.push(array[i])
					array.splice(i,1)
					i--;
				}
			}
			else if(_checkIfFunctionKey(array[i])){
				array[i] = array[i].toLowerCase()
			}
			else if(_checkIfModifiedKey(array[i])){
				if(keys.indexOf('+') != -1){
					modifier.push('shift')
					array[i] = _conversionUS[array[i]]
				}
			}
		}
		var modifierFlag
		if(keys.indexOf('+') !== -1){
			array = array.join('+')
			modifierFlag = true
		}
		else{
			array = array.join(' ')
			modifierFlag = false
		}
		return {
			modifier : modifier,
			newKey : array,
			modifierFlag : modifierFlag
		}
	}

	/**
	 * Split keys and build an array
	 * @param {string} keys - split between spaces or plus
	 */

	function _getProperArray(keys){
		if(keys.indexOf('+') !== -1){
			return keys.split('+')
		}
		else{
			return keys.split(' ')
		}
	}

	/**
	 * Increase character pointer of all the registered keys if the match
	 * @param {string} character - currently pressed character
	 */

	function _increaseCharPointer(character){
		for(var keys in _registeredKeys){
				if(keys.indexOf('r:') !== -1){
					var exp = keys.substring(2)
					var matches = exp.match(new RegExp('^/(.*?)/([gimy]*)$'))
					var regex = new RegExp(matches[1],matches[2])
					if(regex.test(_allPressed.join(''))){
						_currentPointer[keys] = 1
						continue;
					}
					else{
						_currentPointer[keys] = 0
					}
				}
				var key = _getProperArray(keys)
				var progress
				_currentPointer[keys] = progress =  _currentPointer[keys]?_currentPointer[keys]:0
				var withoutMod = _conversionUS[key[progress]]
				if(withoutMod && character === 'shift'){

					continue
				}
				else if(_conversionUS[character] && _conversionUS[character] === key[progress]){
					var items = _registeredKeys[keys]
					var incFlag = false

					for(var i=0;i<items.length;i++){
						if(items[i].modifierFlag && items[i].modifier.indexOf('shift') !== -1){
							_currentPointer[keys]++;

							incFlag = true
							break;
						}
					}
					if(incFlag){
						continue;
					}
				}
				if(key[progress] === character){
					_currentPointer[keys]++;
				}
				else{
					_currentPointer[keys] = 0
				}
			//}
		}
	}

	

	/**
	 * Calls a the matched element which should be invoked.
	 * @param {function} func - The callback that must be invoked
	 * @param {number} wait - A wait period where a user can press a different key to invoke a different element
	 * @param {object} event - The current keydown event
	 */

	function _invokeFunction(func,wait,event,invokedKey){
		
		if(wait){
			_flushTimeout()
			_funcId = setTimeout(function(){
				var prevent
				prevent = func.call(window,event,invokedKey)
				prevent = prevent === false?prevent:true
				if(!prevent){
					event.preventDefault()
				}
				_currentPointer = {}
				_allPressed = []
				_allPressedWithModifier = []
			},wait)
		}
		else{
			_flushTimeout()
			var prevent = func.call(window,event,invokedKey)
			prevent = prevent === false?prevent:true
			if(!prevent){
				event.preventDefault()
			}
			_currentPointer = {}
			_allPressed = []
			_allPressedWithModifier = []
		}
	}

	function _isVisible(element){
		var tagName = element.tagName
		var parent = element;
		switch(tagName){
			case 'LYTE-BUTTON':
			case 'LYTE-ACCORDION-ITEM':
			case 'LYTE-NAV-ITEM':
				return !!( element.offsetWidth || element.offsetHeight || element.getClientRects().length );
				break;
			case 'LYTE-MENU-ITEM':
				while(parent.tagName !== 'LYTE-MENU-BODY'){
					parent = parent.parentElement
				}
				var menu = parent.parent
				var query = menu.ltProp('query')
				var all = document.querySelectorAll(query)
				for(var i=0;i<all.length;i++){
					var isVisible = !!( all[i].offsetWidth || all[i].offsetHeight || all[i].getClientRects().length );
					if(isVisible){
						return true
					}
				}
				return false

		}
	}

	/**
	 * Triggers a click event on the element that is matched
	 * @param {HTMLElement} element - The HTMLElement that should be clicked
	 * @param {number} wait - A wait period where a user can press a different key to invoke a different element
	 */


	function _invokeClick(element,wait){
		element = element.tagName === 'LYTE-BUTTON'? element.querySelector('button'):element;
		var isVisible = _isVisible(element)
		if(!isVisible){
			return ;
		}
		if(wait){
			_flushTimeout()
			_clickId = setTimeout(function(){
				element.click()
				_currentPointer = {}
				_allPressed = []
				_allPressedWithModifier = []
			},wait)
		}
		else{
			_flushTimeout()
			element.click()
			_currentPointer = {}
			_allPressed = []
			_allPressedWithModifier = []
		}
	}

	/**
	 * Clears the timeout in both the invoke functions
	 */

	function _flushTimeout(){
		clearTimeout(_funcId)
		clearTimeout(_clickId)
	}

	/**
	 * Callbacks/elements that need to be invoked/clicked
	 * @param {array} matchedElements - all the keys that have matched the current sequence of characters
	 */

	function _invokeMatchedElements(matchedElements,event){
		for(var i=0;i<matchedElements.length;i++){
			var type = matchedElements[i].type
			var value = matchedElements[i].value
			var wait = matchedElements[i].wait
			var invokedKey = matchedElements[i]._invokedKey
			if(typeof value === 'function'){
				_invokeFunction(value,wait,event,invokedKey)
			}
			else{
				_invokeClick(value,wait)
			}
		}
	}

	/**
	 * get all the modifiers that are currently pressed
	 * @param {object} event - the keydown event
	 */

	function _getModifiers(event){
		var modifier = []
		if(event.altKey){
			modifier.push('alt')
		}
		if(event.ctrlKey){
			modifier.push('ctrl')
		}
		if(event.shiftKey){
			modifier.push('shift')
		}
		if(event.metaKey){
			modifier.push('meta')
		}
		return modifier
	}

	/**
	 * get all the matching elements for the current sequence
	 * @param {object} event - the keydown event
	 */

	function _getMatchedElements(event){
		var allValues = []
		var allModifier = _getModifiers(event)
		// _invokedKey writes in the global object but it won't cause problems i guess
		for(var keys in _currentPointer){
			if(keys.indexOf('r:') !== -1 && _currentPointer[keys] > 0){
				var item = _registeredKeys[keys]
				item._invokedKey = keys
				allValues.push(item)
				continue
			}
			for(var i = 0;i < _registeredKeys[keys].length;i++){
				var item = _registeredKeys[keys][i]
				if(item.modifierFlag &&	_currentPointer[keys] ===  _getProperArray(keys).length && item.modifier.sort().join(' ') === allModifier.sort().join(' ')){
					item._invokedKey = item.modifier.sort().length !== 0? item.modifier.sort().join('+') + "+" + keys:keys
					allValues.push(item)
					_currentPointer[keys] = 0
				}
				else if(!item.modifierFlag && _currentPointer[keys] ===  _getProperArray(keys).length && _allPressedWithModifier.length === _getProperArray(keys).length){
					item._invokedKey = keys
					allValues.push(item)
					_currentPointer[keys] = 0
				}
			}
		}
		return allValues
	}

	/**
	 * Returns character from event
	 * @param {object} event - the keydown event
	 */

	function _getKeyFromKeyCode(event){
		var code = event.which
		if(_specialKeys[code]){
			return _specialKeys[code]
		}
		else if(_otherSpecialKeys[code]){
			if(event.shiftKey){
				return _otherSpecialKeys[code]
			}
			return _conversionUS[_otherSpecialKeys[code]]
		}
		return String.fromCharCode(code).toLowerCase()
	}


	// A timeout that refreshes the current pressed keys when no more keys are pressed


	function _createGracePeriod(){
		 clearTimeout(_timeoutID)
		_timeoutID = setTimeout(function(){
			_currentPointer = {}
			_allPressed = []
			_allPressedWithModifier = []
		},1000)
	}


	// Checks if the active element is a input/select/textarea

	function _checkActiveElement(){
		var activeElement = document.activeElement
		var tagName = activeElement.tagName
		var inputTypesAllowed = ['checkbox','radio','file','color','range']
		if(
			( 
				(
					tagName === 'INPUT' && inputTypesAllowed.indexOf(activeElement.type) === -1
				) 
				||
					activeElement.getAttribute('contenteditable') === "true"
				||
					tagName === 'SELECT' 
				|| 
					tagName === 'TEXTAREA'
			) 
			&& 
				!activeElement.classList.contains('lyte-shortcut')
			) {
			return true;
		}
		return false
	}

	/**
	 * The callback for the keydown event
	 * @param {object} event - the keydown event
	 */

	function _handleKeyPress(event){
		var shouldReject = _checkActiveElement();
		if(shouldReject){
			return ;
		}
		var character = _getKeyFromKeyCode(event)
		if(!_specialKeys[event.which]){
			_allPressed.push(character)
			_allPressedWithModifier.push(character)
		}
		else {
			_allPressedWithModifier.push(_specialKeys[event.which])
		}
		_increaseCharPointer(character)
		var matchedElements = _getMatchedElements(event)
		_createGracePeriod()
		if(matchedElements.length){
			_invokeMatchedElements(matchedElements,event)
		}
	}

	/**
	 * Builds the registered keys from array
	 * @param {array} keys - Array of keys
	 * @param {function} callback - Function to be invoked for the keys
	 */

	function _processObject(keys,callback,options){
		for(var i = 0;i < keys.length;i++){
			var key = keys[i]
			_processString(key,callback,options)
		}
	}

	/**
	 * Builds the registered key from the string
	 * @param {string} keys - String that represents the key
	 * @param {function} callback - Function to be invoked for the key
	 */

	function _processString(keys,callback,options){
		shortcut.push({
			newKey:keys,
			oldKey:undefined,
			value:callback,
			options:options
		})
	}

	/**
	 * strips white spaces
	 * @param {string} key - The key for which white spaces need to be removed
	 */

	function _stripSpaces(key){
		key = key.replace(/\s+/i,' ');
		return key;
	}


	/**
	 * Adds the regex expression to the registeredKeys
	 * @param {string} key - The regular expresssion
	 * @param {function/HTMLElement} callback - The function or the HTMLElement that should be invoked
	 * @param {object} options - Configuarion for this particular key
	 */


	function _pushRegex(keys,callback,options){
		keys = 'r:' + keys
		var wait = options.wait? options.wait:0
		var type = typeof callback 
		_registeredKeys[keys] = {
			type : type,
			value : callback,
			wait : wait
		}
	}
	

	/**
	 * registers function keys and solves other cross browser issues
	 */


	function _registerOtherKeys(){
		for(var i = 0;i <= 9;i++){
			_specialKeys[i + 96] = i.toString()
		}
		for(var i = 1;i <= 12;i++){
			_specialKeys[111 + i] = 'f' + i
		}
		var sniff = navigator.userAgent
		if(sniff.match('Firefox')){
			_otherSpecialKeys[59] = ':'
			_otherSpecialKeys[173] = '_'
		}
		else{
			_otherSpecialKeys[186] = ':'
			_otherSpecialKeys[189] = '_'
		}
	}

	/**
	 * Removing a single key and its functions
	 * @param {string} keys - The key to remove
	 */

	function _removeKey(keys){
		var obj = _preprocess(_stripSpaces(keys))
		var container = _registeredKeys[obj.newKey]
		if(!container){
			return ;
		}
		for(var i = 0;i < container.length;i++){
			if(obj.modifierFlag && container[i].modifier.sort().join(' ') === obj.modifier.sort().join(' ')){
				_registeredKeys[obj.newKey].splice(i,1)
				break;
			}
			else if(!obj.modifierFlag){
				_registeredKeys[obj.newKey].splice(i,1)
				break;
			}
		}
	}

	// Constructor

	/** 
	 * Shortcut constructor
	 * registers listeners
	 */


	function shortcut(target){
		_registerOtherKeys()
		target.addEventListener('keydown',_handleKeyPress)
	}


	// Public methods

	/**
	 * Exposes the push function so that the custom elements register key presses
	 */


	Object.defineProperty(shortcut,"push",{
		writable:false,
		value : function(entry){
			var oldkey = entry.oldKey
			if(oldkey){
				shortcut.unregister(oldkey)
			}
			if(!entry.newKey){
				return ;
			}
			var key = _stripSpaces(entry.newKey)  // don't know if we need this
			if(entry.type === 'regex'){
				_pushRegex(key,entry.value,options)
				return ;
			}
			var value = entry.value
			var returnedObject = _preprocess(key)
			var wait
			if(entry.options){
				wait = entry.options.wait? entry.options.wait:0
			}
			else{
				wait = 0
			}
			var type = typeof value
			if(_registeredKeys[returnedObject.newKey]){
				var pushed = true
				for(var i = 0; i < _registeredKeys.length;i++){
					if(_registeredKeys[i].modifier.sort().join(' ') === returnedObject.modifier.sort().join(' ')){
						_registeredKeys[returnedObject.newKey][i] = {
							type : type,
							value : value,
							modifier : returnedObject.modifier,
							modifierFlag : returnedObject.modifierFlag,
							wait : wait
						}
						pushed = false
						break;
					}
				}
				if(pushed){
					_registeredKeys[returnedObject.newKey].push({
						type : type,
						value : value,
						modifier : returnedObject.modifier,
						modifierFlag : returnedObject.modifierFlag,
						wait : wait
					})
				}
			}
			else{
				_registeredKeys[returnedObject.newKey] = [{
					type : type,
					value : value,
					modifier : returnedObject.modifier,
					modifierFlag : returnedObject.modifierFlag,
					wait : wait
				}]
			}
			
		}
	})


	/**
	 * Exposes the register function so that developers can register key pressess
	 */


	Object.defineProperty(shortcut,"register",{
		writable:false,
		value : function(keys,callback,options){
			if(options && options.type === 'regex'){
				_pushRegex(keys,callback,options)
			}
			var type = typeof keys 
			if(type !== 'string' && type !== 'object'){
				console.error("Invalid Type")
				return ;
			}
			if(type === 'object'){
				_processObject(keys,callback,options)
			}
			else{
				_processString(keys,callback,options)
			}
		}
	})


	/**
	 * Exposes the unregister function so that developers can unregister already registered keys
	 */


	Object.defineProperty(shortcut,"unregister",{
		writable:false,
		value : function(keys){
			if(typeof keys === 'object'){
				for(var i=0;i < keys.length;i++){
					var _key = keys[i]
					_removeKey(_key);
				}
			}
			else {
				_removeKey(keys);
			}
		}
	})

	/** 
	 * Exposes the unregisterAll function so developers can unregister all keys at once 
	 */


	 Object.defineProperty(shortcut,"unregisterAll",{
		writable:false,
		value : function(){
			for(var key in _registeredKeys){
				delete _registeredKeys[key]
			}
		}
	})



	// Intializing

	shortcut(document)
	window.shortcut = shortcut


})(window,document);
/*------------------------   NOTES   ------------------------*/
/*
  Date - 22/06/2018 - Documented
  1. Added scrollDivX property to check for horizontal scrolling.
  Date - 24/07/2018
  1. Added multiSelect option - to sort multiple items at a time.
  Date - 28/08/2018
  1. Added method to destroy sortable.
  Date - 13/09/2018
  1. Added omitRestricted - to exclude the restricted elements from list while calculating from and to index position.
*/
/*
	Issues with relative Horizontal scroll div - Fixed
*/


(function( window ) {

	if($L){	
		
		manageSortable = {
			keyPressed : false,
			keyValue : 0,
			countSortable : 0,
			init : false,
			isEqual : function (value, other) {
				if(value.length != other.length){
					return false;
				}
				for(var i = 0 ; i < value.length ; i++){
					if(other.indexOf(value[i]) == -1){
						return false;
					}
				}
				// If nothing failed, return true
				return true;
			},

			convertToArrayOfItems : function(selector){
				if(typeof selector != "string" && selector.length > 0){
					return selector;
				}
				var selectorArray = selector.split(',');
				var retArray = [];
				selectorArray.forEach(function(item,indexVal){
					var items = $L(item.trim()).e;
					if(items.length){
						for(var i=0;i < items.length ;i++){
							if(retArray.indexOf(items[i]) == -1){
								retArray.push(items[i]);
							}
						}
					}
					else{
						if(retArray.indexOf(items) == -1){
							retArray.push(items);
						}
					}
				});
				return retArray;
			},

			// keydown : function(event){
			// 	manageSortable.keyPressed = true;
			// 	manageSortable.keyValue = event.which;
			// 	// console.log(manageSortable.keyValue);
			// },

			// keyup : function(event){
			// 	manageSortable.keyPressed = false;
			// 	manageSortable.keyValue = 0;
			// },

			destroy : function(element){
				var childrens = Array.from(element.children).filter(function(node) { return node.tagName != 'TEMPLATE'});
				var sortableElemClass = element.getSortableClass();
				for(var i = 0; i<childrens.length; i++){
					childrens[i].classList.remove('sortable-element',sortableElemClass);
					if(childrens[i]._sortableData){
						childrens[i]._sortableData = null;
					}
				}
				element.classList.remove('sortable-parent');
				element._sortableData = null;
			},

			alreadySortable : function(elements){
				for(var i = 0; i<elements.length; i++){
					if($L(elements[i]).hasClass('sortable-parent') && elements[i]._sortableData){
						return {found : true, class : elements[i]._sortableData.sortableElemClass}
					}
				}
				return {found : undefined};
			}
		};

		// $L(document).bind('keydown',manageSortable.keydown);
		// $L(document).bind('keyup',manageSortable.keyup);
		
		$L.prototype.sortable = function(object) {
			if(!manageSortable.init){
				if (!Element.prototype.matches) {
				    Element.prototype.matches = 
				        Element.prototype.matchesSelector || 
				        Element.prototype.mozMatchesSelector ||
				        Element.prototype.msMatchesSelector || 
				        Element.prototype.oMatchesSelector || 
				        Element.prototype.webkitMatchesSelector ||
				        function(s) {
				            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
				                i = matches.length - 1;
				            while (i >= 0 && matches.item(i) !== this){
				            	--i;
				            	//gets the index of the matched item
				            }
				            return i > -1;            
				        };
				}
				manageSortable.init = true;
			}
			if(typeof object === "string" && object === "destroy"){
				if(this.e.length){
					var elemArray = this.e;
					for(var i = 0; i<elemArray.length; i++){
						manageSortable.destroy(elemArray[i]);
					}
				}
				else{
					manageSortable.destroy(this.e);
				}
				return;
			}
			var data = object ? object : {};
			
			if(this.e.length){
				var elemArray = this.e;
				if(!data.changed){
					++manageSortable.countSortable;
					data.changed = true;
				}
				var check = manageSortable.alreadySortable(this.e);
				if(check.found){
					data.sortableElemClass = check.class;
				}
				for(var i = 0 ; i < elemArray.length ; i++){
					$L(elemArray[i]).sortable(Object.assign({},data));
				};
				return;
			}

			var element = this.e.length == undefined ? this.e : this.e[0];

			if(this.e._sortableData){
				var _sortableData = this.e._sortableData;
				data._parentElem = data._parentElem == undefined ? _sortableData._parentElem : data._parentElem;

				//Data overriding
				data.containment = data.containment ? data.containment : _sortableData.containment;
				data.connected = data.connectedWith ? manageSortable.isEqual(data.connectedWith, _sortableData.connectedWith) : _sortableData.connected;
				data.connectedWith = data.connectedWith ? data.connectedWith : _sortableData.connectedWith;
				data.orientation = data.orientation ? data.orientation : _sortableData.orientation;
				data.droppable = (data.droppable == undefined) ? _sortableData.droppable : data.droppable;
				data.draggable = (data.draggable == undefined) ? _sortableData.draggable : data.draggable;
				data.sortableElemClass = _sortableData.sortableElemClass;	
				data.placeholder = data.placeholder ? data.placeholder : _sortableData.placeholder;
				data.disabled = data.disabled ? data.disabled : _sortableData.disabled;
				data.onReady = data.onReady ? data.onReady : _sortableData.onReady;
				data.onSelect = data.onSelect ? data.onSelect : _sortableData.onSelect;
				data.onDragStart = data.onDragStart ? data.onDragStart : _sortableData.onDragStart;
				data.onDrag = data.onDrag ? data.onDrag : _sortableData.onDrag;
				data.onPlaceholder = data.onPlaceholder ? data.onPlaceholder : _sortableData.onPlaceholder;
				data.onBeforeDrop = data.onBeforeDrop ? data.onBeforeDrop : _sortableData.onBeforeDrop;
				data.onDrop = data.onDrop ? data.onDrop : _sortableData.onDrop;
				data.cancel = data.cancel == undefined ? _sortableData.cancel : data.cancel instanceof Array ? data.cancel : data.cancel.split(",") ;
				data.tolerance = data.tolerance ? data.tolerance : _sortableData.tolerance;
				data.items = data.items == undefined ? _sortableData.items : data.items instanceof Array ? data.items : data.items.split(",");
				data.cursorAt = data.cursorAt == undefined ? _sortableData.cursorAt : data.cursorAt;
				data.restrict = data.restrict == undefined ? _sortableData.restrict : data.restrict instanceof Array ? data.restrict : data.restrict.split(",");
				data.scrollDivX = data.scrollDivX == undefined ? _sortableData.scrollDivX : typeof data.scrollDivX === "string" ? document.querySelector(data.scrollDivX) : data.scrollDivX;
				data.multiSelect = data.multiSelect == undefined ? _sortableData.multiSelect : data.multiSelect === true ? true : false;
				data.omitRestricted = data.omitRestricted == undefined ? _sortableData.omitRestricted : data.omitRestricted;
				// data.scrollDivY = data.scrollDivY == undefined ? _sortableData.scrollDivY : typeof data.scrollDivY === "string" ? this.e.closest(data.scrollDivY) : data.scrollDivY;
				// data.parentScrollDivX = data.scrollDivX ? data.scrollDivX.parentElement : _sortableData.scrollDivX;

				if(data.executeOnReady){
					data._parentElem.executedOnReady = false;
				}
			}
			else{

				if(!data.connected && !data.changed){
					// console.log(data,++manageSortable.countSortable);
					++manageSortable.countSortable;
					data.changed = true;
				}
				//Parent Element
				data._parentElem = this.e;
				var element = this.e;
				$L(data._parentElem).addClass('sortable-parent');

				//Data initialization
				data.containment = data.containment;
				data.connectedWith = data.connectedWith ? data.connectedWith : [];
				data.orientation = data.orientation ? data.orientation : "vertical";
				data.droppable = (data.droppable == undefined) ? true : data.droppable;
				data.draggable = (data.draggable == undefined) ? true : data.draggable;
				data.sortableElemClass = data.sortableElemClass ? data.sortableElemClass : element.parentElement && element.parentElement._sortableData ? element.parentElement._sortableData.sortableElemClass : (data.orientation === "horizontal") ? "sortable-element-h"+manageSortable.countSortable : "sortable-element-v"+manageSortable.countSortable;
				data.placeholder = data.placeholder ? data.placeholder : "lyteSortablePlaceholder";
				data.disabled = data.disabled ? data.disabled : "lyteSortableDisabledPlaceholder";
				data.cancel = data.cancel == undefined ? [] : data.cancel instanceof Array ? data.cancel : data.cancel.split(",");
				data.tolerance = data.tolerance ? data.tolerance : "intersect";
				data.items = data.items == undefined ? [] : data.items instanceof Array ? data.items : data.items.split(",");
				data.cursorAt = data.cursorAt;
				data.restrict = data.restrict == undefined ? [] : data.restrict instanceof Array ? data.restrict : data.restrict.split(",");
				data.scrollDivX = data.scrollDivX ? ( typeof data.scrollDivX === "string" ? document.querySelector(data.scrollDivX) : data.scrollDivX) : undefined;
				data.multiSelect = data.multiSelect === true ? true : false;
				data.omitRestricted = data.omitRestricted == undefined ? false : data.omitRestricted;
				// data.scrollDivY = data.scrollDivY ? ( typeof data.scrollDivY === "string" ? element.closest(data.scrollDivY) : data.scrollDivY) : undefined;
				// data.parentScrollDivX = data.scrollDivX ? data.scrollDivX.parentElement : undefined;
			}


			var _offset = [0,0];
			var _isDown = false;
			var _isMoved = false;
			var _mousePosition;
			var _elemBelow;
			var _droppablePlace;
			var _marginTop = 0;
			var _marginLeft = 0;
			var _sortableElemClass;
			var _sortableElem;
			var _placeholder = "";
			var _div = "";
			var _returnElemBelow;
			var _scrollLeft = 0;
			var _scrollTop = 0;
			var _requestId1 = null;
			var _requestId2 = null;
			var _animationFrameFired1 = false;
			var _animationFrameFired2 = false;
			var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                            window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
			var cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
			var _maxScrollWidth = 0;
			var _maxScrollHeight = 0;
			var _multiSelectedItems = [];
			var _prevMode = null;
			var _checkSelection = false;
			var prevTop = null;
			var _fromIndex = null;
			var _source = null;
			var _prevScrollDiv = null;

			function mouseDownEvent(event){
				
		
				//Disable right click on the sortable elements to avoid unwanted behaviour
				if(event.which == 3){
					return;
				}
				
				var target = event.target;

				while(target){
					if($L(target).hasClass("sortable-element")){
						_sortableElem = target;
						break;
					}
					target = target.parentElement;
				}

				if(_sortableElem && checkForSortable(_sortableElem._sortableData || _sortableElem.parentElement._sortableData, event.target) && checkForItems(_sortableElem._sortableData || _sortableElem.parentElement._sortableData, event.target)){
					event.preventDefault();
					if(!$L(_sortableElem).hasClass(_sortableElem.parentElement._sortableData.sortableElemClass)){
						$L(_sortableElem).addClass(_sortableElem.parentElement._sortableData.sortableElemClass)
					}
					var data = _sortableElem._sortableData || _sortableElem.parentElement._sortableData;
					_placeholder = _sortableElem.cloneNode(true);
					_placeholder.classList.remove('sortable-element-selected');
					data._div = _div = _sortableElem;
					var returnVal = true;
					storeFromAndSource(data);
					if(data.multiSelect){
						_multiSelectedItems = _div.parentElement._multiSelectedItems ? _div.parentElement._multiSelectedItems : [];
						if(_multiSelectedItems.length > 0 && _multiSelectedItems.indexOf(_div) != -1 ){
							// console.log("here came");
							data._checkSelection = true;
							returnVal = true;
						}
						else{
							//Callback fired
							if(data.onSelect,event){
								returnVal = onSelect(data);
							}
							if(returnVal){
								// var keyValue = manageSortable.keyValue;
								if(event.metaKey || event.ctrlKey /*keyValue == 91 || keyValue == 93 || keyValue == 224*/){
									if(_div.classList.contains('sortable-element-selected')){
										_div.classList.remove('sortable-element-selected');
										removeFromArray(_div);
									}
									else{
										// console.log('here 1')
										addToArray(_div,'single',_div.parentElement);
									}
								}
								else if(event.shiftKey){
									if(_div.classList.contains('sortable-element-selected')){
										_div.classList.remove('sortable-element-selected');
									}
									// console.log('here 2')
									addToArray(_div,'multiple',_div.parentElement);
								}
								else{
									if(_div.classList.contains('sortable-element-selected')){
										if(_prevMode = 'multiple'){
											removeClass(_multiSelectedItems);
											_multiSelectedItems = [];
											_div.parentElement._multiSelectedItems = [];
											// _div.classList.add('sortable-element-selected');
											addToArray(_div,'single',_div.parentElement);
											// console.log('here 3')
										}
										else{
											_div.classList.remove('sortable-element-selected');
											removeFromArray(_div);
											// console.log('here 4');
										}
										_prevMode = 'single';
									}
									else{
										// console.log('here 5')
										removeClass(_multiSelectedItems);
										_multiSelectedItems = [];
										_div.parentElement._multiSelectedItems = [];
										// _div.classList.add('sortable-element-selected');
										addToArray(_div,'single',_div.parentElement);
										// console.log(_multiSelectedItems);
									}
								}

							}
						}
					}
					else{
						//Callback fired
						if(data.onSelect){
							returnVal = onSelect(data,event);
						}
						if(returnVal){
							$L(_div).addClass("sortable-element-selected");
						}
					}
					if(returnVal){
						var sortableElemCS = window.getComputedStyle(_sortableElem);
						var divOffset = _div.getBoundingClientRect();
						if(data.scrollDivX && window.getComputedStyle(data.scrollDivX).position == "relative"){
							data._isRelative = true; 
						}
						else{
							data._isRelative = false;
						}
						
						if(sortableElemCS.marginTop){
							_marginTop = sortableElemCS.marginTop;
						}
						if(sortableElemCS.marginLeft){
							_marginLeft = sortableElemCS.marginLeft;
						}
						if(event.type == "mousedown"){
							_offset = [
								event.clientX - divOffset.left,
								event.clientY - divOffset.top
							];
						}
						else if(event.type == "touchstart"){
							_offset = [
								event.touches[0].clientX - divOffset.left,
								event.touches[0].clientY - divOffset.top
							];
							
							//Binding eventlistener for touch
							$L(_sortableElem).bind('touchmove',data._parentElem.__mouseMoveEvent);
							$L(_sortableElem).bind('touchend',data._parentElem.__mouseUpEvent);
						}

						if(data.multiSelect && (!_div.parentElement._multiSelectedItems || _div.parentElement._multiSelectedItems.length == 0)){
							_div.parentElement._multiSelectedItems = [_div];

						}
						//Binding the values to the draggable element
						data._isDown = true;
						data._placeholder = _placeholder;
						data._offset = _offset;
						data._marginTop = _marginTop;
						data._marginLeft = _marginLeft;
						data._event = event;
						data._placedPlaceholder = false;

						if(!_sortableElem._sortableData){
							_sortableElem._sortableData = data;
						}
						_placeholder = null;
						_div = null;
						_sortableElem = null;
						// console.log(_multiSelectedItems);
					}
					//Binding mousedown and mouseup event
					document.addEventListener('mousemove',mouseMoveEvent);
					document.addEventListener('mouseup',mouseUpEvent);
					
				}
				else{
					_sortableElem = null;
				}
			}

			var mouseMoveEvent = function(event){
				if(event.type == "touchmove"){
					event.preventDefault();
				}
				if(_animationFrameFired1 && _requestId1){
					cancelAnimationFrame(_requestId1);
					_animationFrameFired1 = false;
					_requestId1 = null;
				}
				if(_animationFrameFired2 && _requestId2){
					cancelAnimationFrame(_requestId2);
					_animationFrameFired2 = false;
					_requestId2 = null;
				}
				var target = event.target;
				while(target){
					if($L(target).hasClass("sortable-element-selected")){
						_sortableElem = target;
						break;
					}
					target = target.parentElement;
				}
				
				if(_sortableElem){

					var data = _sortableElem._sortableData;
					if(data && data._isDown){
						event.preventDefault();
						if(typeof document.body.style.MozUserSelect!="undefined"){
							document.body.style.MozUserSelect = "none";
						}
						_div = data._div;
						_placeholder = data._placeholder;
						_offset = data._offset;
						_marginTop = data._marginTop;
						_marginLeft = data._marginLeft;
						_sortableElemClass = data.sortableElemClass;

						var divOffset = _sortableElem.getBoundingClientRect(); 
						if(data.multiSelect){
							_multiSelectedItems = _div.parentElement._multiSelectedItems;
						}
						if(data.scrollDivX){
							_scrollLeft = data.scrollDivX.scrollLeft;
						}
						else{
							_scrollLeft = 0;
						}
						if(!data._placedPlaceholder){
							//onDragStart
							if(data.onDragStart){
								onDragStart(data);
							}
							divOffset = _sortableElem.getBoundingClientRect(); 

							//set containment properties
							if(data.containment){
								data.containmentDimensions = setContainment(data,_sortableElem);
							}
							else{
								data.containmentDimensions = null;
							}

							// console.log("getting called");
							var width = divOffset.width;
							var height = divOffset.height;
							var cellSpacing = 0;
							var parent = _sortableElem.offsetParent;
							if(data.scrollDivX){
								_maxScrollWidth = data.scrollDivX.scrollWidth - data.scrollDivX.getBoundingClientRect().width;
							}
							else{
								_maxScrollWidth = 0;
							}
							data._maxScrollWidth = _maxScrollWidth;
							if(parent.tagName.toLowerCase() == "table"){
								cellSpacing = parent.cellSpacing;
								if(cellSpacing == ""){
									cellSpacing = 2;
								}
							}
							while((parent.tagName.toLowerCase() == "table" || parent.tagName.toLowerCase() == "lyte-table-structure") && parent.style.position == ""){
								parent = parent.offsetParent;
							}
							var relativeParent = getRelativeParent(_div);
							if(relativeParent && !(parent.isEqualNode(relativeParent))){
								parent = relativeParent;
							}
							var parentOffset = parent.getBoundingClientRect();
							_div.style.top = divOffset.top - (parentOffset.top + parseInt(cellSpacing) + parseInt(_marginTop)) + 'px';
							_div.style.left = (divOffset.left + _scrollLeft) - (parentOffset.left + parseInt(_marginLeft)) + 'px';
							_div.style.boxSizing = "border-box";
							_div.style.zIndex = 3001;
							$L(_div).width(width);
							$L(_div).height(height);
							
							if(_sortableElem.tagName.toLowerCase() == "tr" || _sortableElem.tagName.toLowerCase() == "lyte-tr"){
								fixWidth(_sortableElem);
							}
							
							//Create placeholder and append it to the DOM
							$L(_placeholder).html("");
							$L(_placeholder).attr('id','dummy');
							$L(_placeholder).removeClass('sortableElem');
							$L(_placeholder).width(divOffset.width /*calculateWidth(_sortableElem)*/);
							if(data.multiSelect){
								$L(_placeholder).height(divOffset.height * _multiSelectedItems.length /*calculateHeight(_sortableElem)*/);
								for(var i = 0; i<_multiSelectedItems.length; i++){
									_multiSelectedItems[i].classList.add('lyteSortableElem');
								}
							}
							else{
								$L(_placeholder).height(divOffset.height /*calculateHeight(_sortableElem)*/);
								_div.classList.add('lyteSortableElem');
							}
							
							_placeholder.style.padding = "0px";

							//Insert the placeholder in the DOM and make the selected element's position absolute
							// _div.parentElement.insertBefore(_placeholder,_div);
							LyteComponent.insertBefore(_div,_placeholder)
							_div.style.position = "absolute";
							data._placedPlaceholder = true;
							// if(window.getComputedStyle(_placeholder).display == "inline"){
							// 	_placeholder.style.display = "inherit";
							// }
							data._div = _div;
							data._placeholder = _placeholder;
							data._prevTop = event.clientY;

						}

						//Find scroll div
						var scrollDiv;
						// if(data.scrollDivY){
						// 	scrollDiv = data.scrollDivY;
						// }
						// else{
							scrollDiv = findScrollDiv(_placeholder);
						// }
						if(scrollDiv && (!_prevScrollDiv || (_prevScrollDiv && !_prevScrollDiv.isEqualNode(scrollDiv)))){
							_maxScrollHeight = scrollDiv.scrollHeight - scrollDiv.offsetHeight;
							_prevScrollDiv = scrollDiv;
						}
						

						//Find scrollDiv is relative or contains any relative parent
						var isRelativeY = false;
						if(scrollDiv && window.getComputedStyle(scrollDiv).position == "relative"){
							isRelativeY = true;
							_scrollTop = scrollDiv.scrollTop;
						}
						else{
							_scrollTop = 0;
						}

						if(event.type == "mousemove"){
							_mousePosition = {
								x : event.clientX,
								y : event.clientY
							};
						}
						else if(event.type == "touchmove"){
							_mousePosition = {
								x : event.touches[0].clientX,
								y : event.touches[0].clientY
							};
						}
						
						if(data.multiSelect & _multiSelectedItems.length > 1){
							var width = divOffset.width;
							var height = divOffset.height;
							var parent = _div.offsetParent;
							var relativeParent = getRelativeParent(_div);
							if(relativeParent && !(parent.isEqualNode(relativeParent))){
								parent = relativeParent;
							}
							var parentOffset = parent.getBoundingClientRect();
							var placeholderOffset = _placeholder.getBoundingClientRect();
							var leftVal;
							var topVal;
							var scrollLeftValue = 0;
							if(data._isRelative){
								scrollLeftValue = _scrollLeft;
							}
							_div.style.left = _mousePosition.x - _offset[0] - parentOffset.left - parseInt(_marginLeft) + scrollLeftValue + "px";
							_div.style.top = _mousePosition.y - _offset[1] - parentOffset.top - parseInt(_marginTop) + _scrollTop + "px";
							var index = _multiSelectedItems.indexOf(_div);
							for(var i = index - 1; i >= 0; i--){
								_multiSelectedItems[i].style.left = _div.offsetLeft + "px";
								_multiSelectedItems[i].style.top = _multiSelectedItems[i+1].offsetTop - divOffset.height + "px";
								_multiSelectedItems[i].style.boxSizing = "border-box";
								_multiSelectedItems[i].style.zIndex = 3001;
								_multiSelectedItems[i].style.height = height + "px";
								_multiSelectedItems[i].style.width = width + "px";
								_multiSelectedItems[i].style.position = "absolute";
							}
							for(var i = index + 1; i < _multiSelectedItems.length; i++){
								_multiSelectedItems[i].style.left = _div.offsetLeft + "px";
								_multiSelectedItems[i].style.top = _multiSelectedItems[i-1].offsetTop + divOffset.height + "px";
								_multiSelectedItems[i].style.boxSizing = "border-box";
								_multiSelectedItems[i].style.zIndex = 3001;
								_multiSelectedItems[i].style.height = height + "px";
								_multiSelectedItems[i].style.width = width + "px";
								_multiSelectedItems[i].style.position = "absolute";
							}

							var topNBottom = getTopNBottom();
							divOffset = _div.getBoundingClientRect();
							var scrollDivOffset = scrollDiv ? scrollDiv.getBoundingClientRect() : 0;
							if(scrollDiv && (divOffset.left <= scrollDivOffset.right) && (divOffset.right >= scrollDivOffset.left)){
								_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,scrollDivOffset,_maxScrollHeight,topNBottom,isRelativeY,_mousePosition,_offset,parentOffset));
								_animationFrameFired1 = true;
							}

							//Find the below element over which the sortable element is being dragged
							// _div.style.display = "none";
							var prevDisplay = [];
							for(var i = 0; i<_multiSelectedItems.length; i++){
								prevDisplay.push(_multiSelectedItems[i].style.display ? _multiSelectedItems[i].style.display : "");
								_multiSelectedItems[i].style.display = "none";
							}
							_elemBelow = document.elementFromPoint(_mousePosition.x,_mousePosition.y);
							for(var i = 0; i<_multiSelectedItems.length; i++){
								_multiSelectedItems[i].style.display = prevDisplay[i];
							}

							if(!_elemBelow){
								return;
							}

							//Find the closest sortable element to sort with
							droppablePlace = _elemBelow.closest('.'+_sortableElemClass);

							if(droppablePlace && checkDroppable(droppablePlace,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition)){
								// console.log("inside 1");
								if($L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition) && checkForIntersect(_elemBelow,_mousePosition) && checkForBetween(_elemBelow,_mousePosition,_sortableElem,isRelativeY,scrollDiv)){
									// $L(_elemBelow).append(_placeholder);
									// console.log("inside 2");
									LyteComponent.appendChild(_elemBelow,_placeholder);
								}
								else{
									if((topNBottom.bottom - topNBottom.top) >= droppablePlace.offsetHeight){
										// console.log("inside 3");
										LyteComponent.insertBefore(droppablePlace,_placeholder);
									}
									else{
										if(data.tolerance == "pointer"){
											if(event.clientY < data._prevTop){
												LyteComponent.insertBefore(droppablePlace,_placeholder);
											}
											else{
												LyteComponent.insertAfter(droppablePlace,_placeholder);
											}
											data._prevTop = event.clientY;
										}
										if(data.tolerance == "intersect"){
											scrollDivOffset = droppablePlace.getBoundingClientRect();
											if(topNBottom.top < (scrollDivOffset.top)){
												// $L(droppablePlace).insertBefore(_placeholder);
												// console.log("inside 4");
												LyteComponent.insertBefore(droppablePlace,_placeholder);
											}
											else if(topNBottom.bottom > (scrollDivOffset.bottom)){
												// $L(droppablePlace).insertAfter(_placeholder);
												// console.log("inside 5");
												LyteComponent.insertAfter(droppablePlace,_placeholder);
											}
										}
									}
								}
							}
							else{
								if(prevTop && prevTop > topNBottom.top){
									_elemBelow = document.elementFromPoint(_mousePosition.x,topNBottom.top - 1);
									if(!_elemBelow){
										return;
									}
									droppablePlace = _elemBelow.closest('.'+_sortableElemClass);
									if(droppablePlace && droppablePlace.id != 'dummy' && topNBottom.top < (droppablePlace.getBoundingClientRect().top + (droppablePlace.getBoundingClientRect().height/2))){
										// console.log("inside 6");
										LyteComponent.insertBefore(droppablePlace,_placeholder);
									}
									else if(_elemBelow && $L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition) && checkForIntersect(_elemBelow,_mousePosition) && checkForBetween(_elemBelow,_mousePosition,_sortableElem,isRelativeY,scrollDiv)){
										// $L(_elemBelow).append(_placeholder);
										// console.log("inside 7");
										LyteComponent.appendChild(_elemBelow,_placeholder);
									}
								}
								else{
									_elemBelow = document.elementFromPoint(_mousePosition.x,topNBottom.bottom + 1);
									if(!_elemBelow){
										return;
									}
									droppablePlace = _elemBelow.closest('.'+_sortableElemClass);
									if(droppablePlace && droppablePlace.id != 'dummy' && topNBottom.bottom > (droppablePlace.getBoundingClientRect().bottom - (droppablePlace.getBoundingClientRect().height/2))){
										// console.log("inside 8");
										LyteComponent.insertAfter(droppablePlace,_placeholder);
									}
									else if(_elemBelow && $L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition) && checkForIntersect(_elemBelow,_mousePosition) && checkForBetween(_elemBelow,_mousePosition,_sortableElem,isRelativeY,scrollDiv)){
										// $L(_elemBelow).append(_placeholder);
										// console.log("inside 9");
										LyteComponent.appendChild(_elemBelow,_placeholder);
									}
								}
							}
							if(!data.onPlaceholder || checkValidDroppable(data,_elemBelow)){
								if($L(_placeholder).hasClass(data.disabled)){
									$L(_placeholder).removeClass(data.disabled);
								}
								$L(_placeholder).addClass(data.placeholder);
							}
							else{
								if($L(_placeholder).hasClass(data.placeholder)){
									$L(_placeholder).removeClass(data.placeholder);
								}
								$L(_placeholder).addClass(data.disabled);
							}
							prevTop = topNBottom.top;


						}
						else{
							var parent = _div.offsetParent;
							var relativeParent = getRelativeParent(_div);
							if(relativeParent && !(parent.isEqualNode(relativeParent))){
								parent = relativeParent;
							}
							var parentOffset = parent.getBoundingClientRect();
							var leftVal;
							var topVal;
							var scrollLeftValue = 0;
							if(data._isRelative){
								scrollLeftValue = _scrollLeft;
							}
							if(data.cursorAt){
								leftVal = _mousePosition.x - data.cursorAt.left - parentOffset.left - parseInt(_marginLeft) + scrollLeftValue;
								topVal = _mousePosition.y - data.cursorAt.top - parentOffset.top - parseInt(_marginTop) + _scrollTop;

								if(data.containment){
									if(leftVal >= data.containmentDimensions.offsetLeft && leftVal <= (data.containmentDimensions.offsetLeft + (data.containmentDimensions.width - divOffset.width))){
										_div.style.left = leftVal + 'px';
									}
									if(topVal >= data.containmentDimensions.offsetTop && topVal <= (data.containmentDimensions.offsetTop + (data.containmentDimensions.height - divOffset.height) + _scrollTop)){
										_div.style.top = topVal + 'px';
									}
								}
								else{
									_div.style.left = leftVal + 'px';
									_div.style.top = topVal + 'px';
								}
							}
							else{
								leftVal = _mousePosition.x - _offset[0] - parentOffset.left - parseInt(_marginLeft) + scrollLeftValue;
								topVal = _mousePosition.y - _offset[1] - parentOffset.top - parseInt(_marginTop) + _scrollTop;
								// console.log("left",leftVal);
								// console.log("top",topVal);
								// console.log("bottom",(data.containmentDimensions.offsetTop + (data.containmentDimensions.height - divOffset.height) + _scrollTop))
								if(data.containment){
									if(leftVal >= data.containmentDimensions.offsetLeft && leftVal <= (data.containmentDimensions.offsetLeft + (data.containmentDimensions.width - divOffset.width))){
										_div.style.left = leftVal + 'px';
									}
									if(topVal >= data.containmentDimensions.offsetTop && topVal <= (data.containmentDimensions.offsetTop + (data.containmentDimensions.height - divOffset.height) + _scrollTop)){
										// console.log("calculating");
										_div.style.top = topVal + 'px';
									}
								// 	if(topVal > (data.containmentDimensions.offsetTop + (data.containmentDimensions.height - divOffset.height) + _scrollTop)){
								// 		debugger
								// 	}
								}
								else{
									_div.style.left = leftVal + 'px';
									_div.style.top = topVal + 'px';
								}
							}

							divOffset = _div.getBoundingClientRect();
							var scrollDivOffset = scrollDiv ? scrollDiv.getBoundingClientRect() : 0;

							//Animation Frame fired for vertical scrolling
							if(scrollDiv && (divOffset.left <= scrollDivOffset.right) && (divOffset.right >= scrollDivOffset.left)){
								_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,scrollDivOffset,_maxScrollHeight,null,isRelativeY,_mousePosition,_offset,parentOffset));
								_animationFrameFired1 = true;
							}

							//Animation Frame fired for horizontal scrolling
							if(data.scrollDivX){
								scrollDivOffset = data.scrollDivX.getBoundingClientRect();
								if(divOffset.left <= scrollDivOffset.left || divOffset.right >= scrollDivOffset.right){
									_requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,scrollDivOffset,_mousePosition,_offset,parentOffset,data._isRelative));
									_animationFrameFired2 = true; 
								}
							}
							
							//Find the below element over which the sortable element is being dragged
							var prevDisplay = _div.style.display ? _div.style.display : "";
							_div.style.display = "none";
							_elemBelow = document.elementFromPoint(_mousePosition.x,_mousePosition.y);
							_div.style.display = prevDisplay;
							

							if(!_elemBelow){
								return;
							}

							//Find the closest sortable element to sort with
							droppablePlace = _elemBelow.closest('.'+_sortableElemClass);

							if(droppablePlace && checkDroppable(droppablePlace,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition)){
								
								if($L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition) && checkForIntersect(_elemBelow,_mousePosition) && checkForBetween(_elemBelow,_mousePosition,_sortableElem/*,isRelativeY,scrollDiv*/)){
									// $L(_elemBelow).append(_placeholder);
									LyteComponent.appendChild(_elemBelow,_placeholder);
								}
								else{
									if(data.tolerance == "pointer"){
										if(event.clientY < data._prevTop){
											LyteComponent.insertBefore(droppablePlace,_placeholder);
										}
										else{
											LyteComponent.insertAfter(droppablePlace,_placeholder);
										}
										data._prevTop = event.clientY;
									}
									if(data.tolerance == "intersect"){
										scrollDivOffset = droppablePlace.getBoundingClientRect();
										if(divOffset.top < (scrollDivOffset.top)){
											// $L(droppablePlace).insertBefore(_placeholder);
											LyteComponent.insertBefore(droppablePlace,_placeholder);
										}
										else if(divOffset.bottom > (scrollDivOffset.bottom)){
											// $L(droppablePlace).insertAfter(_placeholder);
											LyteComponent.insertAfter(droppablePlace,_placeholder);
										}
									}
								}
							}
							else if(_elemBelow && $L(_elemBelow).hasClass('sortable-parent') && checkParentDroppable(_elemBelow,_sortableElem.parentElement,_sortableElem,data.connectedWith,data.containmentDimensions,_mousePosition) && checkForIntersect(_elemBelow,_mousePosition) && checkForBetween(_elemBelow,_mousePosition,_sortableElem,isRelativeY,scrollDiv)){
								// $L(_elemBelow).append(_placeholder);
								LyteComponent.appendChild(_elemBelow,_placeholder);
							}
							// else{
							// 	console.log("checkParentDroppable",checkParentDroppable(_elemBelow,data._parentElem,_sortableElem,data.connectedWith));
							// 	console.log("checkForIntersect",checkForIntersect(_elemBelow,_mousePosition));
							// 	console.log("came here",_elemBelow);
							// }
							if(!data.onPlaceholder || checkValidDroppable(data,_elemBelow)){
								if($L(_placeholder).hasClass(data.disabled)){
									$L(_placeholder).removeClass(data.disabled);
								}
								$L(_placeholder).addClass(data.placeholder);
							}
							else{
								if($L(_placeholder).hasClass(data.placeholder)){
									$L(_placeholder).removeClass(data.placeholder);
								}
								$L(_placeholder).addClass(data.disabled);
							}
						}
						

						//Callback fired
						if(data.onDrag){
							onDrag(data,droppablePlace,_elemBelow,event);
						}

						data._isMoved = true;
						droppablePlace = null;
						_elemBelow = null;
					}
				}
			}

			var mouseUpEvent = function(event){
				var target = event.target;
				if(_animationFrameFired1 && _requestId1){
					cancelAnimationFrame(_requestId1);
					_animationFrameFired1 = false;
					_requestId1 = null;
				}
				if(_animationFrameFired2 && _requestId2){
					cancelAnimationFrame(_requestId2);
					_animationFrameFired2 = false;
					_requestId2 = null;
				}

				while(target){
					if($L(target).hasClass("sortable-element-selected")){
						_sortableElem = target;
						break;
					}
					target = target.parentElement;
				}
				if(_sortableElem){
					var data = _sortableElem._sortableData;
					var prevParent = _sortableElem.parentElement;
					//UnBinding mousedown and mouseup event
					document.removeEventListener('mousemove',mouseMoveEvent);
					document.removeEventListener('mouseup',mouseUpEvent);
					if(data.multiSelect){
						_multiSelectedItems = prevParent._multiSelectedItems;
					}
					// debugger
					if(data._isDown){
						data._isDown = false;
						_div = data._div;
						_placeholder = data._placeholder;
						if(data._isMoved){
							data._isMoved = false;
							var returnVal = true;

							if(data.multiSelect){
								//Callback fired
								if(data.onBeforeDrop){
									returnVal = onBeforeDrop(data,event);
								}
								removeClass(_multiSelectedItems);
								if($L(_placeholder).hasClass(data.disabled)){
									callRevertBack(data,"multiple");
									return;
								}

								if(!returnVal){
									callRevertBack(data,"multiple");
									return;
								}
								var sibling = (findPreviousElem(_placeholder) ? findPreviousElem(_placeholder) : findNextElem(_placeholder));
								var elementData = sibling && sibling._sortableData ? sibling._sortableData : _placeholder.parentElement._sortableData;
								// $L(_placeholder).replace(_div);
								
								var previousElementSibling = findPreviousElem(_placeholder);
								if(previousElementSibling){
									_placeholder.remove();
									for(var v=0; v<_multiSelectedItems.length; v++){
										removeStyle(_multiSelectedItems[v]);
										LyteComponent.insertAfter(previousElementSibling,_multiSelectedItems[v]);
										_multiSelectedItems[v]._sortableData = elementData;
										previousElementSibling = findNextElem(previousElementSibling);
									}
								}
								else{
									var nextElementSibling = findNextElem(_placeholder);
									if(nextElementSibling){
										_placeholder.remove();
										for(var v=_multiSelectedItems.length-1; v>=0; v--){
											removeStyle(_multiSelectedItems[v]);
											LyteComponent.insertBefore(nextElementSibling,_multiSelectedItems[v]);
											_multiSelectedItems[v]._sortableData = elementData;
											nextElementSibling = findPreviousElem(nextElementSibling);
										}
									}
									else{
										var parent = _placeholder.parentElement;
										_placeholder.remove();
										for(var v=0; v < _multiSelectedItems.length; v++){
											removeStyle(_multiSelectedItems[v]);
											LyteComponent.appendChild(parent,_multiSelectedItems[v]);
											_multiSelectedItems[v]._sortableData = elementData;
										}
									}
								}
								
								_multiSelectedItems = [];
								_placeholder = null;
								_prevMode = null;
								_checkSelection = false;
								prevParent._multiSelectedItems = [];

								//Callback fired
								if(data.onDrop){
									onDrop(data,event);
								}
							}
							else{
								//Callback fired
								if(data.onBeforeDrop){
									returnVal = onBeforeDrop(data,event);
								}

								if($L(_placeholder).hasClass(data.disabled)){
									callRevertBack(data);
									return;
								}

								if(!returnVal){
									callRevertBack(data);
									return;
								}
								
								var sibling = (findPreviousElem(_placeholder) ? findPreviousElem(_placeholder) : findNextElem(_placeholder));
								var elementData = sibling && sibling._sortableData ? sibling._sortableData : _placeholder.parentElement._sortableData;
								// $L(_placeholder).replace(_div);
								LyteComponent.replaceWith(_placeholder, _div);
								removeStyle(_div);

								_placeholder = null;

								_div._sortableData = elementData;

								//Callback fired
								if(data.onDrop){
									onDrop(data,event);
								}
								// if(!elementData.draggable){
								// 	$L(_div).unbind("mousedown",mouseDownEvent);
								// }
							}
						}
						else{
							if(data._checkSelection){
								// var keyValue = manageSortable.keyValue;
								if(event.metaKey || event.ctrlKey /*keyValue == 91 || keyValue == 93 || keyValue == 224*/){
									_div.classList.remove('sortable-element-selected');
									removeFromArray(_div);
								}
								else if(event.shiftKey /*keyValue == 16*/){
									removeClass(_multiSelectedItems);
									_multiSelectedItems = [];
									_div.parentElement._multiSelectedItems = [];
									addToArray(_div,"multiple",_div.parentElement);
								}
								else{
									removeClass(_multiSelectedItems);
									_multiSelectedItems = [];
									_div.parentElement._multiSelectedItems = [];
									addToArray(_div,'single',_div.parentElement);
								}
								data._checkSelection = false;
							}
							else if(!data.multiSelect){
								removeStyle(_div);
								if(_sortableElem.tagName.toLowerCase() == 'a'){
									window.location.href = _sortableElem.href;
								}
							}
						}
						data._div = null;
						data._placeholder = null;
						data._placedPlaceholder = false;

						//Unbinding the eventlisteners for touch
						if(event.type == "touchend"){
							$L(_sortableElem).unbind('touchmove',data._parentElem.__mouseMoveEvent);
							$L(_sortableElem).unbind('touchend',data._parentElem.__mouseUpEvent);
						}
					}
					else if(_multiSelectedItems.length > 0){
						removeClass(_multiSelectedItems);
						_multiSelectedItems = [];
						prevParent._multiSelectedItems = [];
					}
					if(!data.multiSelect){
						$L(_sortableElem).removeClass('sortable-element-selected');
					}
					_fromIndex = null;
					_source = null;
					_offset = null;
					_isDown = null;
					_isMoved = null;
					_mousePosition = null;
					_elemBelow = null;
					_droppablePlace = null;
					_marginTop = null;
					_marginLeft = null;
					_sortableElemClass = null;
					_sortableElem = null;
					_placeholder = null;
					_div = null;

					
				}
			}

			element.addToSortable = function(elem){
				elem._sortableData = element._sortableData;
				$L(elem).addClass("sortable-element",element._sortableData.sortableElemClass);
				// $L(elem).bind("mousedown",mouseDownEvent);
			};

			element.getSortableClass = function(){
				return element._sortableData.sortableElemClass;
			};

			var callForScrollX = function(data,parentOffset,_mousePosition,_offset,parent,isRelative){
				// console.log("Scroll X getting called");
				var divOffset = data._div.getBoundingClientRect();
				_scrollLeft = data.scrollDivX.scrollLeft;
				_maxScrollWidth = data._maxScrollWidth;
				if((divOffset.right >= parentOffset.right) && (_scrollLeft < _maxScrollWidth)){
					if((_maxScrollWidth - _scrollLeft) >= 5){
						data.scrollDivX.scrollLeft += 5;
						if(isRelative){
							data._div.style.left = _mousePosition.x - _offset[0] - parent.left + 5 + _scrollLeft + "px";
						}
					}
					else{
						data.scrollDivX.scrollLeft += (5 - (_maxScrollWidth - _scrollLeft));
						if(isRelative){
							data._div.style.left = _mousePosition.x - _offset[0] - parent.left + (5 - (_maxScrollWidth - _scrollLeft)) + _scrollLeft + "px";
						}
					}
				}
				else if((divOffset.left <= parentOffset.left) && (_scrollLeft > 0)){
					if(isRelative){
						data._div.style.left = _mousePosition.x - _offset[0] - parent.left - ((_maxScrollWidth - _scrollLeft) > 5 ? 5 : (5 - (_maxScrollWidth - _scrollLeft))) + _scrollLeft + "px";
					}
					data.scrollDivX.scrollLeft -= 5;
				}
				else{
					cancelAnimationFrame(_requestId2);
					_animationFrameFired2 = false;
					_requestId2 = null;
					return;
				}
				_requestId2 = requestAnimationFrame(callForScrollX.bind(this,data,parentOffset,_mousePosition,_offset,parent,isRelative)); 
			};

			var callForScrollY = function(data,scrollDiv,parentOffset,_maxScrollHeight,topNBottom,isRelativeY,_mousePosition,_offset,parent){
				// var scrollDiv = arguments[1];
				// var parentOffset = arguments[2];
				var divOffset = data._div.getBoundingClientRect();
				var diff = data._placeholder.parentElement.offsetTop - scrollDiv.offsetTop + 5;
				// var _maxScrollHeight = arguments[3];
				// var topNBottom = arguments[4];
				// var isRelativeY = arguments[5];
				var scrollTop = scrollDiv.scrollTop;
				if(data.multiSelect && topNBottom){
					if((topNBottom.top - parseInt(data._marginTop) <= parentOffset.top + diff) && (scrollTop > 0)){
						scrollDiv.scrollTop -= 10;
					}
					else if((topNBottom.bottom >= parentOffset.bottom) && (scrollTop < (scrollDiv.scrollHeight - parentOffset.height))){
						scrollDiv.scrollTop += 10;
					}
					else{
						cancelAnimationFrame(_requestId1);
						_animationFrameFired1 = false;
						_requestId1 = null;
						return;
					}
					_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,parentOffset,_maxScrollHeight,topNBottom,isRelativeY,_mousePosition,_offset,parent));
				}
				else{
					if((divOffset.top - parseInt(data._marginTop) <= parentOffset.top + diff) && (scrollTop > 0)){
						if(isRelativeY){
							data._div.style.top = _mousePosition.y - _offset[1] - parent.top - (_maxScrollHeight - scrollTop >= 10 ? 10 : _maxScrollHeight - scrollTop) + scrollTop + "px";
						}
						scrollDiv.scrollTop -= 10;
					}
					else if((divOffset.bottom >= (parentOffset.bottom - 3)) && (scrollTop < _maxScrollHeight)){
						if(_maxScrollHeight - scrollTop > 10){
							if(isRelativeY){
								data._div.style.top = _mousePosition.y - _offset[1] - parent.top + 10 + scrollTop + "px";
							}
							scrollDiv.scrollTop += 10;
						}
						else{
							if(isRelativeY){
								data._div.style.top = _mousePosition.y - _offset[1] - parent.top + _maxScrollHeight - scrollTop + scrollTop + "px";
							}
							scrollDiv.scrollTop += (_maxScrollHeight - scrollTop);
						}
					}
					else{
						cancelAnimationFrame(_requestId1);
						_animationFrameFired1 = false;
						_requestId1 = null;
						return;
					}
					_requestId1 = requestAnimationFrame(callForScrollY.bind(this,data,scrollDiv,parentOffset,_maxScrollHeight,topNBottom,isRelativeY,_mousePosition,_offset,parent));
				}
				
			};


			var isNotRestricted = function(data,targetElem){
				for(var i = 0; i<data.restrict.length ; i++){
					// var elements = document.querySelectorAll(data.restrict[i]);
					// for(var j = 0; j<elements.length; j++){
					// 	if(elements[j].isEqualNode(targetElem)){
					// 		return false;
					// 	}
					// }
					if(targetElem.matches(data.restrict[i])){
						return false;
					}
				}
				return true;
			};

			var checkForSortable = function(data,targetElem){
				for(var i = 0; i<data.cancel.length ; i++){
					// var elements = document.querySelectorAll(data.cancel[i]);
					// for(var j = 0; j<elements.length ; j++){
					// 	if(elements[j].isEqualNode(targetElem)){
					// 		return false;
					// 	}
					// }
					var elem = targetElem;
					while(elem.parentElement){
						if(elem.matches(data.cancel[i])){
							return false;
						}
						if($L(elem).hasClass('sortable-element')){
							break;
						}
						elem = elem.parentElement;
					}
				}
				return true;
			};

			var checkDroppedItemPosition = function(data, ele,siblings){
				if(data.omitRestricted){
					for(var y = 0; y<siblings.length; y++){
                        if(!isNotRestricted(data,siblings[y])){
                            siblings.splice(y,1);
                            --y;
                        }
                    }
				}
				for(var i = 0; i<siblings.length; i++){
					if(siblings[i].tagName != "TEMPLATE" && ele.isEqualNode(siblings[i])){
						return i;
					}
				}
			};

			var storeFromAndSource = function(data){
				_source = data._parentElem;
				if(data.omitRestricted){
					var siblings = Array.from(data._parentElem.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } );
					for(var y = 0; y<siblings.length; y++){
                        if(!isNotRestricted(data,siblings[y])){
                            siblings.splice(y,1);
                            --y;
                        }
                    }
                    _fromIndex = siblings.indexOf(data._div);
				}
				else{
					_fromIndex = Array.from(data._parentElem.children).filter( function(ele) { return ele.tagName != "TEMPLATE" } ).indexOf(data._div);
				}
			}

			/*---------------Callbacks Start--------------*/
			var onReady = function(data){
				data.onReady(data._parentElem);
			}

			var onSelect = function(data,event){
				var returnVal = data.onSelect(data._div, _fromIndex, data._parentElem,event);
				return ( returnVal == undefined) ? true : returnVal;
			}

			var onDragStart = function(data){
				data.onDragStart(data._div,data._parentElem);
			}

			var onDrag = function(data,droppableElem,elemBelow,event){

				_returnElemBelow = droppableElem || elemBelow;
				data.onDrag(data._div,_returnElemBelow,event);
			}

			var onBeforeDrop = function(data,event){

				var returnVal = data.onBeforeDrop(data._div,_returnElemBelow,data._placeholder,_fromIndex, checkDroppedItemPosition(data, data._placeholder,Array.from(data._placeholder.parentElement.children).filter(function(ele){ return ele.tagName != "TEMPLATE" && !($L(ele).hasClass('sortable-element-selected')) })), _source, data._placeholder ? data._placeholder.parentElement : null,event);
				return (returnVal == undefined) ? true : returnVal;
			}

			var onDrop = function(data,event){
				data.onDrop(data._div, data._div._sortableData._parentElem, _returnElemBelow, _fromIndex, checkDroppedItemPosition(data, data._div,Array.from(data._div._sortableData._parentElem.children).filter(function(ele){ return ele.tagName != "TEMPLATE" })), _source, event);
			}
			/*---------------Callbacks End--------------*/

			var checkValidDroppable = function(data,destination){
				if(destination.id && destination.id == "dummy"){
					destination = destination.parentElement;
				}
				else{
					while(destination){
						if($L(destination).hasClass('sortable-parent')){
							break;
						}
						destination = destination.parentElement;
					}
				}
				var returnVal = data.onPlaceholder(data._div,data._placeholder, data._parentElem, data._placeholder ? data._placeholder.parentElement : null);
				return (returnVal == undefined) ? true : returnVal;
			}


			//Bind events to the child elements that will be sortable
			var childrens = data._parentElem.children;
			data._parentElem.__mouseMoveEvent = mouseMoveEvent;
			data._parentElem.__mouseUpEvent = mouseUpEvent;
			data._parentElem._sortableData = data;
			for(var i = 0 ; i < childrens.length ; i++){
				if(childrens[i].tagName != "TEMPLATE" && isNotRestricted(data,childrens[i])){
					childrens[i]._sortableData = data;
					$L(childrens[i]).addClass("sortable-element",data.sortableElemClass);
				}
			}
			if(data.draggable){
				data._parentElem.addEventListener("mousedown",mouseDownEvent);
				$L(data._parentElem).bind("touchstart",mouseDownEvent);
			}
			else{
				if(data._parentElem._mousedown){
					data._parentElem.removeEventListener("mousedown",mouseDownEvent);
					$L(data._parentElem).unbind("touchstart",mouseDownEvent);
				}
			}
			

			
			
			//Check whether the arrays are connected or not and has connectedWith
			if(!data.connected && data.connectedWith.length > 0){
				data.connectedWith = manageSortable.convertToArrayOfItems(data.connectedWith);
				data.connectedWith.forEach(function(id){
					var connectedWith = data.connectedWith.concat();
					index = connectedWith.indexOf(id);
					connectedWith.splice(index,1);
					connectedWith.push(data._parentElem);
					$L(id).sortable({
						_parentElem : $L(id).e,
						connectedWith : connectedWith,
						connected : true,
						droppable : data.droppable,
						draggable : data.draggable,
						placeholder : data.placeholder,
						disabled : data.disabled,
						orientation : data.orientation,
						cancel : data.cancel,
						items : data.items,
						cursorAt : data.cursorAt,
						restrict : data.restrict,
						scrollDivX : data.scrollDivX,
						multiSelect : data.multiSelect,
						omitRestricted : data.omitRestricted
					});
				});
				
			}

			if(data.onReady && !data._parentElem.executedOnReady){
				onReady(data);
				data._parentElem.executedOnReady = true;
			}

			var setContainment = function(data,sortableElem){
				if(data.containment == "parent"){
					var dimensions = sortableElem.parentElement.getBoundingClientRect();
					return ({left : dimensions.left,
							right : dimensions.right,
							top : dimensions.top,
							bottom : dimensions.bottom,
							height : dimensions.height,
							width : dimensions.width,
							offsetLeft : sortableElem.parentElement.offsetLeft,
							offsetTop : sortableElem.parentElement.offsetTop});
				}
				else{
					var containment = $L(data.containment).e.length == undefined ? $L(data.containment).e : $L(data.containment).e[0];
					var dimensions = containment.getBoundingClientRect();
					return ({left : dimensions.left,
							right : dimensions.right,
							top : dimensions.top,
							bottom : dimensions.bottom,
							height : dimensions.height,
							width : dimensions.width,
							offsetLeft : containment.offsetLeft,
							offsetTop : containment.offsetTop});
				}
			};

			/*----------------------- UTILITY FUNCTIONS FOR SORTABLE ---------------------*/

			/*----------------------- UTILITY FUNCTIONS FOR MULTISELECT SORTABLE - START ---------------------*/
			//Removes some items from the array
			var removeFromArray = function(item){
				var _multiSelectedItems = item.parentElement._multiSelectedItems;
				if(_multiSelectedItems.length > 0){
					var index = _multiSelectedItems.indexOf(item);
					_multiSelectedItems.splice(index,1);
				}
				item.parentElement._multiSelectedItems = _multiSelectedItems;
			};


			//Adds the selected items to an array for multiselected drag and drop
			var addToArray = function(item,mode,parent){
				var _multiSelectedItems = parent._multiSelectedItems ? parent._multiSelectedItems : [];
				if(mode === "single"){
					if(_multiSelectedItems.length > 0){
						var lastItem = _multiSelectedItems[_multiSelectedItems.length - 1];
						if(lastItem.parentElement != parent){
							removeClass(_multiSelectedItems);
							_multiSelectedItems = [];
							lastItem.parentElement._multiSelectedItems = _multiSelectedItems;
							addToArray(item,mode,parent);
						}
						else{
							item.classList.add('sortable-element-selected');
							positionalPush(item);
						}
					}
					else{
						_multiSelectedItems.push(item);
						item.classList.add('sortable-element-selected');
					}
					_prevMode = mode;
				}
				if(mode == "multiple"){
					if(_prevMode == "multiple" || _prevMode == null){
						if(_multiSelectedItems.length > 0){
							var lastItem = _multiSelectedItems[_multiSelectedItems.length-1];
							if(lastItem.parentElement != parent){
								removeClass(_multiSelectedItems);
								_multiSelectedItems = [];
								lastItem.parentElement._multiSelectedItems = _multiSelectedItems;
								_prevMode = 'multiple';
								addToArray(item,mode,parent);
							}
							else{
								var childrens = Array.from(parent.children).filter(function(ele){ return ele.tagName != 'TEMPLATE'});
								var lastItemIndex = childrens.indexOf(lastItem);
								var index = childrens.indexOf(item);
								var index = childrens.indexOf(item);
								if(index > lastItemIndex){
									for(var v = lastItemIndex+1 ; v <= index; v++){
										_multiSelectedItems.push(childrens[v]);
										childrens[v].classList.add('sortable-element-selected');
									}
								}
								else{
									removeClass(_multiSelectedItems);
									_multiSelectedItems = [];
									for(var v = index; v<= lastItemIndex; v++){
										_multiSelectedItems.push(childrens[v]);
										childrens[v].classList.add('sortable-element-selected');
									}
								}
							}
						}
						else{
							var childrens = Array.from(parent.children).filter(function(ele) { return ele.tagName != 'TEMPLATE'});
							var index = childrens.indexOf(item);
							
							for(var v = 0;v <= index; v++){
								_multiSelectedItems.push(childrens[v]);
								childrens[v].classList.add('sortable-element-selected');
							}
						}
					}
					if(_prevMode == "single"){
						var lastItem;
						if(_multiSelectedItems.length > 0 && _multiSelectedItems[_multiSelectedItems.length - 1].parentElement == parent){
							lastItem = _multiSelectedItems[_multiSelectedItems.length - 1];
							var childrens = Array.from(parent.children).filter(function(ele){ return ele.tagName != 'TEMPLATE'});
							var lastItemIndex = childrens.indexOf(lastItem);
							var index = childrens.indexOf(item);
							if(index > lastItemIndex){
								for(var v = lastItemIndex+1 ; v <= index; v++){
									_multiSelectedItems.push(childrens[v]);
									childrens[v].classList.add('sortable-element-selected');
								}
							}
							else{
								removeClass(_multiSelectedItems);
								_multiSelectedItems = [];
								for(var v = index; v<= lastItemIndex; v++){
									_multiSelectedItems.push(childrens[v]);
									childrens[v].classList.add('sortable-element-selected');
								}
							}
						}
						else{
							removeClass(_multiSelectedItems);
							_multiSelectedItems = [];
							if(lastItem){
								lastItem.parentElement._multiSelectedItems = _multiSelectedItems;
							}
							_prevMode = 'multiple';
							addToArray(item,mode,parent);
						}
					}
					_prevMode = mode;
				}
				checkForUnwanted(_multiSelectedItems);
				parent._multiSelectedItems = _multiSelectedItems;
			};

			var checkForUnwanted = function(items){
				var newItems = Array.from(document.querySelectorAll('.sortable-element-selected'));
				if(newItems.length != items.length){
					for(var i = 0; i<newItems.length; i++){
						if(items.indexOf(newItems[i]) == -1){
							newItems[i].classList.remove('sortable-element-selected');
							newItems[i].parentElement._multiSelectedItems = [];
						}
					}
				}
			};

			var removeClass = function(arrayItems){
				for(var i = 0; i<arrayItems.length; i++){
					arrayItems[i].classList.remove('sortable-element-selected');
				}
			};

			var positionalPush = function(item){
				var pos = 0;
				for(var v = 0 ; v < _multiSelectedItems.length ; v++){
					if(_multiSelectedItems[v].offsetTop > item.offsetTop){
						break;
					}
					else{
						++pos;
					}
				}
				_multiSelectedItems.splice(pos,0,item);
			};

			//Gets the top and bottom for multiSelected items
			var getTopNBottom = function(prop){
				return {top :_multiSelectedItems[0].getBoundingClientRect().top,
						bottom :_multiSelectedItems[_multiSelectedItems.length - 1].getBoundingClientRect().bottom};
			};

			var findPlaceholderPosition = function(placeholder){
				var childrens = Array.from(placeholder.parentElement.children).filter(function(ele){ return ele.tagName != 'TEMPLATE'});
				return childrens.indexOf(placeholder);
			}
			/*----------------------- UTILITY FUNCTIONS FOR MULTISELECT SORTABLE - END ---------------------*/

			var findScrollDiv = function(elem){
				var parent = elem.parentElement;
				while(elem.parentElement){
					elem = elem.parentElement;
					if((parent.scrollHeight > elem.clientHeight) && ((window.getComputedStyle(elem).overflow != "hidden" && window.getComputedStyle(elem).overflow != "visible") || elem.matches('.lyteScrollBar')) /*!(elem.style.overflow && elem.style.overflow == 'hidden')*/){
						return elem;
					}
				}
				return null;
			};

			var fixWidth = function(element){
				var childrens = element.children;
				for(var i = 0; i<childrens.length; i++){
					if(childrens[i].tagName.toLowerCase() == "td" || childrens[i].tagName.toLowerCase() == "lyte-td"){
						if(childrens[i].style.width){
							childrens[i].style.width = childrens[i].style.width;
						}
						else{
							$L(childrens[i]).width($L(childrens[i]).width());
						}
					}
				}
			};

			var calculateHeight = function(element) {
				var cs = getComputedStyle(element);

				var paddingY = parseFloat(cs.paddingTop) + parseFloat(cs.paddingBottom);

				var borderY = parseFloat(cs.borderTopWidth) + parseFloat(cs.borderBottomWidth);

				// Element height minus padding and border
				elementHeight = element.offsetHeight - paddingY - borderY;
				return elementHeight;
			};

			var calculateWidth = function(element) {
				var cs = getComputedStyle(element);

				var paddingX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);

				var borderX = parseFloat(cs.borderLeftWidth) + parseFloat(cs.borderRightWidth);

				// Element width minus padding and border
				elementWidth = element.offsetWidth - paddingX - borderX;
				return elementWidth;
			};

			var getRelativeParent = function(element){
				while(element.parentElement){
					element = element.parentElement;
					var cs = getComputedStyle(element);
					if(cs.position == "relative"){
						return element;
					}
				}
				return null;
			};

			//Checks whether the element can be dropped or not
			var checkDroppable = function(element,parentElem,sortableElem,connectedWith,containmentDimensions,mP){
				if(element.id != "dummy"){
					var sortableParentId = sortableElem.parentElement.id;
					var droppableParentId = element.parentElement.id;
					if(containmentDimensions){
						if(mP.x < containmentDimensions.left || mP.x > containmentDimensions.right || mP.y < containmentDimensions.top || mP.y > containmentDimensions.bottom){
							return false;
						}
					}
					if(sortableElem.parentElement.isEqualNode(element.parentElement) || element.parentElement.isEqualNode(sortableElem._sortableData._parentElem)){
						return true;
					}
					if(((connectedWith).indexOf(element.parentElement) != -1) && element._sortableData.droppable){
						return true;
					}
				}
				return false;
			};

			//Checks whwther the element can be dropped or not 
			var checkParentDroppable = function(element,parentElem,sortableElem,connectedWith,containmentDimensions,mP){
				var sortableParentId = sortableElem.parentElement.id;
				if(containmentDimensions){
					if(mP.x < containmentDimensions.left || mP.x > containmentDimensions.right || mP.y < containmentDimensions.top || mP.y > containmentDimensions.bottom){
						return false;
					}
				} 
				if(sortableElem.parentElement.isEqualNode(element) || element.isEqualNode(parentElem)){
					return true;
				}
				if(((connectedWith).indexOf(element) != -1) && checkDroppableValue(element)){
					return true;
				}
				return false;
			};

			var checkDroppableValue = function(element){
				var childrens = element.children;
				var childElem;
				for(var v= 0; v<childrens.length; v++){
					if(childrens[v] != element.querySelector("#dummy") && childrens[v].tagName != "TEMPLATE" && $L(childrens[v]).hasClass('sortable-element')){
						childElem = childrens[v];
						break;
					}
				}
				return (childElem && childElem._sortableData ? childElem._sortableData.droppable : element._sortableData.droppable);
			};

			//Checks for appending the sortable elements at the end of the div
			var checkPossiblePosition = function(element,sortableElem){
				if(element.childElementCount > 0){
					var lastChild = element.lastElementChild;
					if(sortableElem.getBoundingClientRect().top > lastChild.getBoundingClientRect().bottom){
						return true
					}
				}
				else{
					return true;
				}
				return false;
			};

			var checkIfDroppable = function(parentElem,ele){
				if(ele.parentElement === parentElem && parentElem.childElementCount === 1 && (((ele.getBoundingClientRect().right > (parentElem.getBoundingClientRect().left + ele.getBoundingClientRect().width / 2)) && 
					(ele.getBoundingClientRect().right <= parentElem.getBoundingClientRect().right)) || ((ele.getBoundingClientRect().left < (parentElem.getBoundingClientRect().right - ele.getBoundingClientRect().width / 2)) && 
					(ele.getBoundingClientRect().left >= parentElem.getBoundingClientRect().left)))){
					return true;
				}
				return false;
			};

			var checkForIntersect = function(parentElem,mP){
				var cs = window.getComputedStyle(parentElem);
				var offset = parentElem.getBoundingClientRect();
				// console.log("cs",cs);
				// console.log("offset",offset);
				// console.log("_mousePosition",mP.x,mP.y);
				if(mP.x > (offset.left + parseFloat(cs.paddingLeft || 0)) && mP.x < (offset.right - parseFloat(cs.paddingRight || 0)) && mP.y > (offset.top + parseFloat(cs.paddingTop || 0)) && mP.y < (offset.bottom - parseFloat(cs.paddingBottom || 0))){
					return true;
				}
				return false; 
			};

			var checkForBetween = function(parentElem,mP,div,isRelativeY,scrollDiv){
				var childrens = parentElem.children;
				var templateTags = 0;
				var childElem = [];
				for(var i = 0;i<childrens.length;i++){
					if(childrens[i].tagName != "TEMPLATE" && childrens[i].id != "dummy" && isNotRestricted(parentElem._sortableData,childrens[i])){
						childElem.push(childrens[i]);
					}
					else{
						templateTags++;
					}
				}
				if(templateTags == childrens.length){
					return true;
				}
				else if((childElem.length == 1 && childElem[childElem.length - 1].isEqualNode(div)) || (childElem.length > 1 && childElem[childElem.length - 1].isEqualNode(div) && div.getBoundingClientRect().top > (childElem[childElem.length - 2].getBoundingClientRect().bottom + (isRelativeY ? scrollDiv.scrollTop : 0)))){
					return true;
				}
				else if(div.getBoundingClientRect().top > (childElem[childElem.length - 1].getBoundingClientRect().bottom + (isRelativeY ? scrollDiv.scrollTop : 0))){
					return true;
				}
				return false;
			};

			var callRevertBack = function(data) {
				$L(data._div).removeClass("sortable-element-selected");
				removeStyle(data._div);
				data._placeholder.remove();
			};

			var removeStyle = function(element){
				element.style.position = '';
				element.style.top = '';
				element.style.left = '';
				element.style.width = '';
				element.style.height = '';
				// element.style.display = '';
				element.style.zIndex = '';
				element.style.boxSizing = '';
				$L(element).removeClass('lyteSortableElem');
			};

			var findPreviousElem = function(elem){
				while(elem.previousElementSibling){
					elem = elem.previousElementSibling;
					if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
						return elem;
					}
				}
				return null;
			};

			var findNextElem = function(elem){
				while(elem.nextElementSibling){
					elem = elem.nextElementSibling;
					if(elem.tagName != "TEMPLATE" && $L(elem).hasClass('sortable-element')){
						return elem;
					}
				}
				return null;
			};

			var checkForItems = function(data,targetElem){
				if(data.items.length > 0){
					for(var i = 0 ; i<data.items.length ; i++){
						var elements = document.querySelectorAll(data.items[i]);
						for(var j = 0; j<elements.length; j++){
							if(elements[j].isEqualNode(targetElem)){
								return true;
							}
						}
					}
				}
				else{
					return true;
				}
				return false;
			};

		}
		
	}

})( window );
